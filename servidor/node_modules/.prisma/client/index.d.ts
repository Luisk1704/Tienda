
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Proveedor
 * 
 */
export type Proveedor = {
  id: number
  nombre: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Ropa
 * 
 */
export type Ropa = {
  id: number
  vendedorId: number
  nombre: string
  precio: Prisma.Decimal
  estado: string
  cantidad: number
  proveedorId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model PedidoRopa
 * 
 */
export type PedidoRopa = {
  id: number
  idRopa: number
  idPedido: number
  cantidad: number
  subtotal: Prisma.Decimal
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Pedido
 * 
 */
export type Pedido = {
  id: number
  fechaOrden: Date
  idPago: number
  clienteId: number
  direccionId: number
  descuento: Prisma.Decimal
  IV: Prisma.Decimal
  estado: string
  subtotal: Prisma.Decimal
  Total: Prisma.Decimal
  fecha: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Usuario
 * 
 */
export type Usuario = {
  id: number
  nombre: string
  cedula: string
  telefono: string
  correo: string
  contrasenna: string
  estado: boolean
  rol: Rol
  createdAt: Date
  updatedAt: Date
}

/**
 * Model MetodoPago
 * 
 */
export type MetodoPago = {
  id: number
  idCliente: number
  descripcion: string
  proveedor: string
  numeroCuenta: string
  fechaExpiracion: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Pregunta
 * 
 */
export type Pregunta = {
  id: number
  descripcion: string
  usuarioId: number
  ropaId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Respuesta
 * 
 */
export type Respuesta = {
  id: number
  descripcion: string
  usuarioId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Informe
 * 
 */
export type Informe = {
  id: number
  descripcion: string
  usuarioId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Evaluacion
 * 
 */
export type Evaluacion = {
  id: number
  nombre: string
  usuarioId: number
  pedidoId: number
  nota: number
  descripcion: string | null
  usuarioRol: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Categoria
 * 
 */
export type Categoria = {
  id: number
  descripcion: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Direccion
 * 
 */
export type Direccion = {
  id: number
  usuarioId: number
  provincia: string
  canton: string
  distrito: string
  direccionExacta: string
  codPostal: string
  telef: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Foto
 * 
 */
export type Foto = {
  id: number
  ropaId: number
  foto: string
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Rol: {
  ADMINISTRADOR: 'ADMINISTRADOR',
  VENDEDOR: 'VENDEDOR',
  CLIENTE: 'CLIENTE',
  USUARIO: 'USUARIO'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Proveedors
 * const proveedors = await prisma.proveedor.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Proveedors
   * const proveedors = await prisma.proveedor.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.proveedor`: Exposes CRUD operations for the **Proveedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedors
    * const proveedors = await prisma.proveedor.findMany()
    * ```
    */
  get proveedor(): Prisma.ProveedorDelegate<GlobalReject>;

  /**
   * `prisma.ropa`: Exposes CRUD operations for the **Ropa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ropas
    * const ropas = await prisma.ropa.findMany()
    * ```
    */
  get ropa(): Prisma.RopaDelegate<GlobalReject>;

  /**
   * `prisma.pedidoRopa`: Exposes CRUD operations for the **PedidoRopa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PedidoRopas
    * const pedidoRopas = await prisma.pedidoRopa.findMany()
    * ```
    */
  get pedidoRopa(): Prisma.PedidoRopaDelegate<GlobalReject>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<GlobalReject>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<GlobalReject>;

  /**
   * `prisma.metodoPago`: Exposes CRUD operations for the **MetodoPago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetodoPagos
    * const metodoPagos = await prisma.metodoPago.findMany()
    * ```
    */
  get metodoPago(): Prisma.MetodoPagoDelegate<GlobalReject>;

  /**
   * `prisma.pregunta`: Exposes CRUD operations for the **Pregunta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preguntas
    * const preguntas = await prisma.pregunta.findMany()
    * ```
    */
  get pregunta(): Prisma.PreguntaDelegate<GlobalReject>;

  /**
   * `prisma.respuesta`: Exposes CRUD operations for the **Respuesta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Respuestas
    * const respuestas = await prisma.respuesta.findMany()
    * ```
    */
  get respuesta(): Prisma.RespuestaDelegate<GlobalReject>;

  /**
   * `prisma.informe`: Exposes CRUD operations for the **Informe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Informes
    * const informes = await prisma.informe.findMany()
    * ```
    */
  get informe(): Prisma.InformeDelegate<GlobalReject>;

  /**
   * `prisma.evaluacion`: Exposes CRUD operations for the **Evaluacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluacions
    * const evaluacions = await prisma.evaluacion.findMany()
    * ```
    */
  get evaluacion(): Prisma.EvaluacionDelegate<GlobalReject>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<GlobalReject>;

  /**
   * `prisma.direccion`: Exposes CRUD operations for the **Direccion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Direccions
    * const direccions = await prisma.direccion.findMany()
    * ```
    */
  get direccion(): Prisma.DireccionDelegate<GlobalReject>;

  /**
   * `prisma.foto`: Exposes CRUD operations for the **Foto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fotos
    * const fotos = await prisma.foto.findMany()
    * ```
    */
  get foto(): Prisma.FotoDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.1
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Proveedor: 'Proveedor',
    Ropa: 'Ropa',
    PedidoRopa: 'PedidoRopa',
    Pedido: 'Pedido',
    Usuario: 'Usuario',
    MetodoPago: 'MetodoPago',
    Pregunta: 'Pregunta',
    Respuesta: 'Respuesta',
    Informe: 'Informe',
    Evaluacion: 'Evaluacion',
    Categoria: 'Categoria',
    Direccion: 'Direccion',
    Foto: 'Foto'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProveedorCountOutputType
   */


  export type ProveedorCountOutputType = {
    ropas: number
  }

  export type ProveedorCountOutputTypeSelect = {
    ropas?: boolean
  }

  export type ProveedorCountOutputTypeGetPayload<S extends boolean | null | undefined | ProveedorCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProveedorCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProveedorCountOutputTypeArgs)
    ? ProveedorCountOutputType 
    : S extends { select: any } & (ProveedorCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProveedorCountOutputType ? ProveedorCountOutputType[P] : never
  } 
      : ProveedorCountOutputType




  // Custom InputTypes

  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProveedorCountOutputType
     */
    select?: ProveedorCountOutputTypeSelect | null
  }



  /**
   * Count Type RopaCountOutputType
   */


  export type RopaCountOutputType = {
    categorias: number
    fotos: number
    ordenes: number
    preguntas: number
  }

  export type RopaCountOutputTypeSelect = {
    categorias?: boolean
    fotos?: boolean
    ordenes?: boolean
    preguntas?: boolean
  }

  export type RopaCountOutputTypeGetPayload<S extends boolean | null | undefined | RopaCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RopaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RopaCountOutputTypeArgs)
    ? RopaCountOutputType 
    : S extends { select: any } & (RopaCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RopaCountOutputType ? RopaCountOutputType[P] : never
  } 
      : RopaCountOutputType




  // Custom InputTypes

  /**
   * RopaCountOutputType without action
   */
  export type RopaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RopaCountOutputType
     */
    select?: RopaCountOutputTypeSelect | null
  }



  /**
   * Count Type PedidoCountOutputType
   */


  export type PedidoCountOutputType = {
    ropas: number
    evaluaciones: number
  }

  export type PedidoCountOutputTypeSelect = {
    ropas?: boolean
    evaluaciones?: boolean
  }

  export type PedidoCountOutputTypeGetPayload<S extends boolean | null | undefined | PedidoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PedidoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PedidoCountOutputTypeArgs)
    ? PedidoCountOutputType 
    : S extends { select: any } & (PedidoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PedidoCountOutputType ? PedidoCountOutputType[P] : never
  } 
      : PedidoCountOutputType




  // Custom InputTypes

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     */
    select?: PedidoCountOutputTypeSelect | null
  }



  /**
   * Count Type UsuarioCountOutputType
   */


  export type UsuarioCountOutputType = {
    metodos: number
    pedidos: number
    direcciones: number
    preguntas: number
    respuestas: number
    informes: number
    evaluaciones: number
    ropas: number
  }

  export type UsuarioCountOutputTypeSelect = {
    metodos?: boolean
    pedidos?: boolean
    direcciones?: boolean
    preguntas?: boolean
    respuestas?: boolean
    informes?: boolean
    evaluaciones?: boolean
    ropas?: boolean
  }

  export type UsuarioCountOutputTypeGetPayload<S extends boolean | null | undefined | UsuarioCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UsuarioCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UsuarioCountOutputTypeArgs)
    ? UsuarioCountOutputType 
    : S extends { select: any } & (UsuarioCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UsuarioCountOutputType ? UsuarioCountOutputType[P] : never
  } 
      : UsuarioCountOutputType




  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect | null
  }



  /**
   * Count Type MetodoPagoCountOutputType
   */


  export type MetodoPagoCountOutputType = {
    pedidos: number
  }

  export type MetodoPagoCountOutputTypeSelect = {
    pedidos?: boolean
  }

  export type MetodoPagoCountOutputTypeGetPayload<S extends boolean | null | undefined | MetodoPagoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MetodoPagoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MetodoPagoCountOutputTypeArgs)
    ? MetodoPagoCountOutputType 
    : S extends { select: any } & (MetodoPagoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MetodoPagoCountOutputType ? MetodoPagoCountOutputType[P] : never
  } 
      : MetodoPagoCountOutputType




  // Custom InputTypes

  /**
   * MetodoPagoCountOutputType without action
   */
  export type MetodoPagoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MetodoPagoCountOutputType
     */
    select?: MetodoPagoCountOutputTypeSelect | null
  }



  /**
   * Count Type PreguntaCountOutputType
   */


  export type PreguntaCountOutputType = {
    respuestas: number
  }

  export type PreguntaCountOutputTypeSelect = {
    respuestas?: boolean
  }

  export type PreguntaCountOutputTypeGetPayload<S extends boolean | null | undefined | PreguntaCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PreguntaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PreguntaCountOutputTypeArgs)
    ? PreguntaCountOutputType 
    : S extends { select: any } & (PreguntaCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PreguntaCountOutputType ? PreguntaCountOutputType[P] : never
  } 
      : PreguntaCountOutputType




  // Custom InputTypes

  /**
   * PreguntaCountOutputType without action
   */
  export type PreguntaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PreguntaCountOutputType
     */
    select?: PreguntaCountOutputTypeSelect | null
  }



  /**
   * Count Type RespuestaCountOutputType
   */


  export type RespuestaCountOutputType = {
    preguntas: number
  }

  export type RespuestaCountOutputTypeSelect = {
    preguntas?: boolean
  }

  export type RespuestaCountOutputTypeGetPayload<S extends boolean | null | undefined | RespuestaCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RespuestaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RespuestaCountOutputTypeArgs)
    ? RespuestaCountOutputType 
    : S extends { select: any } & (RespuestaCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RespuestaCountOutputType ? RespuestaCountOutputType[P] : never
  } 
      : RespuestaCountOutputType




  // Custom InputTypes

  /**
   * RespuestaCountOutputType without action
   */
  export type RespuestaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RespuestaCountOutputType
     */
    select?: RespuestaCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoriaCountOutputType
   */


  export type CategoriaCountOutputType = {
    ropas: number
  }

  export type CategoriaCountOutputTypeSelect = {
    ropas?: boolean
  }

  export type CategoriaCountOutputTypeGetPayload<S extends boolean | null | undefined | CategoriaCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CategoriaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CategoriaCountOutputTypeArgs)
    ? CategoriaCountOutputType 
    : S extends { select: any } & (CategoriaCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CategoriaCountOutputType ? CategoriaCountOutputType[P] : never
  } 
      : CategoriaCountOutputType




  // Custom InputTypes

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect | null
  }



  /**
   * Count Type DireccionCountOutputType
   */


  export type DireccionCountOutputType = {
    pedidos: number
  }

  export type DireccionCountOutputTypeSelect = {
    pedidos?: boolean
  }

  export type DireccionCountOutputTypeGetPayload<S extends boolean | null | undefined | DireccionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DireccionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DireccionCountOutputTypeArgs)
    ? DireccionCountOutputType 
    : S extends { select: any } & (DireccionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DireccionCountOutputType ? DireccionCountOutputType[P] : never
  } 
      : DireccionCountOutputType




  // Custom InputTypes

  /**
   * DireccionCountOutputType without action
   */
  export type DireccionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DireccionCountOutputType
     */
    select?: DireccionCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Proveedor
   */


  export type AggregateProveedor = {
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  export type ProveedorAvgAggregateOutputType = {
    id: number | null
  }

  export type ProveedorSumAggregateOutputType = {
    id: number | null
  }

  export type ProveedorMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProveedorMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProveedorCountAggregateOutputType = {
    id: number
    nombre: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProveedorAvgAggregateInputType = {
    id?: true
  }

  export type ProveedorSumAggregateInputType = {
    id?: true
  }

  export type ProveedorMinAggregateInputType = {
    id?: true
    nombre?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProveedorMaxAggregateInputType = {
    id?: true
    nombre?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProveedorCountAggregateInputType = {
    id?: true
    nombre?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProveedorAggregateArgs = {
    /**
     * Filter which Proveedor to aggregate.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: Enumerable<ProveedorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proveedors
    **/
    _count?: true | ProveedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedorMaxAggregateInputType
  }

  export type GetProveedorAggregateType<T extends ProveedorAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedor[P]>
      : GetScalarType<T[P], AggregateProveedor[P]>
  }




  export type ProveedorGroupByArgs = {
    where?: ProveedorWhereInput
    orderBy?: Enumerable<ProveedorOrderByWithAggregationInput>
    by: ProveedorScalarFieldEnum[]
    having?: ProveedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedorCountAggregateInputType | true
    _avg?: ProveedorAvgAggregateInputType
    _sum?: ProveedorSumAggregateInputType
    _min?: ProveedorMinAggregateInputType
    _max?: ProveedorMaxAggregateInputType
  }


  export type ProveedorGroupByOutputType = {
    id: number
    nombre: string
    createdAt: Date
    updatedAt: Date
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  type GetProveedorGroupByPayload<T extends ProveedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProveedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
        }
      >
    >


  export type ProveedorSelect = {
    id?: boolean
    nombre?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ropas?: boolean | Proveedor$ropasArgs
    _count?: boolean | ProveedorCountOutputTypeArgs
  }


  export type ProveedorInclude = {
    ropas?: boolean | Proveedor$ropasArgs
    _count?: boolean | ProveedorCountOutputTypeArgs
  }

  export type ProveedorGetPayload<S extends boolean | null | undefined | ProveedorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Proveedor :
    S extends undefined ? never :
    S extends { include: any } & (ProveedorArgs | ProveedorFindManyArgs)
    ? Proveedor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ropas' ? Array < RopaGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProveedorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProveedorArgs | ProveedorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ropas' ? Array < RopaGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProveedorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Proveedor ? Proveedor[P] : never
  } 
      : Proveedor


  type ProveedorCountArgs = 
    Omit<ProveedorFindManyArgs, 'select' | 'include'> & {
      select?: ProveedorCountAggregateInputType | true
    }

  export interface ProveedorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Proveedor that matches the filter.
     * @param {ProveedorFindUniqueArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProveedorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProveedorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Proveedor'> extends True ? Prisma__ProveedorClient<ProveedorGetPayload<T>> : Prisma__ProveedorClient<ProveedorGetPayload<T> | null, null>

    /**
     * Find one Proveedor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProveedorFindUniqueOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProveedorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProveedorFindUniqueOrThrowArgs>
    ): Prisma__ProveedorClient<ProveedorGetPayload<T>>

    /**
     * Find the first Proveedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorFindFirstArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProveedorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProveedorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Proveedor'> extends True ? Prisma__ProveedorClient<ProveedorGetPayload<T>> : Prisma__ProveedorClient<ProveedorGetPayload<T> | null, null>

    /**
     * Find the first Proveedor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorFindFirstOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProveedorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProveedorFindFirstOrThrowArgs>
    ): Prisma__ProveedorClient<ProveedorGetPayload<T>>

    /**
     * Find zero or more Proveedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedors
     * const proveedors = await prisma.proveedor.findMany()
     * 
     * // Get first 10 Proveedors
     * const proveedors = await prisma.proveedor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proveedorWithIdOnly = await prisma.proveedor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProveedorFindManyArgs>(
      args?: SelectSubset<T, ProveedorFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProveedorGetPayload<T>>>

    /**
     * Create a Proveedor.
     * @param {ProveedorCreateArgs} args - Arguments to create a Proveedor.
     * @example
     * // Create one Proveedor
     * const Proveedor = await prisma.proveedor.create({
     *   data: {
     *     // ... data to create a Proveedor
     *   }
     * })
     * 
    **/
    create<T extends ProveedorCreateArgs>(
      args: SelectSubset<T, ProveedorCreateArgs>
    ): Prisma__ProveedorClient<ProveedorGetPayload<T>>

    /**
     * Create many Proveedors.
     *     @param {ProveedorCreateManyArgs} args - Arguments to create many Proveedors.
     *     @example
     *     // Create many Proveedors
     *     const proveedor = await prisma.proveedor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProveedorCreateManyArgs>(
      args?: SelectSubset<T, ProveedorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proveedor.
     * @param {ProveedorDeleteArgs} args - Arguments to delete one Proveedor.
     * @example
     * // Delete one Proveedor
     * const Proveedor = await prisma.proveedor.delete({
     *   where: {
     *     // ... filter to delete one Proveedor
     *   }
     * })
     * 
    **/
    delete<T extends ProveedorDeleteArgs>(
      args: SelectSubset<T, ProveedorDeleteArgs>
    ): Prisma__ProveedorClient<ProveedorGetPayload<T>>

    /**
     * Update one Proveedor.
     * @param {ProveedorUpdateArgs} args - Arguments to update one Proveedor.
     * @example
     * // Update one Proveedor
     * const proveedor = await prisma.proveedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProveedorUpdateArgs>(
      args: SelectSubset<T, ProveedorUpdateArgs>
    ): Prisma__ProveedorClient<ProveedorGetPayload<T>>

    /**
     * Delete zero or more Proveedors.
     * @param {ProveedorDeleteManyArgs} args - Arguments to filter Proveedors to delete.
     * @example
     * // Delete a few Proveedors
     * const { count } = await prisma.proveedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProveedorDeleteManyArgs>(
      args?: SelectSubset<T, ProveedorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedors
     * const proveedor = await prisma.proveedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProveedorUpdateManyArgs>(
      args: SelectSubset<T, ProveedorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedor.
     * @param {ProveedorUpsertArgs} args - Arguments to update or create a Proveedor.
     * @example
     * // Update or create a Proveedor
     * const proveedor = await prisma.proveedor.upsert({
     *   create: {
     *     // ... data to create a Proveedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedor we want to update
     *   }
     * })
    **/
    upsert<T extends ProveedorUpsertArgs>(
      args: SelectSubset<T, ProveedorUpsertArgs>
    ): Prisma__ProveedorClient<ProveedorGetPayload<T>>

    /**
     * Count the number of Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorCountArgs} args - Arguments to filter Proveedors to count.
     * @example
     * // Count the number of Proveedors
     * const count = await prisma.proveedor.count({
     *   where: {
     *     // ... the filter for the Proveedors we want to count
     *   }
     * })
    **/
    count<T extends ProveedorCountArgs>(
      args?: Subset<T, ProveedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedorAggregateArgs>(args: Subset<T, ProveedorAggregateArgs>): Prisma.PrismaPromise<GetProveedorAggregateType<T>>

    /**
     * Group by Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProveedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProveedorGroupByArgs['orderBy'] }
        : { orderBy?: ProveedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProveedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Proveedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProveedorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ropas<T extends Proveedor$ropasArgs= {}>(args?: Subset<T, Proveedor$ropasArgs>): Prisma.PrismaPromise<Array<RopaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Proveedor base type for findUnique actions
   */
  export type ProveedorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where: ProveedorWhereUniqueInput
  }

  /**
   * Proveedor findUnique
   */
  export interface ProveedorFindUniqueArgs extends ProveedorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Proveedor findUniqueOrThrow
   */
  export type ProveedorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where: ProveedorWhereUniqueInput
  }


  /**
   * Proveedor base type for findFirst actions
   */
  export type ProveedorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: Enumerable<ProveedorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proveedors.
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proveedors.
     */
    distinct?: Enumerable<ProveedorScalarFieldEnum>
  }

  /**
   * Proveedor findFirst
   */
  export interface ProveedorFindFirstArgs extends ProveedorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Proveedor findFirstOrThrow
   */
  export type ProveedorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: Enumerable<ProveedorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proveedors.
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proveedors.
     */
    distinct?: Enumerable<ProveedorScalarFieldEnum>
  }


  /**
   * Proveedor findMany
   */
  export type ProveedorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
    /**
     * Filter, which Proveedors to fetch.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: Enumerable<ProveedorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proveedors.
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    distinct?: Enumerable<ProveedorScalarFieldEnum>
  }


  /**
   * Proveedor create
   */
  export type ProveedorCreateArgs = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
    /**
     * The data needed to create a Proveedor.
     */
    data: XOR<ProveedorCreateInput, ProveedorUncheckedCreateInput>
  }


  /**
   * Proveedor createMany
   */
  export type ProveedorCreateManyArgs = {
    /**
     * The data used to create many Proveedors.
     */
    data: Enumerable<ProveedorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Proveedor update
   */
  export type ProveedorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
    /**
     * The data needed to update a Proveedor.
     */
    data: XOR<ProveedorUpdateInput, ProveedorUncheckedUpdateInput>
    /**
     * Choose, which Proveedor to update.
     */
    where: ProveedorWhereUniqueInput
  }


  /**
   * Proveedor updateMany
   */
  export type ProveedorUpdateManyArgs = {
    /**
     * The data used to update Proveedors.
     */
    data: XOR<ProveedorUpdateManyMutationInput, ProveedorUncheckedUpdateManyInput>
    /**
     * Filter which Proveedors to update
     */
    where?: ProveedorWhereInput
  }


  /**
   * Proveedor upsert
   */
  export type ProveedorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
    /**
     * The filter to search for the Proveedor to update in case it exists.
     */
    where: ProveedorWhereUniqueInput
    /**
     * In case the Proveedor found by the `where` argument doesn't exist, create a new Proveedor with this data.
     */
    create: XOR<ProveedorCreateInput, ProveedorUncheckedCreateInput>
    /**
     * In case the Proveedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProveedorUpdateInput, ProveedorUncheckedUpdateInput>
  }


  /**
   * Proveedor delete
   */
  export type ProveedorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
    /**
     * Filter which Proveedor to delete.
     */
    where: ProveedorWhereUniqueInput
  }


  /**
   * Proveedor deleteMany
   */
  export type ProveedorDeleteManyArgs = {
    /**
     * Filter which Proveedors to delete
     */
    where?: ProveedorWhereInput
  }


  /**
   * Proveedor.ropas
   */
  export type Proveedor$ropasArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    where?: RopaWhereInput
    orderBy?: Enumerable<RopaOrderByWithRelationInput>
    cursor?: RopaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RopaScalarFieldEnum>
  }


  /**
   * Proveedor without action
   */
  export type ProveedorArgs = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude | null
  }



  /**
   * Model Ropa
   */


  export type AggregateRopa = {
    _count: RopaCountAggregateOutputType | null
    _avg: RopaAvgAggregateOutputType | null
    _sum: RopaSumAggregateOutputType | null
    _min: RopaMinAggregateOutputType | null
    _max: RopaMaxAggregateOutputType | null
  }

  export type RopaAvgAggregateOutputType = {
    id: number | null
    vendedorId: number | null
    precio: Decimal | null
    cantidad: number | null
    proveedorId: number | null
  }

  export type RopaSumAggregateOutputType = {
    id: number | null
    vendedorId: number | null
    precio: Decimal | null
    cantidad: number | null
    proveedorId: number | null
  }

  export type RopaMinAggregateOutputType = {
    id: number | null
    vendedorId: number | null
    nombre: string | null
    precio: Decimal | null
    estado: string | null
    cantidad: number | null
    proveedorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RopaMaxAggregateOutputType = {
    id: number | null
    vendedorId: number | null
    nombre: string | null
    precio: Decimal | null
    estado: string | null
    cantidad: number | null
    proveedorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RopaCountAggregateOutputType = {
    id: number
    vendedorId: number
    nombre: number
    precio: number
    estado: number
    cantidad: number
    proveedorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RopaAvgAggregateInputType = {
    id?: true
    vendedorId?: true
    precio?: true
    cantidad?: true
    proveedorId?: true
  }

  export type RopaSumAggregateInputType = {
    id?: true
    vendedorId?: true
    precio?: true
    cantidad?: true
    proveedorId?: true
  }

  export type RopaMinAggregateInputType = {
    id?: true
    vendedorId?: true
    nombre?: true
    precio?: true
    estado?: true
    cantidad?: true
    proveedorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RopaMaxAggregateInputType = {
    id?: true
    vendedorId?: true
    nombre?: true
    precio?: true
    estado?: true
    cantidad?: true
    proveedorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RopaCountAggregateInputType = {
    id?: true
    vendedorId?: true
    nombre?: true
    precio?: true
    estado?: true
    cantidad?: true
    proveedorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RopaAggregateArgs = {
    /**
     * Filter which Ropa to aggregate.
     */
    where?: RopaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ropas to fetch.
     */
    orderBy?: Enumerable<RopaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RopaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ropas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ropas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ropas
    **/
    _count?: true | RopaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RopaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RopaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RopaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RopaMaxAggregateInputType
  }

  export type GetRopaAggregateType<T extends RopaAggregateArgs> = {
        [P in keyof T & keyof AggregateRopa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRopa[P]>
      : GetScalarType<T[P], AggregateRopa[P]>
  }




  export type RopaGroupByArgs = {
    where?: RopaWhereInput
    orderBy?: Enumerable<RopaOrderByWithAggregationInput>
    by: RopaScalarFieldEnum[]
    having?: RopaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RopaCountAggregateInputType | true
    _avg?: RopaAvgAggregateInputType
    _sum?: RopaSumAggregateInputType
    _min?: RopaMinAggregateInputType
    _max?: RopaMaxAggregateInputType
  }


  export type RopaGroupByOutputType = {
    id: number
    vendedorId: number
    nombre: string
    precio: Decimal
    estado: string
    cantidad: number
    proveedorId: number
    createdAt: Date
    updatedAt: Date
    _count: RopaCountAggregateOutputType | null
    _avg: RopaAvgAggregateOutputType | null
    _sum: RopaSumAggregateOutputType | null
    _min: RopaMinAggregateOutputType | null
    _max: RopaMaxAggregateOutputType | null
  }

  type GetRopaGroupByPayload<T extends RopaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RopaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RopaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RopaGroupByOutputType[P]>
            : GetScalarType<T[P], RopaGroupByOutputType[P]>
        }
      >
    >


  export type RopaSelect = {
    id?: boolean
    vendedorId?: boolean
    nombre?: boolean
    precio?: boolean
    estado?: boolean
    cantidad?: boolean
    proveedorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proveedor?: boolean | ProveedorArgs
    vendedor?: boolean | UsuarioArgs
    categorias?: boolean | Ropa$categoriasArgs
    fotos?: boolean | Ropa$fotosArgs
    ordenes?: boolean | Ropa$ordenesArgs
    preguntas?: boolean | Ropa$preguntasArgs
    _count?: boolean | RopaCountOutputTypeArgs
  }


  export type RopaInclude = {
    proveedor?: boolean | ProveedorArgs
    vendedor?: boolean | UsuarioArgs
    categorias?: boolean | Ropa$categoriasArgs
    fotos?: boolean | Ropa$fotosArgs
    ordenes?: boolean | Ropa$ordenesArgs
    preguntas?: boolean | Ropa$preguntasArgs
    _count?: boolean | RopaCountOutputTypeArgs
  }

  export type RopaGetPayload<S extends boolean | null | undefined | RopaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Ropa :
    S extends undefined ? never :
    S extends { include: any } & (RopaArgs | RopaFindManyArgs)
    ? Ropa  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'proveedor' ? ProveedorGetPayload<S['include'][P]> :
        P extends 'vendedor' ? UsuarioGetPayload<S['include'][P]> :
        P extends 'categorias' ? Array < CategoriaGetPayload<S['include'][P]>>  :
        P extends 'fotos' ? Array < FotoGetPayload<S['include'][P]>>  :
        P extends 'ordenes' ? Array < PedidoRopaGetPayload<S['include'][P]>>  :
        P extends 'preguntas' ? Array < PreguntaGetPayload<S['include'][P]>>  :
        P extends '_count' ? RopaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RopaArgs | RopaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'proveedor' ? ProveedorGetPayload<S['select'][P]> :
        P extends 'vendedor' ? UsuarioGetPayload<S['select'][P]> :
        P extends 'categorias' ? Array < CategoriaGetPayload<S['select'][P]>>  :
        P extends 'fotos' ? Array < FotoGetPayload<S['select'][P]>>  :
        P extends 'ordenes' ? Array < PedidoRopaGetPayload<S['select'][P]>>  :
        P extends 'preguntas' ? Array < PreguntaGetPayload<S['select'][P]>>  :
        P extends '_count' ? RopaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Ropa ? Ropa[P] : never
  } 
      : Ropa


  type RopaCountArgs = 
    Omit<RopaFindManyArgs, 'select' | 'include'> & {
      select?: RopaCountAggregateInputType | true
    }

  export interface RopaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Ropa that matches the filter.
     * @param {RopaFindUniqueArgs} args - Arguments to find a Ropa
     * @example
     * // Get one Ropa
     * const ropa = await prisma.ropa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RopaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RopaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Ropa'> extends True ? Prisma__RopaClient<RopaGetPayload<T>> : Prisma__RopaClient<RopaGetPayload<T> | null, null>

    /**
     * Find one Ropa that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RopaFindUniqueOrThrowArgs} args - Arguments to find a Ropa
     * @example
     * // Get one Ropa
     * const ropa = await prisma.ropa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RopaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RopaFindUniqueOrThrowArgs>
    ): Prisma__RopaClient<RopaGetPayload<T>>

    /**
     * Find the first Ropa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RopaFindFirstArgs} args - Arguments to find a Ropa
     * @example
     * // Get one Ropa
     * const ropa = await prisma.ropa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RopaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RopaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Ropa'> extends True ? Prisma__RopaClient<RopaGetPayload<T>> : Prisma__RopaClient<RopaGetPayload<T> | null, null>

    /**
     * Find the first Ropa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RopaFindFirstOrThrowArgs} args - Arguments to find a Ropa
     * @example
     * // Get one Ropa
     * const ropa = await prisma.ropa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RopaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RopaFindFirstOrThrowArgs>
    ): Prisma__RopaClient<RopaGetPayload<T>>

    /**
     * Find zero or more Ropas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RopaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ropas
     * const ropas = await prisma.ropa.findMany()
     * 
     * // Get first 10 Ropas
     * const ropas = await prisma.ropa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ropaWithIdOnly = await prisma.ropa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RopaFindManyArgs>(
      args?: SelectSubset<T, RopaFindManyArgs>
    ): Prisma.PrismaPromise<Array<RopaGetPayload<T>>>

    /**
     * Create a Ropa.
     * @param {RopaCreateArgs} args - Arguments to create a Ropa.
     * @example
     * // Create one Ropa
     * const Ropa = await prisma.ropa.create({
     *   data: {
     *     // ... data to create a Ropa
     *   }
     * })
     * 
    **/
    create<T extends RopaCreateArgs>(
      args: SelectSubset<T, RopaCreateArgs>
    ): Prisma__RopaClient<RopaGetPayload<T>>

    /**
     * Create many Ropas.
     *     @param {RopaCreateManyArgs} args - Arguments to create many Ropas.
     *     @example
     *     // Create many Ropas
     *     const ropa = await prisma.ropa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RopaCreateManyArgs>(
      args?: SelectSubset<T, RopaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ropa.
     * @param {RopaDeleteArgs} args - Arguments to delete one Ropa.
     * @example
     * // Delete one Ropa
     * const Ropa = await prisma.ropa.delete({
     *   where: {
     *     // ... filter to delete one Ropa
     *   }
     * })
     * 
    **/
    delete<T extends RopaDeleteArgs>(
      args: SelectSubset<T, RopaDeleteArgs>
    ): Prisma__RopaClient<RopaGetPayload<T>>

    /**
     * Update one Ropa.
     * @param {RopaUpdateArgs} args - Arguments to update one Ropa.
     * @example
     * // Update one Ropa
     * const ropa = await prisma.ropa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RopaUpdateArgs>(
      args: SelectSubset<T, RopaUpdateArgs>
    ): Prisma__RopaClient<RopaGetPayload<T>>

    /**
     * Delete zero or more Ropas.
     * @param {RopaDeleteManyArgs} args - Arguments to filter Ropas to delete.
     * @example
     * // Delete a few Ropas
     * const { count } = await prisma.ropa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RopaDeleteManyArgs>(
      args?: SelectSubset<T, RopaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ropas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RopaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ropas
     * const ropa = await prisma.ropa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RopaUpdateManyArgs>(
      args: SelectSubset<T, RopaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ropa.
     * @param {RopaUpsertArgs} args - Arguments to update or create a Ropa.
     * @example
     * // Update or create a Ropa
     * const ropa = await prisma.ropa.upsert({
     *   create: {
     *     // ... data to create a Ropa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ropa we want to update
     *   }
     * })
    **/
    upsert<T extends RopaUpsertArgs>(
      args: SelectSubset<T, RopaUpsertArgs>
    ): Prisma__RopaClient<RopaGetPayload<T>>

    /**
     * Count the number of Ropas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RopaCountArgs} args - Arguments to filter Ropas to count.
     * @example
     * // Count the number of Ropas
     * const count = await prisma.ropa.count({
     *   where: {
     *     // ... the filter for the Ropas we want to count
     *   }
     * })
    **/
    count<T extends RopaCountArgs>(
      args?: Subset<T, RopaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RopaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ropa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RopaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RopaAggregateArgs>(args: Subset<T, RopaAggregateArgs>): Prisma.PrismaPromise<GetRopaAggregateType<T>>

    /**
     * Group by Ropa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RopaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RopaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RopaGroupByArgs['orderBy'] }
        : { orderBy?: RopaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RopaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRopaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Ropa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RopaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    proveedor<T extends ProveedorArgs= {}>(args?: Subset<T, ProveedorArgs>): Prisma__ProveedorClient<ProveedorGetPayload<T> | Null>;

    vendedor<T extends UsuarioArgs= {}>(args?: Subset<T, UsuarioArgs>): Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>;

    categorias<T extends Ropa$categoriasArgs= {}>(args?: Subset<T, Ropa$categoriasArgs>): Prisma.PrismaPromise<Array<CategoriaGetPayload<T>>| Null>;

    fotos<T extends Ropa$fotosArgs= {}>(args?: Subset<T, Ropa$fotosArgs>): Prisma.PrismaPromise<Array<FotoGetPayload<T>>| Null>;

    ordenes<T extends Ropa$ordenesArgs= {}>(args?: Subset<T, Ropa$ordenesArgs>): Prisma.PrismaPromise<Array<PedidoRopaGetPayload<T>>| Null>;

    preguntas<T extends Ropa$preguntasArgs= {}>(args?: Subset<T, Ropa$preguntasArgs>): Prisma.PrismaPromise<Array<PreguntaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Ropa base type for findUnique actions
   */
  export type RopaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    /**
     * Filter, which Ropa to fetch.
     */
    where: RopaWhereUniqueInput
  }

  /**
   * Ropa findUnique
   */
  export interface RopaFindUniqueArgs extends RopaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ropa findUniqueOrThrow
   */
  export type RopaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    /**
     * Filter, which Ropa to fetch.
     */
    where: RopaWhereUniqueInput
  }


  /**
   * Ropa base type for findFirst actions
   */
  export type RopaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    /**
     * Filter, which Ropa to fetch.
     */
    where?: RopaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ropas to fetch.
     */
    orderBy?: Enumerable<RopaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ropas.
     */
    cursor?: RopaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ropas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ropas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ropas.
     */
    distinct?: Enumerable<RopaScalarFieldEnum>
  }

  /**
   * Ropa findFirst
   */
  export interface RopaFindFirstArgs extends RopaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ropa findFirstOrThrow
   */
  export type RopaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    /**
     * Filter, which Ropa to fetch.
     */
    where?: RopaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ropas to fetch.
     */
    orderBy?: Enumerable<RopaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ropas.
     */
    cursor?: RopaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ropas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ropas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ropas.
     */
    distinct?: Enumerable<RopaScalarFieldEnum>
  }


  /**
   * Ropa findMany
   */
  export type RopaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    /**
     * Filter, which Ropas to fetch.
     */
    where?: RopaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ropas to fetch.
     */
    orderBy?: Enumerable<RopaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ropas.
     */
    cursor?: RopaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ropas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ropas.
     */
    skip?: number
    distinct?: Enumerable<RopaScalarFieldEnum>
  }


  /**
   * Ropa create
   */
  export type RopaCreateArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    /**
     * The data needed to create a Ropa.
     */
    data: XOR<RopaCreateInput, RopaUncheckedCreateInput>
  }


  /**
   * Ropa createMany
   */
  export type RopaCreateManyArgs = {
    /**
     * The data used to create many Ropas.
     */
    data: Enumerable<RopaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Ropa update
   */
  export type RopaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    /**
     * The data needed to update a Ropa.
     */
    data: XOR<RopaUpdateInput, RopaUncheckedUpdateInput>
    /**
     * Choose, which Ropa to update.
     */
    where: RopaWhereUniqueInput
  }


  /**
   * Ropa updateMany
   */
  export type RopaUpdateManyArgs = {
    /**
     * The data used to update Ropas.
     */
    data: XOR<RopaUpdateManyMutationInput, RopaUncheckedUpdateManyInput>
    /**
     * Filter which Ropas to update
     */
    where?: RopaWhereInput
  }


  /**
   * Ropa upsert
   */
  export type RopaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    /**
     * The filter to search for the Ropa to update in case it exists.
     */
    where: RopaWhereUniqueInput
    /**
     * In case the Ropa found by the `where` argument doesn't exist, create a new Ropa with this data.
     */
    create: XOR<RopaCreateInput, RopaUncheckedCreateInput>
    /**
     * In case the Ropa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RopaUpdateInput, RopaUncheckedUpdateInput>
  }


  /**
   * Ropa delete
   */
  export type RopaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    /**
     * Filter which Ropa to delete.
     */
    where: RopaWhereUniqueInput
  }


  /**
   * Ropa deleteMany
   */
  export type RopaDeleteManyArgs = {
    /**
     * Filter which Ropas to delete
     */
    where?: RopaWhereInput
  }


  /**
   * Ropa.categorias
   */
  export type Ropa$categoriasArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    where?: CategoriaWhereInput
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    cursor?: CategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CategoriaScalarFieldEnum>
  }


  /**
   * Ropa.fotos
   */
  export type Ropa$fotosArgs = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    where?: FotoWhereInput
    orderBy?: Enumerable<FotoOrderByWithRelationInput>
    cursor?: FotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FotoScalarFieldEnum>
  }


  /**
   * Ropa.ordenes
   */
  export type Ropa$ordenesArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    where?: PedidoRopaWhereInput
    orderBy?: Enumerable<PedidoRopaOrderByWithRelationInput>
    cursor?: PedidoRopaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PedidoRopaScalarFieldEnum>
  }


  /**
   * Ropa.preguntas
   */
  export type Ropa$preguntasArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    where?: PreguntaWhereInput
    orderBy?: Enumerable<PreguntaOrderByWithRelationInput>
    cursor?: PreguntaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PreguntaScalarFieldEnum>
  }


  /**
   * Ropa without action
   */
  export type RopaArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
  }



  /**
   * Model PedidoRopa
   */


  export type AggregatePedidoRopa = {
    _count: PedidoRopaCountAggregateOutputType | null
    _avg: PedidoRopaAvgAggregateOutputType | null
    _sum: PedidoRopaSumAggregateOutputType | null
    _min: PedidoRopaMinAggregateOutputType | null
    _max: PedidoRopaMaxAggregateOutputType | null
  }

  export type PedidoRopaAvgAggregateOutputType = {
    id: number | null
    idRopa: number | null
    idPedido: number | null
    cantidad: number | null
    subtotal: Decimal | null
  }

  export type PedidoRopaSumAggregateOutputType = {
    id: number | null
    idRopa: number | null
    idPedido: number | null
    cantidad: number | null
    subtotal: Decimal | null
  }

  export type PedidoRopaMinAggregateOutputType = {
    id: number | null
    idRopa: number | null
    idPedido: number | null
    cantidad: number | null
    subtotal: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoRopaMaxAggregateOutputType = {
    id: number | null
    idRopa: number | null
    idPedido: number | null
    cantidad: number | null
    subtotal: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoRopaCountAggregateOutputType = {
    id: number
    idRopa: number
    idPedido: number
    cantidad: number
    subtotal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PedidoRopaAvgAggregateInputType = {
    id?: true
    idRopa?: true
    idPedido?: true
    cantidad?: true
    subtotal?: true
  }

  export type PedidoRopaSumAggregateInputType = {
    id?: true
    idRopa?: true
    idPedido?: true
    cantidad?: true
    subtotal?: true
  }

  export type PedidoRopaMinAggregateInputType = {
    id?: true
    idRopa?: true
    idPedido?: true
    cantidad?: true
    subtotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoRopaMaxAggregateInputType = {
    id?: true
    idRopa?: true
    idPedido?: true
    cantidad?: true
    subtotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoRopaCountAggregateInputType = {
    id?: true
    idRopa?: true
    idPedido?: true
    cantidad?: true
    subtotal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PedidoRopaAggregateArgs = {
    /**
     * Filter which PedidoRopa to aggregate.
     */
    where?: PedidoRopaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoRopas to fetch.
     */
    orderBy?: Enumerable<PedidoRopaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoRopaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoRopas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoRopas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PedidoRopas
    **/
    _count?: true | PedidoRopaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoRopaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoRopaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoRopaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoRopaMaxAggregateInputType
  }

  export type GetPedidoRopaAggregateType<T extends PedidoRopaAggregateArgs> = {
        [P in keyof T & keyof AggregatePedidoRopa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedidoRopa[P]>
      : GetScalarType<T[P], AggregatePedidoRopa[P]>
  }




  export type PedidoRopaGroupByArgs = {
    where?: PedidoRopaWhereInput
    orderBy?: Enumerable<PedidoRopaOrderByWithAggregationInput>
    by: PedidoRopaScalarFieldEnum[]
    having?: PedidoRopaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoRopaCountAggregateInputType | true
    _avg?: PedidoRopaAvgAggregateInputType
    _sum?: PedidoRopaSumAggregateInputType
    _min?: PedidoRopaMinAggregateInputType
    _max?: PedidoRopaMaxAggregateInputType
  }


  export type PedidoRopaGroupByOutputType = {
    id: number
    idRopa: number
    idPedido: number
    cantidad: number
    subtotal: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PedidoRopaCountAggregateOutputType | null
    _avg: PedidoRopaAvgAggregateOutputType | null
    _sum: PedidoRopaSumAggregateOutputType | null
    _min: PedidoRopaMinAggregateOutputType | null
    _max: PedidoRopaMaxAggregateOutputType | null
  }

  type GetPedidoRopaGroupByPayload<T extends PedidoRopaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PedidoRopaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoRopaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoRopaGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoRopaGroupByOutputType[P]>
        }
      >
    >


  export type PedidoRopaSelect = {
    id?: boolean
    idRopa?: boolean
    idPedido?: boolean
    cantidad?: boolean
    subtotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedido?: boolean | PedidoArgs
    ropa?: boolean | RopaArgs
  }


  export type PedidoRopaInclude = {
    pedido?: boolean | PedidoArgs
    ropa?: boolean | RopaArgs
  }

  export type PedidoRopaGetPayload<S extends boolean | null | undefined | PedidoRopaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PedidoRopa :
    S extends undefined ? never :
    S extends { include: any } & (PedidoRopaArgs | PedidoRopaFindManyArgs)
    ? PedidoRopa  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pedido' ? PedidoGetPayload<S['include'][P]> :
        P extends 'ropa' ? RopaGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PedidoRopaArgs | PedidoRopaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pedido' ? PedidoGetPayload<S['select'][P]> :
        P extends 'ropa' ? RopaGetPayload<S['select'][P]> :  P extends keyof PedidoRopa ? PedidoRopa[P] : never
  } 
      : PedidoRopa


  type PedidoRopaCountArgs = 
    Omit<PedidoRopaFindManyArgs, 'select' | 'include'> & {
      select?: PedidoRopaCountAggregateInputType | true
    }

  export interface PedidoRopaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PedidoRopa that matches the filter.
     * @param {PedidoRopaFindUniqueArgs} args - Arguments to find a PedidoRopa
     * @example
     * // Get one PedidoRopa
     * const pedidoRopa = await prisma.pedidoRopa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoRopaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PedidoRopaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PedidoRopa'> extends True ? Prisma__PedidoRopaClient<PedidoRopaGetPayload<T>> : Prisma__PedidoRopaClient<PedidoRopaGetPayload<T> | null, null>

    /**
     * Find one PedidoRopa that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PedidoRopaFindUniqueOrThrowArgs} args - Arguments to find a PedidoRopa
     * @example
     * // Get one PedidoRopa
     * const pedidoRopa = await prisma.pedidoRopa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoRopaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PedidoRopaFindUniqueOrThrowArgs>
    ): Prisma__PedidoRopaClient<PedidoRopaGetPayload<T>>

    /**
     * Find the first PedidoRopa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoRopaFindFirstArgs} args - Arguments to find a PedidoRopa
     * @example
     * // Get one PedidoRopa
     * const pedidoRopa = await prisma.pedidoRopa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoRopaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PedidoRopaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PedidoRopa'> extends True ? Prisma__PedidoRopaClient<PedidoRopaGetPayload<T>> : Prisma__PedidoRopaClient<PedidoRopaGetPayload<T> | null, null>

    /**
     * Find the first PedidoRopa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoRopaFindFirstOrThrowArgs} args - Arguments to find a PedidoRopa
     * @example
     * // Get one PedidoRopa
     * const pedidoRopa = await prisma.pedidoRopa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoRopaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PedidoRopaFindFirstOrThrowArgs>
    ): Prisma__PedidoRopaClient<PedidoRopaGetPayload<T>>

    /**
     * Find zero or more PedidoRopas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoRopaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PedidoRopas
     * const pedidoRopas = await prisma.pedidoRopa.findMany()
     * 
     * // Get first 10 PedidoRopas
     * const pedidoRopas = await prisma.pedidoRopa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoRopaWithIdOnly = await prisma.pedidoRopa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PedidoRopaFindManyArgs>(
      args?: SelectSubset<T, PedidoRopaFindManyArgs>
    ): Prisma.PrismaPromise<Array<PedidoRopaGetPayload<T>>>

    /**
     * Create a PedidoRopa.
     * @param {PedidoRopaCreateArgs} args - Arguments to create a PedidoRopa.
     * @example
     * // Create one PedidoRopa
     * const PedidoRopa = await prisma.pedidoRopa.create({
     *   data: {
     *     // ... data to create a PedidoRopa
     *   }
     * })
     * 
    **/
    create<T extends PedidoRopaCreateArgs>(
      args: SelectSubset<T, PedidoRopaCreateArgs>
    ): Prisma__PedidoRopaClient<PedidoRopaGetPayload<T>>

    /**
     * Create many PedidoRopas.
     *     @param {PedidoRopaCreateManyArgs} args - Arguments to create many PedidoRopas.
     *     @example
     *     // Create many PedidoRopas
     *     const pedidoRopa = await prisma.pedidoRopa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoRopaCreateManyArgs>(
      args?: SelectSubset<T, PedidoRopaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PedidoRopa.
     * @param {PedidoRopaDeleteArgs} args - Arguments to delete one PedidoRopa.
     * @example
     * // Delete one PedidoRopa
     * const PedidoRopa = await prisma.pedidoRopa.delete({
     *   where: {
     *     // ... filter to delete one PedidoRopa
     *   }
     * })
     * 
    **/
    delete<T extends PedidoRopaDeleteArgs>(
      args: SelectSubset<T, PedidoRopaDeleteArgs>
    ): Prisma__PedidoRopaClient<PedidoRopaGetPayload<T>>

    /**
     * Update one PedidoRopa.
     * @param {PedidoRopaUpdateArgs} args - Arguments to update one PedidoRopa.
     * @example
     * // Update one PedidoRopa
     * const pedidoRopa = await prisma.pedidoRopa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoRopaUpdateArgs>(
      args: SelectSubset<T, PedidoRopaUpdateArgs>
    ): Prisma__PedidoRopaClient<PedidoRopaGetPayload<T>>

    /**
     * Delete zero or more PedidoRopas.
     * @param {PedidoRopaDeleteManyArgs} args - Arguments to filter PedidoRopas to delete.
     * @example
     * // Delete a few PedidoRopas
     * const { count } = await prisma.pedidoRopa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoRopaDeleteManyArgs>(
      args?: SelectSubset<T, PedidoRopaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoRopas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoRopaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PedidoRopas
     * const pedidoRopa = await prisma.pedidoRopa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoRopaUpdateManyArgs>(
      args: SelectSubset<T, PedidoRopaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PedidoRopa.
     * @param {PedidoRopaUpsertArgs} args - Arguments to update or create a PedidoRopa.
     * @example
     * // Update or create a PedidoRopa
     * const pedidoRopa = await prisma.pedidoRopa.upsert({
     *   create: {
     *     // ... data to create a PedidoRopa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PedidoRopa we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoRopaUpsertArgs>(
      args: SelectSubset<T, PedidoRopaUpsertArgs>
    ): Prisma__PedidoRopaClient<PedidoRopaGetPayload<T>>

    /**
     * Count the number of PedidoRopas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoRopaCountArgs} args - Arguments to filter PedidoRopas to count.
     * @example
     * // Count the number of PedidoRopas
     * const count = await prisma.pedidoRopa.count({
     *   where: {
     *     // ... the filter for the PedidoRopas we want to count
     *   }
     * })
    **/
    count<T extends PedidoRopaCountArgs>(
      args?: Subset<T, PedidoRopaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoRopaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PedidoRopa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoRopaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoRopaAggregateArgs>(args: Subset<T, PedidoRopaAggregateArgs>): Prisma.PrismaPromise<GetPedidoRopaAggregateType<T>>

    /**
     * Group by PedidoRopa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoRopaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoRopaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoRopaGroupByArgs['orderBy'] }
        : { orderBy?: PedidoRopaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoRopaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoRopaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PedidoRopa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PedidoRopaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pedido<T extends PedidoArgs= {}>(args?: Subset<T, PedidoArgs>): Prisma__PedidoClient<PedidoGetPayload<T> | Null>;

    ropa<T extends RopaArgs= {}>(args?: Subset<T, RopaArgs>): Prisma__RopaClient<RopaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PedidoRopa base type for findUnique actions
   */
  export type PedidoRopaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    /**
     * Filter, which PedidoRopa to fetch.
     */
    where: PedidoRopaWhereUniqueInput
  }

  /**
   * PedidoRopa findUnique
   */
  export interface PedidoRopaFindUniqueArgs extends PedidoRopaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PedidoRopa findUniqueOrThrow
   */
  export type PedidoRopaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    /**
     * Filter, which PedidoRopa to fetch.
     */
    where: PedidoRopaWhereUniqueInput
  }


  /**
   * PedidoRopa base type for findFirst actions
   */
  export type PedidoRopaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    /**
     * Filter, which PedidoRopa to fetch.
     */
    where?: PedidoRopaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoRopas to fetch.
     */
    orderBy?: Enumerable<PedidoRopaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoRopas.
     */
    cursor?: PedidoRopaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoRopas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoRopas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoRopas.
     */
    distinct?: Enumerable<PedidoRopaScalarFieldEnum>
  }

  /**
   * PedidoRopa findFirst
   */
  export interface PedidoRopaFindFirstArgs extends PedidoRopaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PedidoRopa findFirstOrThrow
   */
  export type PedidoRopaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    /**
     * Filter, which PedidoRopa to fetch.
     */
    where?: PedidoRopaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoRopas to fetch.
     */
    orderBy?: Enumerable<PedidoRopaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoRopas.
     */
    cursor?: PedidoRopaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoRopas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoRopas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoRopas.
     */
    distinct?: Enumerable<PedidoRopaScalarFieldEnum>
  }


  /**
   * PedidoRopa findMany
   */
  export type PedidoRopaFindManyArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    /**
     * Filter, which PedidoRopas to fetch.
     */
    where?: PedidoRopaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoRopas to fetch.
     */
    orderBy?: Enumerable<PedidoRopaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PedidoRopas.
     */
    cursor?: PedidoRopaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoRopas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoRopas.
     */
    skip?: number
    distinct?: Enumerable<PedidoRopaScalarFieldEnum>
  }


  /**
   * PedidoRopa create
   */
  export type PedidoRopaCreateArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    /**
     * The data needed to create a PedidoRopa.
     */
    data: XOR<PedidoRopaCreateInput, PedidoRopaUncheckedCreateInput>
  }


  /**
   * PedidoRopa createMany
   */
  export type PedidoRopaCreateManyArgs = {
    /**
     * The data used to create many PedidoRopas.
     */
    data: Enumerable<PedidoRopaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PedidoRopa update
   */
  export type PedidoRopaUpdateArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    /**
     * The data needed to update a PedidoRopa.
     */
    data: XOR<PedidoRopaUpdateInput, PedidoRopaUncheckedUpdateInput>
    /**
     * Choose, which PedidoRopa to update.
     */
    where: PedidoRopaWhereUniqueInput
  }


  /**
   * PedidoRopa updateMany
   */
  export type PedidoRopaUpdateManyArgs = {
    /**
     * The data used to update PedidoRopas.
     */
    data: XOR<PedidoRopaUpdateManyMutationInput, PedidoRopaUncheckedUpdateManyInput>
    /**
     * Filter which PedidoRopas to update
     */
    where?: PedidoRopaWhereInput
  }


  /**
   * PedidoRopa upsert
   */
  export type PedidoRopaUpsertArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    /**
     * The filter to search for the PedidoRopa to update in case it exists.
     */
    where: PedidoRopaWhereUniqueInput
    /**
     * In case the PedidoRopa found by the `where` argument doesn't exist, create a new PedidoRopa with this data.
     */
    create: XOR<PedidoRopaCreateInput, PedidoRopaUncheckedCreateInput>
    /**
     * In case the PedidoRopa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoRopaUpdateInput, PedidoRopaUncheckedUpdateInput>
  }


  /**
   * PedidoRopa delete
   */
  export type PedidoRopaDeleteArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    /**
     * Filter which PedidoRopa to delete.
     */
    where: PedidoRopaWhereUniqueInput
  }


  /**
   * PedidoRopa deleteMany
   */
  export type PedidoRopaDeleteManyArgs = {
    /**
     * Filter which PedidoRopas to delete
     */
    where?: PedidoRopaWhereInput
  }


  /**
   * PedidoRopa without action
   */
  export type PedidoRopaArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
  }



  /**
   * Model Pedido
   */


  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id: number | null
    idPago: number | null
    clienteId: number | null
    direccionId: number | null
    descuento: Decimal | null
    IV: Decimal | null
    subtotal: Decimal | null
    Total: Decimal | null
  }

  export type PedidoSumAggregateOutputType = {
    id: number | null
    idPago: number | null
    clienteId: number | null
    direccionId: number | null
    descuento: Decimal | null
    IV: Decimal | null
    subtotal: Decimal | null
    Total: Decimal | null
  }

  export type PedidoMinAggregateOutputType = {
    id: number | null
    fechaOrden: Date | null
    idPago: number | null
    clienteId: number | null
    direccionId: number | null
    descuento: Decimal | null
    IV: Decimal | null
    estado: string | null
    subtotal: Decimal | null
    Total: Decimal | null
    fecha: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoMaxAggregateOutputType = {
    id: number | null
    fechaOrden: Date | null
    idPago: number | null
    clienteId: number | null
    direccionId: number | null
    descuento: Decimal | null
    IV: Decimal | null
    estado: string | null
    subtotal: Decimal | null
    Total: Decimal | null
    fecha: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoCountAggregateOutputType = {
    id: number
    fechaOrden: number
    idPago: number
    clienteId: number
    direccionId: number
    descuento: number
    IV: number
    estado: number
    subtotal: number
    Total: number
    fecha: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id?: true
    idPago?: true
    clienteId?: true
    direccionId?: true
    descuento?: true
    IV?: true
    subtotal?: true
    Total?: true
  }

  export type PedidoSumAggregateInputType = {
    id?: true
    idPago?: true
    clienteId?: true
    direccionId?: true
    descuento?: true
    IV?: true
    subtotal?: true
    Total?: true
  }

  export type PedidoMinAggregateInputType = {
    id?: true
    fechaOrden?: true
    idPago?: true
    clienteId?: true
    direccionId?: true
    descuento?: true
    IV?: true
    estado?: true
    subtotal?: true
    Total?: true
    fecha?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoMaxAggregateInputType = {
    id?: true
    fechaOrden?: true
    idPago?: true
    clienteId?: true
    direccionId?: true
    descuento?: true
    IV?: true
    estado?: true
    subtotal?: true
    Total?: true
    fecha?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoCountAggregateInputType = {
    id?: true
    fechaOrden?: true
    idPago?: true
    clienteId?: true
    direccionId?: true
    descuento?: true
    IV?: true
    estado?: true
    subtotal?: true
    Total?: true
    fecha?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PedidoAggregateArgs = {
    /**
     * Filter which Pedido to aggregate.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs = {
    where?: PedidoWhereInput
    orderBy?: Enumerable<PedidoOrderByWithAggregationInput>
    by: PedidoScalarFieldEnum[]
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }


  export type PedidoGroupByOutputType = {
    id: number
    fechaOrden: Date
    idPago: number
    clienteId: number
    direccionId: number
    descuento: Decimal
    IV: Decimal
    estado: string
    subtotal: Decimal
    Total: Decimal
    fecha: Date
    createdAt: Date
    updatedAt: Date
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect = {
    id?: boolean
    fechaOrden?: boolean
    idPago?: boolean
    clienteId?: boolean
    direccionId?: boolean
    descuento?: boolean
    IV?: boolean
    estado?: boolean
    subtotal?: boolean
    Total?: boolean
    fecha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ropas?: boolean | Pedido$ropasArgs
    evaluaciones?: boolean | Pedido$evaluacionesArgs
    direccion?: boolean | DireccionArgs
    metodo?: boolean | MetodoPagoArgs
    usuario?: boolean | UsuarioArgs
    _count?: boolean | PedidoCountOutputTypeArgs
  }


  export type PedidoInclude = {
    ropas?: boolean | Pedido$ropasArgs
    evaluaciones?: boolean | Pedido$evaluacionesArgs
    direccion?: boolean | DireccionArgs
    metodo?: boolean | MetodoPagoArgs
    usuario?: boolean | UsuarioArgs
    _count?: boolean | PedidoCountOutputTypeArgs
  }

  export type PedidoGetPayload<S extends boolean | null | undefined | PedidoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Pedido :
    S extends undefined ? never :
    S extends { include: any } & (PedidoArgs | PedidoFindManyArgs)
    ? Pedido  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ropas' ? Array < PedidoRopaGetPayload<S['include'][P]>>  :
        P extends 'evaluaciones' ? Array < EvaluacionGetPayload<S['include'][P]>>  :
        P extends 'direccion' ? DireccionGetPayload<S['include'][P]> :
        P extends 'metodo' ? MetodoPagoGetPayload<S['include'][P]> :
        P extends 'usuario' ? UsuarioGetPayload<S['include'][P]> :
        P extends '_count' ? PedidoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PedidoArgs | PedidoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ropas' ? Array < PedidoRopaGetPayload<S['select'][P]>>  :
        P extends 'evaluaciones' ? Array < EvaluacionGetPayload<S['select'][P]>>  :
        P extends 'direccion' ? DireccionGetPayload<S['select'][P]> :
        P extends 'metodo' ? MetodoPagoGetPayload<S['select'][P]> :
        P extends 'usuario' ? UsuarioGetPayload<S['select'][P]> :
        P extends '_count' ? PedidoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Pedido ? Pedido[P] : never
  } 
      : Pedido


  type PedidoCountArgs = 
    Omit<PedidoFindManyArgs, 'select' | 'include'> & {
      select?: PedidoCountAggregateInputType | true
    }

  export interface PedidoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PedidoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pedido'> extends True ? Prisma__PedidoClient<PedidoGetPayload<T>> : Prisma__PedidoClient<PedidoGetPayload<T> | null, null>

    /**
     * Find one Pedido that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PedidoFindUniqueOrThrowArgs>
    ): Prisma__PedidoClient<PedidoGetPayload<T>>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PedidoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pedido'> extends True ? Prisma__PedidoClient<PedidoGetPayload<T>> : Prisma__PedidoClient<PedidoGetPayload<T> | null, null>

    /**
     * Find the first Pedido that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PedidoFindFirstOrThrowArgs>
    ): Prisma__PedidoClient<PedidoGetPayload<T>>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoWithIdOnly = await prisma.pedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PedidoFindManyArgs>(
      args?: SelectSubset<T, PedidoFindManyArgs>
    ): Prisma.PrismaPromise<Array<PedidoGetPayload<T>>>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
    **/
    create<T extends PedidoCreateArgs>(
      args: SelectSubset<T, PedidoCreateArgs>
    ): Prisma__PedidoClient<PedidoGetPayload<T>>

    /**
     * Create many Pedidos.
     *     @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     *     @example
     *     // Create many Pedidos
     *     const pedido = await prisma.pedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoCreateManyArgs>(
      args?: SelectSubset<T, PedidoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
    **/
    delete<T extends PedidoDeleteArgs>(
      args: SelectSubset<T, PedidoDeleteArgs>
    ): Prisma__PedidoClient<PedidoGetPayload<T>>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoUpdateArgs>(
      args: SelectSubset<T, PedidoUpdateArgs>
    ): Prisma__PedidoClient<PedidoGetPayload<T>>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoDeleteManyArgs>(
      args?: SelectSubset<T, PedidoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoUpdateManyArgs>(
      args: SelectSubset<T, PedidoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoUpsertArgs>(
      args: SelectSubset<T, PedidoUpsertArgs>
    ): Prisma__PedidoClient<PedidoGetPayload<T>>

    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): Prisma.PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PedidoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ropas<T extends Pedido$ropasArgs= {}>(args?: Subset<T, Pedido$ropasArgs>): Prisma.PrismaPromise<Array<PedidoRopaGetPayload<T>>| Null>;

    evaluaciones<T extends Pedido$evaluacionesArgs= {}>(args?: Subset<T, Pedido$evaluacionesArgs>): Prisma.PrismaPromise<Array<EvaluacionGetPayload<T>>| Null>;

    direccion<T extends DireccionArgs= {}>(args?: Subset<T, DireccionArgs>): Prisma__DireccionClient<DireccionGetPayload<T> | Null>;

    metodo<T extends MetodoPagoArgs= {}>(args?: Subset<T, MetodoPagoArgs>): Prisma__MetodoPagoClient<MetodoPagoGetPayload<T> | Null>;

    usuario<T extends UsuarioArgs= {}>(args?: Subset<T, UsuarioArgs>): Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pedido base type for findUnique actions
   */
  export type PedidoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido findUnique
   */
  export interface PedidoFindUniqueArgs extends PedidoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido base type for findFirst actions
   */
  export type PedidoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }

  /**
   * Pedido findFirst
   */
  export interface PedidoFindFirstArgs extends PedidoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }


  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    /**
     * Filter, which Pedidos to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }


  /**
   * Pedido create
   */
  export type PedidoCreateArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    /**
     * The data needed to create a Pedido.
     */
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }


  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs = {
    /**
     * The data used to create many Pedidos.
     */
    data: Enumerable<PedidoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pedido update
   */
  export type PedidoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    /**
     * The data needed to update a Pedido.
     */
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs = {
    /**
     * The data used to update Pedidos.
     */
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     */
    where?: PedidoWhereInput
  }


  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     */
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     */
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }


  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    /**
     * Filter which Pedido to delete.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs = {
    /**
     * Filter which Pedidos to delete
     */
    where?: PedidoWhereInput
  }


  /**
   * Pedido.ropas
   */
  export type Pedido$ropasArgs = {
    /**
     * Select specific fields to fetch from the PedidoRopa
     */
    select?: PedidoRopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoRopaInclude | null
    where?: PedidoRopaWhereInput
    orderBy?: Enumerable<PedidoRopaOrderByWithRelationInput>
    cursor?: PedidoRopaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PedidoRopaScalarFieldEnum>
  }


  /**
   * Pedido.evaluaciones
   */
  export type Pedido$evaluacionesArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    where?: EvaluacionWhereInput
    orderBy?: Enumerable<EvaluacionOrderByWithRelationInput>
    cursor?: EvaluacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EvaluacionScalarFieldEnum>
  }


  /**
   * Pedido without action
   */
  export type PedidoArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
  }



  /**
   * Model Usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    cedula: string | null
    telefono: string | null
    correo: string | null
    contrasenna: string | null
    estado: boolean | null
    rol: Rol | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    cedula: string | null
    telefono: string | null
    correo: string | null
    contrasenna: string | null
    estado: boolean | null
    rol: Rol | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    cedula: number
    telefono: number
    correo: number
    contrasenna: number
    estado: number
    rol: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    cedula?: true
    telefono?: true
    correo?: true
    contrasenna?: true
    estado?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    cedula?: true
    telefono?: true
    correo?: true
    contrasenna?: true
    estado?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    cedula?: true
    telefono?: true
    correo?: true
    contrasenna?: true
    estado?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: UsuarioWhereInput
    orderBy?: Enumerable<UsuarioOrderByWithAggregationInput>
    by: UsuarioScalarFieldEnum[]
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol: Rol
    createdAt: Date
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect = {
    id?: boolean
    nombre?: boolean
    cedula?: boolean
    telefono?: boolean
    correo?: boolean
    contrasenna?: boolean
    estado?: boolean
    rol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metodos?: boolean | Usuario$metodosArgs
    pedidos?: boolean | Usuario$pedidosArgs
    direcciones?: boolean | Usuario$direccionesArgs
    preguntas?: boolean | Usuario$preguntasArgs
    respuestas?: boolean | Usuario$respuestasArgs
    informes?: boolean | Usuario$informesArgs
    evaluaciones?: boolean | Usuario$evaluacionesArgs
    ropas?: boolean | Usuario$ropasArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }


  export type UsuarioInclude = {
    metodos?: boolean | Usuario$metodosArgs
    pedidos?: boolean | Usuario$pedidosArgs
    direcciones?: boolean | Usuario$direccionesArgs
    preguntas?: boolean | Usuario$preguntasArgs
    respuestas?: boolean | Usuario$respuestasArgs
    informes?: boolean | Usuario$informesArgs
    evaluaciones?: boolean | Usuario$evaluacionesArgs
    ropas?: boolean | Usuario$ropasArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Usuario :
    S extends undefined ? never :
    S extends { include: any } & (UsuarioArgs | UsuarioFindManyArgs)
    ? Usuario  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'metodos' ? Array < MetodoPagoGetPayload<S['include'][P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<S['include'][P]>>  :
        P extends 'direcciones' ? Array < DireccionGetPayload<S['include'][P]>>  :
        P extends 'preguntas' ? Array < PreguntaGetPayload<S['include'][P]>>  :
        P extends 'respuestas' ? Array < RespuestaGetPayload<S['include'][P]>>  :
        P extends 'informes' ? Array < InformeGetPayload<S['include'][P]>>  :
        P extends 'evaluaciones' ? Array < EvaluacionGetPayload<S['include'][P]>>  :
        P extends 'ropas' ? Array < RopaGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UsuarioArgs | UsuarioFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'metodos' ? Array < MetodoPagoGetPayload<S['select'][P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<S['select'][P]>>  :
        P extends 'direcciones' ? Array < DireccionGetPayload<S['select'][P]>>  :
        P extends 'preguntas' ? Array < PreguntaGetPayload<S['select'][P]>>  :
        P extends 'respuestas' ? Array < RespuestaGetPayload<S['select'][P]>>  :
        P extends 'informes' ? Array < InformeGetPayload<S['select'][P]>>  :
        P extends 'evaluaciones' ? Array < EvaluacionGetPayload<S['select'][P]>>  :
        P extends 'ropas' ? Array < RopaGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Usuario ? Usuario[P] : never
  } 
      : Usuario


  type UsuarioCountArgs = 
    Omit<UsuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Usuario'> extends True ? Prisma__UsuarioClient<UsuarioGetPayload<T>> : Prisma__UsuarioClient<UsuarioGetPayload<T> | null, null>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs>
    ): Prisma__UsuarioClient<UsuarioGetPayload<T>>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Usuario'> extends True ? Prisma__UsuarioClient<UsuarioGetPayload<T>> : Prisma__UsuarioClient<UsuarioGetPayload<T> | null, null>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs>
    ): Prisma__UsuarioClient<UsuarioGetPayload<T>>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs>(
      args?: SelectSubset<T, UsuarioFindManyArgs>
    ): Prisma.PrismaPromise<Array<UsuarioGetPayload<T>>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs>(
      args: SelectSubset<T, UsuarioCreateArgs>
    ): Prisma__UsuarioClient<UsuarioGetPayload<T>>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs>(
      args?: SelectSubset<T, UsuarioCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs>(
      args: SelectSubset<T, UsuarioDeleteArgs>
    ): Prisma__UsuarioClient<UsuarioGetPayload<T>>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs>(
      args: SelectSubset<T, UsuarioUpdateArgs>
    ): Prisma__UsuarioClient<UsuarioGetPayload<T>>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs>(
      args: SelectSubset<T, UsuarioUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs>(
      args: SelectSubset<T, UsuarioUpsertArgs>
    ): Prisma__UsuarioClient<UsuarioGetPayload<T>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsuarioClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    metodos<T extends Usuario$metodosArgs= {}>(args?: Subset<T, Usuario$metodosArgs>): Prisma.PrismaPromise<Array<MetodoPagoGetPayload<T>>| Null>;

    pedidos<T extends Usuario$pedidosArgs= {}>(args?: Subset<T, Usuario$pedidosArgs>): Prisma.PrismaPromise<Array<PedidoGetPayload<T>>| Null>;

    direcciones<T extends Usuario$direccionesArgs= {}>(args?: Subset<T, Usuario$direccionesArgs>): Prisma.PrismaPromise<Array<DireccionGetPayload<T>>| Null>;

    preguntas<T extends Usuario$preguntasArgs= {}>(args?: Subset<T, Usuario$preguntasArgs>): Prisma.PrismaPromise<Array<PreguntaGetPayload<T>>| Null>;

    respuestas<T extends Usuario$respuestasArgs= {}>(args?: Subset<T, Usuario$respuestasArgs>): Prisma.PrismaPromise<Array<RespuestaGetPayload<T>>| Null>;

    informes<T extends Usuario$informesArgs= {}>(args?: Subset<T, Usuario$informesArgs>): Prisma.PrismaPromise<Array<InformeGetPayload<T>>| Null>;

    evaluaciones<T extends Usuario$evaluacionesArgs= {}>(args?: Subset<T, Usuario$evaluacionesArgs>): Prisma.PrismaPromise<Array<EvaluacionGetPayload<T>>| Null>;

    ropas<T extends Usuario$ropasArgs= {}>(args?: Subset<T, Usuario$ropasArgs>): Prisma.PrismaPromise<Array<RopaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Usuario base type for findUnique actions
   */
  export type UsuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUnique
   */
  export interface UsuarioFindUniqueArgs extends UsuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario base type for findFirst actions
   */
  export type UsuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * Usuario findFirst
   */
  export interface UsuarioFindFirstArgs extends UsuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs = {
    /**
     * The data used to create many Usuarios.
     */
    data: Enumerable<UsuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario.metodos
   */
  export type Usuario$metodosArgs = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    where?: MetodoPagoWhereInput
    orderBy?: Enumerable<MetodoPagoOrderByWithRelationInput>
    cursor?: MetodoPagoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MetodoPagoScalarFieldEnum>
  }


  /**
   * Usuario.pedidos
   */
  export type Usuario$pedidosArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    where?: PedidoWhereInput
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }


  /**
   * Usuario.direcciones
   */
  export type Usuario$direccionesArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    where?: DireccionWhereInput
    orderBy?: Enumerable<DireccionOrderByWithRelationInput>
    cursor?: DireccionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DireccionScalarFieldEnum>
  }


  /**
   * Usuario.preguntas
   */
  export type Usuario$preguntasArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    where?: PreguntaWhereInput
    orderBy?: Enumerable<PreguntaOrderByWithRelationInput>
    cursor?: PreguntaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PreguntaScalarFieldEnum>
  }


  /**
   * Usuario.respuestas
   */
  export type Usuario$respuestasArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    where?: RespuestaWhereInput
    orderBy?: Enumerable<RespuestaOrderByWithRelationInput>
    cursor?: RespuestaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RespuestaScalarFieldEnum>
  }


  /**
   * Usuario.informes
   */
  export type Usuario$informesArgs = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    where?: InformeWhereInput
    orderBy?: Enumerable<InformeOrderByWithRelationInput>
    cursor?: InformeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InformeScalarFieldEnum>
  }


  /**
   * Usuario.evaluaciones
   */
  export type Usuario$evaluacionesArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    where?: EvaluacionWhereInput
    orderBy?: Enumerable<EvaluacionOrderByWithRelationInput>
    cursor?: EvaluacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EvaluacionScalarFieldEnum>
  }


  /**
   * Usuario.ropas
   */
  export type Usuario$ropasArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    where?: RopaWhereInput
    orderBy?: Enumerable<RopaOrderByWithRelationInput>
    cursor?: RopaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RopaScalarFieldEnum>
  }


  /**
   * Usuario without action
   */
  export type UsuarioArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude | null
  }



  /**
   * Model MetodoPago
   */


  export type AggregateMetodoPago = {
    _count: MetodoPagoCountAggregateOutputType | null
    _avg: MetodoPagoAvgAggregateOutputType | null
    _sum: MetodoPagoSumAggregateOutputType | null
    _min: MetodoPagoMinAggregateOutputType | null
    _max: MetodoPagoMaxAggregateOutputType | null
  }

  export type MetodoPagoAvgAggregateOutputType = {
    id: number | null
    idCliente: number | null
  }

  export type MetodoPagoSumAggregateOutputType = {
    id: number | null
    idCliente: number | null
  }

  export type MetodoPagoMinAggregateOutputType = {
    id: number | null
    idCliente: number | null
    descripcion: string | null
    proveedor: string | null
    numeroCuenta: string | null
    fechaExpiracion: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetodoPagoMaxAggregateOutputType = {
    id: number | null
    idCliente: number | null
    descripcion: string | null
    proveedor: string | null
    numeroCuenta: string | null
    fechaExpiracion: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetodoPagoCountAggregateOutputType = {
    id: number
    idCliente: number
    descripcion: number
    proveedor: number
    numeroCuenta: number
    fechaExpiracion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MetodoPagoAvgAggregateInputType = {
    id?: true
    idCliente?: true
  }

  export type MetodoPagoSumAggregateInputType = {
    id?: true
    idCliente?: true
  }

  export type MetodoPagoMinAggregateInputType = {
    id?: true
    idCliente?: true
    descripcion?: true
    proveedor?: true
    numeroCuenta?: true
    fechaExpiracion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetodoPagoMaxAggregateInputType = {
    id?: true
    idCliente?: true
    descripcion?: true
    proveedor?: true
    numeroCuenta?: true
    fechaExpiracion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetodoPagoCountAggregateInputType = {
    id?: true
    idCliente?: true
    descripcion?: true
    proveedor?: true
    numeroCuenta?: true
    fechaExpiracion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MetodoPagoAggregateArgs = {
    /**
     * Filter which MetodoPago to aggregate.
     */
    where?: MetodoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetodoPagos to fetch.
     */
    orderBy?: Enumerable<MetodoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetodoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetodoPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetodoPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetodoPagos
    **/
    _count?: true | MetodoPagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetodoPagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetodoPagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetodoPagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetodoPagoMaxAggregateInputType
  }

  export type GetMetodoPagoAggregateType<T extends MetodoPagoAggregateArgs> = {
        [P in keyof T & keyof AggregateMetodoPago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetodoPago[P]>
      : GetScalarType<T[P], AggregateMetodoPago[P]>
  }




  export type MetodoPagoGroupByArgs = {
    where?: MetodoPagoWhereInput
    orderBy?: Enumerable<MetodoPagoOrderByWithAggregationInput>
    by: MetodoPagoScalarFieldEnum[]
    having?: MetodoPagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetodoPagoCountAggregateInputType | true
    _avg?: MetodoPagoAvgAggregateInputType
    _sum?: MetodoPagoSumAggregateInputType
    _min?: MetodoPagoMinAggregateInputType
    _max?: MetodoPagoMaxAggregateInputType
  }


  export type MetodoPagoGroupByOutputType = {
    id: number
    idCliente: number
    descripcion: string
    proveedor: string
    numeroCuenta: string
    fechaExpiracion: Date
    createdAt: Date
    updatedAt: Date
    _count: MetodoPagoCountAggregateOutputType | null
    _avg: MetodoPagoAvgAggregateOutputType | null
    _sum: MetodoPagoSumAggregateOutputType | null
    _min: MetodoPagoMinAggregateOutputType | null
    _max: MetodoPagoMaxAggregateOutputType | null
  }

  type GetMetodoPagoGroupByPayload<T extends MetodoPagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MetodoPagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetodoPagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetodoPagoGroupByOutputType[P]>
            : GetScalarType<T[P], MetodoPagoGroupByOutputType[P]>
        }
      >
    >


  export type MetodoPagoSelect = {
    id?: boolean
    idCliente?: boolean
    descripcion?: boolean
    proveedor?: boolean
    numeroCuenta?: boolean
    fechaExpiracion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioArgs
    pedidos?: boolean | MetodoPago$pedidosArgs
    _count?: boolean | MetodoPagoCountOutputTypeArgs
  }


  export type MetodoPagoInclude = {
    usuario?: boolean | UsuarioArgs
    pedidos?: boolean | MetodoPago$pedidosArgs
    _count?: boolean | MetodoPagoCountOutputTypeArgs
  }

  export type MetodoPagoGetPayload<S extends boolean | null | undefined | MetodoPagoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MetodoPago :
    S extends undefined ? never :
    S extends { include: any } & (MetodoPagoArgs | MetodoPagoFindManyArgs)
    ? MetodoPago  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['include'][P]> :
        P extends 'pedidos' ? Array < PedidoGetPayload<S['include'][P]>>  :
        P extends '_count' ? MetodoPagoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MetodoPagoArgs | MetodoPagoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['select'][P]> :
        P extends 'pedidos' ? Array < PedidoGetPayload<S['select'][P]>>  :
        P extends '_count' ? MetodoPagoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MetodoPago ? MetodoPago[P] : never
  } 
      : MetodoPago


  type MetodoPagoCountArgs = 
    Omit<MetodoPagoFindManyArgs, 'select' | 'include'> & {
      select?: MetodoPagoCountAggregateInputType | true
    }

  export interface MetodoPagoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MetodoPago that matches the filter.
     * @param {MetodoPagoFindUniqueArgs} args - Arguments to find a MetodoPago
     * @example
     * // Get one MetodoPago
     * const metodoPago = await prisma.metodoPago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MetodoPagoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MetodoPagoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MetodoPago'> extends True ? Prisma__MetodoPagoClient<MetodoPagoGetPayload<T>> : Prisma__MetodoPagoClient<MetodoPagoGetPayload<T> | null, null>

    /**
     * Find one MetodoPago that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MetodoPagoFindUniqueOrThrowArgs} args - Arguments to find a MetodoPago
     * @example
     * // Get one MetodoPago
     * const metodoPago = await prisma.metodoPago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MetodoPagoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MetodoPagoFindUniqueOrThrowArgs>
    ): Prisma__MetodoPagoClient<MetodoPagoGetPayload<T>>

    /**
     * Find the first MetodoPago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodoPagoFindFirstArgs} args - Arguments to find a MetodoPago
     * @example
     * // Get one MetodoPago
     * const metodoPago = await prisma.metodoPago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MetodoPagoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MetodoPagoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MetodoPago'> extends True ? Prisma__MetodoPagoClient<MetodoPagoGetPayload<T>> : Prisma__MetodoPagoClient<MetodoPagoGetPayload<T> | null, null>

    /**
     * Find the first MetodoPago that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodoPagoFindFirstOrThrowArgs} args - Arguments to find a MetodoPago
     * @example
     * // Get one MetodoPago
     * const metodoPago = await prisma.metodoPago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MetodoPagoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MetodoPagoFindFirstOrThrowArgs>
    ): Prisma__MetodoPagoClient<MetodoPagoGetPayload<T>>

    /**
     * Find zero or more MetodoPagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodoPagoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetodoPagos
     * const metodoPagos = await prisma.metodoPago.findMany()
     * 
     * // Get first 10 MetodoPagos
     * const metodoPagos = await prisma.metodoPago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metodoPagoWithIdOnly = await prisma.metodoPago.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MetodoPagoFindManyArgs>(
      args?: SelectSubset<T, MetodoPagoFindManyArgs>
    ): Prisma.PrismaPromise<Array<MetodoPagoGetPayload<T>>>

    /**
     * Create a MetodoPago.
     * @param {MetodoPagoCreateArgs} args - Arguments to create a MetodoPago.
     * @example
     * // Create one MetodoPago
     * const MetodoPago = await prisma.metodoPago.create({
     *   data: {
     *     // ... data to create a MetodoPago
     *   }
     * })
     * 
    **/
    create<T extends MetodoPagoCreateArgs>(
      args: SelectSubset<T, MetodoPagoCreateArgs>
    ): Prisma__MetodoPagoClient<MetodoPagoGetPayload<T>>

    /**
     * Create many MetodoPagos.
     *     @param {MetodoPagoCreateManyArgs} args - Arguments to create many MetodoPagos.
     *     @example
     *     // Create many MetodoPagos
     *     const metodoPago = await prisma.metodoPago.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MetodoPagoCreateManyArgs>(
      args?: SelectSubset<T, MetodoPagoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MetodoPago.
     * @param {MetodoPagoDeleteArgs} args - Arguments to delete one MetodoPago.
     * @example
     * // Delete one MetodoPago
     * const MetodoPago = await prisma.metodoPago.delete({
     *   where: {
     *     // ... filter to delete one MetodoPago
     *   }
     * })
     * 
    **/
    delete<T extends MetodoPagoDeleteArgs>(
      args: SelectSubset<T, MetodoPagoDeleteArgs>
    ): Prisma__MetodoPagoClient<MetodoPagoGetPayload<T>>

    /**
     * Update one MetodoPago.
     * @param {MetodoPagoUpdateArgs} args - Arguments to update one MetodoPago.
     * @example
     * // Update one MetodoPago
     * const metodoPago = await prisma.metodoPago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MetodoPagoUpdateArgs>(
      args: SelectSubset<T, MetodoPagoUpdateArgs>
    ): Prisma__MetodoPagoClient<MetodoPagoGetPayload<T>>

    /**
     * Delete zero or more MetodoPagos.
     * @param {MetodoPagoDeleteManyArgs} args - Arguments to filter MetodoPagos to delete.
     * @example
     * // Delete a few MetodoPagos
     * const { count } = await prisma.metodoPago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MetodoPagoDeleteManyArgs>(
      args?: SelectSubset<T, MetodoPagoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetodoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodoPagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetodoPagos
     * const metodoPago = await prisma.metodoPago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MetodoPagoUpdateManyArgs>(
      args: SelectSubset<T, MetodoPagoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MetodoPago.
     * @param {MetodoPagoUpsertArgs} args - Arguments to update or create a MetodoPago.
     * @example
     * // Update or create a MetodoPago
     * const metodoPago = await prisma.metodoPago.upsert({
     *   create: {
     *     // ... data to create a MetodoPago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetodoPago we want to update
     *   }
     * })
    **/
    upsert<T extends MetodoPagoUpsertArgs>(
      args: SelectSubset<T, MetodoPagoUpsertArgs>
    ): Prisma__MetodoPagoClient<MetodoPagoGetPayload<T>>

    /**
     * Count the number of MetodoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodoPagoCountArgs} args - Arguments to filter MetodoPagos to count.
     * @example
     * // Count the number of MetodoPagos
     * const count = await prisma.metodoPago.count({
     *   where: {
     *     // ... the filter for the MetodoPagos we want to count
     *   }
     * })
    **/
    count<T extends MetodoPagoCountArgs>(
      args?: Subset<T, MetodoPagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetodoPagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetodoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodoPagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetodoPagoAggregateArgs>(args: Subset<T, MetodoPagoAggregateArgs>): Prisma.PrismaPromise<GetMetodoPagoAggregateType<T>>

    /**
     * Group by MetodoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodoPagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetodoPagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetodoPagoGroupByArgs['orderBy'] }
        : { orderBy?: MetodoPagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetodoPagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetodoPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MetodoPago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MetodoPagoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends UsuarioArgs= {}>(args?: Subset<T, UsuarioArgs>): Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>;

    pedidos<T extends MetodoPago$pedidosArgs= {}>(args?: Subset<T, MetodoPago$pedidosArgs>): Prisma.PrismaPromise<Array<PedidoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MetodoPago base type for findUnique actions
   */
  export type MetodoPagoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    /**
     * Filter, which MetodoPago to fetch.
     */
    where: MetodoPagoWhereUniqueInput
  }

  /**
   * MetodoPago findUnique
   */
  export interface MetodoPagoFindUniqueArgs extends MetodoPagoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MetodoPago findUniqueOrThrow
   */
  export type MetodoPagoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    /**
     * Filter, which MetodoPago to fetch.
     */
    where: MetodoPagoWhereUniqueInput
  }


  /**
   * MetodoPago base type for findFirst actions
   */
  export type MetodoPagoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    /**
     * Filter, which MetodoPago to fetch.
     */
    where?: MetodoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetodoPagos to fetch.
     */
    orderBy?: Enumerable<MetodoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetodoPagos.
     */
    cursor?: MetodoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetodoPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetodoPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetodoPagos.
     */
    distinct?: Enumerable<MetodoPagoScalarFieldEnum>
  }

  /**
   * MetodoPago findFirst
   */
  export interface MetodoPagoFindFirstArgs extends MetodoPagoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MetodoPago findFirstOrThrow
   */
  export type MetodoPagoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    /**
     * Filter, which MetodoPago to fetch.
     */
    where?: MetodoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetodoPagos to fetch.
     */
    orderBy?: Enumerable<MetodoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetodoPagos.
     */
    cursor?: MetodoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetodoPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetodoPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetodoPagos.
     */
    distinct?: Enumerable<MetodoPagoScalarFieldEnum>
  }


  /**
   * MetodoPago findMany
   */
  export type MetodoPagoFindManyArgs = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    /**
     * Filter, which MetodoPagos to fetch.
     */
    where?: MetodoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetodoPagos to fetch.
     */
    orderBy?: Enumerable<MetodoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetodoPagos.
     */
    cursor?: MetodoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetodoPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetodoPagos.
     */
    skip?: number
    distinct?: Enumerable<MetodoPagoScalarFieldEnum>
  }


  /**
   * MetodoPago create
   */
  export type MetodoPagoCreateArgs = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    /**
     * The data needed to create a MetodoPago.
     */
    data: XOR<MetodoPagoCreateInput, MetodoPagoUncheckedCreateInput>
  }


  /**
   * MetodoPago createMany
   */
  export type MetodoPagoCreateManyArgs = {
    /**
     * The data used to create many MetodoPagos.
     */
    data: Enumerable<MetodoPagoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MetodoPago update
   */
  export type MetodoPagoUpdateArgs = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    /**
     * The data needed to update a MetodoPago.
     */
    data: XOR<MetodoPagoUpdateInput, MetodoPagoUncheckedUpdateInput>
    /**
     * Choose, which MetodoPago to update.
     */
    where: MetodoPagoWhereUniqueInput
  }


  /**
   * MetodoPago updateMany
   */
  export type MetodoPagoUpdateManyArgs = {
    /**
     * The data used to update MetodoPagos.
     */
    data: XOR<MetodoPagoUpdateManyMutationInput, MetodoPagoUncheckedUpdateManyInput>
    /**
     * Filter which MetodoPagos to update
     */
    where?: MetodoPagoWhereInput
  }


  /**
   * MetodoPago upsert
   */
  export type MetodoPagoUpsertArgs = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    /**
     * The filter to search for the MetodoPago to update in case it exists.
     */
    where: MetodoPagoWhereUniqueInput
    /**
     * In case the MetodoPago found by the `where` argument doesn't exist, create a new MetodoPago with this data.
     */
    create: XOR<MetodoPagoCreateInput, MetodoPagoUncheckedCreateInput>
    /**
     * In case the MetodoPago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetodoPagoUpdateInput, MetodoPagoUncheckedUpdateInput>
  }


  /**
   * MetodoPago delete
   */
  export type MetodoPagoDeleteArgs = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
    /**
     * Filter which MetodoPago to delete.
     */
    where: MetodoPagoWhereUniqueInput
  }


  /**
   * MetodoPago deleteMany
   */
  export type MetodoPagoDeleteManyArgs = {
    /**
     * Filter which MetodoPagos to delete
     */
    where?: MetodoPagoWhereInput
  }


  /**
   * MetodoPago.pedidos
   */
  export type MetodoPago$pedidosArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    where?: PedidoWhereInput
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }


  /**
   * MetodoPago without action
   */
  export type MetodoPagoArgs = {
    /**
     * Select specific fields to fetch from the MetodoPago
     */
    select?: MetodoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MetodoPagoInclude | null
  }



  /**
   * Model Pregunta
   */


  export type AggregatePregunta = {
    _count: PreguntaCountAggregateOutputType | null
    _avg: PreguntaAvgAggregateOutputType | null
    _sum: PreguntaSumAggregateOutputType | null
    _min: PreguntaMinAggregateOutputType | null
    _max: PreguntaMaxAggregateOutputType | null
  }

  export type PreguntaAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    ropaId: number | null
  }

  export type PreguntaSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    ropaId: number | null
  }

  export type PreguntaMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
    usuarioId: number | null
    ropaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreguntaMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
    usuarioId: number | null
    ropaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreguntaCountAggregateOutputType = {
    id: number
    descripcion: number
    usuarioId: number
    ropaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PreguntaAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    ropaId?: true
  }

  export type PreguntaSumAggregateInputType = {
    id?: true
    usuarioId?: true
    ropaId?: true
  }

  export type PreguntaMinAggregateInputType = {
    id?: true
    descripcion?: true
    usuarioId?: true
    ropaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreguntaMaxAggregateInputType = {
    id?: true
    descripcion?: true
    usuarioId?: true
    ropaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreguntaCountAggregateInputType = {
    id?: true
    descripcion?: true
    usuarioId?: true
    ropaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PreguntaAggregateArgs = {
    /**
     * Filter which Pregunta to aggregate.
     */
    where?: PreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preguntas to fetch.
     */
    orderBy?: Enumerable<PreguntaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Preguntas
    **/
    _count?: true | PreguntaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreguntaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreguntaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreguntaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreguntaMaxAggregateInputType
  }

  export type GetPreguntaAggregateType<T extends PreguntaAggregateArgs> = {
        [P in keyof T & keyof AggregatePregunta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePregunta[P]>
      : GetScalarType<T[P], AggregatePregunta[P]>
  }




  export type PreguntaGroupByArgs = {
    where?: PreguntaWhereInput
    orderBy?: Enumerable<PreguntaOrderByWithAggregationInput>
    by: PreguntaScalarFieldEnum[]
    having?: PreguntaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreguntaCountAggregateInputType | true
    _avg?: PreguntaAvgAggregateInputType
    _sum?: PreguntaSumAggregateInputType
    _min?: PreguntaMinAggregateInputType
    _max?: PreguntaMaxAggregateInputType
  }


  export type PreguntaGroupByOutputType = {
    id: number
    descripcion: string
    usuarioId: number
    ropaId: number
    createdAt: Date
    updatedAt: Date
    _count: PreguntaCountAggregateOutputType | null
    _avg: PreguntaAvgAggregateOutputType | null
    _sum: PreguntaSumAggregateOutputType | null
    _min: PreguntaMinAggregateOutputType | null
    _max: PreguntaMaxAggregateOutputType | null
  }

  type GetPreguntaGroupByPayload<T extends PreguntaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PreguntaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreguntaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreguntaGroupByOutputType[P]>
            : GetScalarType<T[P], PreguntaGroupByOutputType[P]>
        }
      >
    >


  export type PreguntaSelect = {
    id?: boolean
    descripcion?: boolean
    usuarioId?: boolean
    ropaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioArgs
    ropa?: boolean | RopaArgs
    respuestas?: boolean | Pregunta$respuestasArgs
    _count?: boolean | PreguntaCountOutputTypeArgs
  }


  export type PreguntaInclude = {
    usuario?: boolean | UsuarioArgs
    ropa?: boolean | RopaArgs
    respuestas?: boolean | Pregunta$respuestasArgs
    _count?: boolean | PreguntaCountOutputTypeArgs
  }

  export type PreguntaGetPayload<S extends boolean | null | undefined | PreguntaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Pregunta :
    S extends undefined ? never :
    S extends { include: any } & (PreguntaArgs | PreguntaFindManyArgs)
    ? Pregunta  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['include'][P]> :
        P extends 'ropa' ? RopaGetPayload<S['include'][P]> :
        P extends 'respuestas' ? Array < RespuestaGetPayload<S['include'][P]>>  :
        P extends '_count' ? PreguntaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PreguntaArgs | PreguntaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['select'][P]> :
        P extends 'ropa' ? RopaGetPayload<S['select'][P]> :
        P extends 'respuestas' ? Array < RespuestaGetPayload<S['select'][P]>>  :
        P extends '_count' ? PreguntaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Pregunta ? Pregunta[P] : never
  } 
      : Pregunta


  type PreguntaCountArgs = 
    Omit<PreguntaFindManyArgs, 'select' | 'include'> & {
      select?: PreguntaCountAggregateInputType | true
    }

  export interface PreguntaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Pregunta that matches the filter.
     * @param {PreguntaFindUniqueArgs} args - Arguments to find a Pregunta
     * @example
     * // Get one Pregunta
     * const pregunta = await prisma.pregunta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PreguntaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PreguntaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pregunta'> extends True ? Prisma__PreguntaClient<PreguntaGetPayload<T>> : Prisma__PreguntaClient<PreguntaGetPayload<T> | null, null>

    /**
     * Find one Pregunta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PreguntaFindUniqueOrThrowArgs} args - Arguments to find a Pregunta
     * @example
     * // Get one Pregunta
     * const pregunta = await prisma.pregunta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PreguntaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PreguntaFindUniqueOrThrowArgs>
    ): Prisma__PreguntaClient<PreguntaGetPayload<T>>

    /**
     * Find the first Pregunta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaFindFirstArgs} args - Arguments to find a Pregunta
     * @example
     * // Get one Pregunta
     * const pregunta = await prisma.pregunta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PreguntaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PreguntaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pregunta'> extends True ? Prisma__PreguntaClient<PreguntaGetPayload<T>> : Prisma__PreguntaClient<PreguntaGetPayload<T> | null, null>

    /**
     * Find the first Pregunta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaFindFirstOrThrowArgs} args - Arguments to find a Pregunta
     * @example
     * // Get one Pregunta
     * const pregunta = await prisma.pregunta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PreguntaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PreguntaFindFirstOrThrowArgs>
    ): Prisma__PreguntaClient<PreguntaGetPayload<T>>

    /**
     * Find zero or more Preguntas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preguntas
     * const preguntas = await prisma.pregunta.findMany()
     * 
     * // Get first 10 Preguntas
     * const preguntas = await prisma.pregunta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preguntaWithIdOnly = await prisma.pregunta.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PreguntaFindManyArgs>(
      args?: SelectSubset<T, PreguntaFindManyArgs>
    ): Prisma.PrismaPromise<Array<PreguntaGetPayload<T>>>

    /**
     * Create a Pregunta.
     * @param {PreguntaCreateArgs} args - Arguments to create a Pregunta.
     * @example
     * // Create one Pregunta
     * const Pregunta = await prisma.pregunta.create({
     *   data: {
     *     // ... data to create a Pregunta
     *   }
     * })
     * 
    **/
    create<T extends PreguntaCreateArgs>(
      args: SelectSubset<T, PreguntaCreateArgs>
    ): Prisma__PreguntaClient<PreguntaGetPayload<T>>

    /**
     * Create many Preguntas.
     *     @param {PreguntaCreateManyArgs} args - Arguments to create many Preguntas.
     *     @example
     *     // Create many Preguntas
     *     const pregunta = await prisma.pregunta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PreguntaCreateManyArgs>(
      args?: SelectSubset<T, PreguntaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pregunta.
     * @param {PreguntaDeleteArgs} args - Arguments to delete one Pregunta.
     * @example
     * // Delete one Pregunta
     * const Pregunta = await prisma.pregunta.delete({
     *   where: {
     *     // ... filter to delete one Pregunta
     *   }
     * })
     * 
    **/
    delete<T extends PreguntaDeleteArgs>(
      args: SelectSubset<T, PreguntaDeleteArgs>
    ): Prisma__PreguntaClient<PreguntaGetPayload<T>>

    /**
     * Update one Pregunta.
     * @param {PreguntaUpdateArgs} args - Arguments to update one Pregunta.
     * @example
     * // Update one Pregunta
     * const pregunta = await prisma.pregunta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PreguntaUpdateArgs>(
      args: SelectSubset<T, PreguntaUpdateArgs>
    ): Prisma__PreguntaClient<PreguntaGetPayload<T>>

    /**
     * Delete zero or more Preguntas.
     * @param {PreguntaDeleteManyArgs} args - Arguments to filter Preguntas to delete.
     * @example
     * // Delete a few Preguntas
     * const { count } = await prisma.pregunta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PreguntaDeleteManyArgs>(
      args?: SelectSubset<T, PreguntaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preguntas
     * const pregunta = await prisma.pregunta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PreguntaUpdateManyArgs>(
      args: SelectSubset<T, PreguntaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pregunta.
     * @param {PreguntaUpsertArgs} args - Arguments to update or create a Pregunta.
     * @example
     * // Update or create a Pregunta
     * const pregunta = await prisma.pregunta.upsert({
     *   create: {
     *     // ... data to create a Pregunta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pregunta we want to update
     *   }
     * })
    **/
    upsert<T extends PreguntaUpsertArgs>(
      args: SelectSubset<T, PreguntaUpsertArgs>
    ): Prisma__PreguntaClient<PreguntaGetPayload<T>>

    /**
     * Count the number of Preguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaCountArgs} args - Arguments to filter Preguntas to count.
     * @example
     * // Count the number of Preguntas
     * const count = await prisma.pregunta.count({
     *   where: {
     *     // ... the filter for the Preguntas we want to count
     *   }
     * })
    **/
    count<T extends PreguntaCountArgs>(
      args?: Subset<T, PreguntaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreguntaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pregunta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreguntaAggregateArgs>(args: Subset<T, PreguntaAggregateArgs>): Prisma.PrismaPromise<GetPreguntaAggregateType<T>>

    /**
     * Group by Pregunta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreguntaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreguntaGroupByArgs['orderBy'] }
        : { orderBy?: PreguntaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreguntaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreguntaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pregunta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PreguntaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends UsuarioArgs= {}>(args?: Subset<T, UsuarioArgs>): Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>;

    ropa<T extends RopaArgs= {}>(args?: Subset<T, RopaArgs>): Prisma__RopaClient<RopaGetPayload<T> | Null>;

    respuestas<T extends Pregunta$respuestasArgs= {}>(args?: Subset<T, Pregunta$respuestasArgs>): Prisma.PrismaPromise<Array<RespuestaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pregunta base type for findUnique actions
   */
  export type PreguntaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    /**
     * Filter, which Pregunta to fetch.
     */
    where: PreguntaWhereUniqueInput
  }

  /**
   * Pregunta findUnique
   */
  export interface PreguntaFindUniqueArgs extends PreguntaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pregunta findUniqueOrThrow
   */
  export type PreguntaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    /**
     * Filter, which Pregunta to fetch.
     */
    where: PreguntaWhereUniqueInput
  }


  /**
   * Pregunta base type for findFirst actions
   */
  export type PreguntaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    /**
     * Filter, which Pregunta to fetch.
     */
    where?: PreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preguntas to fetch.
     */
    orderBy?: Enumerable<PreguntaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preguntas.
     */
    cursor?: PreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preguntas.
     */
    distinct?: Enumerable<PreguntaScalarFieldEnum>
  }

  /**
   * Pregunta findFirst
   */
  export interface PreguntaFindFirstArgs extends PreguntaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pregunta findFirstOrThrow
   */
  export type PreguntaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    /**
     * Filter, which Pregunta to fetch.
     */
    where?: PreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preguntas to fetch.
     */
    orderBy?: Enumerable<PreguntaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preguntas.
     */
    cursor?: PreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preguntas.
     */
    distinct?: Enumerable<PreguntaScalarFieldEnum>
  }


  /**
   * Pregunta findMany
   */
  export type PreguntaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    /**
     * Filter, which Preguntas to fetch.
     */
    where?: PreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preguntas to fetch.
     */
    orderBy?: Enumerable<PreguntaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Preguntas.
     */
    cursor?: PreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preguntas.
     */
    skip?: number
    distinct?: Enumerable<PreguntaScalarFieldEnum>
  }


  /**
   * Pregunta create
   */
  export type PreguntaCreateArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    /**
     * The data needed to create a Pregunta.
     */
    data: XOR<PreguntaCreateInput, PreguntaUncheckedCreateInput>
  }


  /**
   * Pregunta createMany
   */
  export type PreguntaCreateManyArgs = {
    /**
     * The data used to create many Preguntas.
     */
    data: Enumerable<PreguntaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pregunta update
   */
  export type PreguntaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    /**
     * The data needed to update a Pregunta.
     */
    data: XOR<PreguntaUpdateInput, PreguntaUncheckedUpdateInput>
    /**
     * Choose, which Pregunta to update.
     */
    where: PreguntaWhereUniqueInput
  }


  /**
   * Pregunta updateMany
   */
  export type PreguntaUpdateManyArgs = {
    /**
     * The data used to update Preguntas.
     */
    data: XOR<PreguntaUpdateManyMutationInput, PreguntaUncheckedUpdateManyInput>
    /**
     * Filter which Preguntas to update
     */
    where?: PreguntaWhereInput
  }


  /**
   * Pregunta upsert
   */
  export type PreguntaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    /**
     * The filter to search for the Pregunta to update in case it exists.
     */
    where: PreguntaWhereUniqueInput
    /**
     * In case the Pregunta found by the `where` argument doesn't exist, create a new Pregunta with this data.
     */
    create: XOR<PreguntaCreateInput, PreguntaUncheckedCreateInput>
    /**
     * In case the Pregunta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreguntaUpdateInput, PreguntaUncheckedUpdateInput>
  }


  /**
   * Pregunta delete
   */
  export type PreguntaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    /**
     * Filter which Pregunta to delete.
     */
    where: PreguntaWhereUniqueInput
  }


  /**
   * Pregunta deleteMany
   */
  export type PreguntaDeleteManyArgs = {
    /**
     * Filter which Preguntas to delete
     */
    where?: PreguntaWhereInput
  }


  /**
   * Pregunta.respuestas
   */
  export type Pregunta$respuestasArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    where?: RespuestaWhereInput
    orderBy?: Enumerable<RespuestaOrderByWithRelationInput>
    cursor?: RespuestaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RespuestaScalarFieldEnum>
  }


  /**
   * Pregunta without action
   */
  export type PreguntaArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
  }



  /**
   * Model Respuesta
   */


  export type AggregateRespuesta = {
    _count: RespuestaCountAggregateOutputType | null
    _avg: RespuestaAvgAggregateOutputType | null
    _sum: RespuestaSumAggregateOutputType | null
    _min: RespuestaMinAggregateOutputType | null
    _max: RespuestaMaxAggregateOutputType | null
  }

  export type RespuestaAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type RespuestaSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type RespuestaMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RespuestaMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RespuestaCountAggregateOutputType = {
    id: number
    descripcion: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RespuestaAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type RespuestaSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type RespuestaMinAggregateInputType = {
    id?: true
    descripcion?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RespuestaMaxAggregateInputType = {
    id?: true
    descripcion?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RespuestaCountAggregateInputType = {
    id?: true
    descripcion?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RespuestaAggregateArgs = {
    /**
     * Filter which Respuesta to aggregate.
     */
    where?: RespuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Respuestas to fetch.
     */
    orderBy?: Enumerable<RespuestaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RespuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Respuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Respuestas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Respuestas
    **/
    _count?: true | RespuestaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RespuestaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RespuestaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RespuestaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RespuestaMaxAggregateInputType
  }

  export type GetRespuestaAggregateType<T extends RespuestaAggregateArgs> = {
        [P in keyof T & keyof AggregateRespuesta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRespuesta[P]>
      : GetScalarType<T[P], AggregateRespuesta[P]>
  }




  export type RespuestaGroupByArgs = {
    where?: RespuestaWhereInput
    orderBy?: Enumerable<RespuestaOrderByWithAggregationInput>
    by: RespuestaScalarFieldEnum[]
    having?: RespuestaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RespuestaCountAggregateInputType | true
    _avg?: RespuestaAvgAggregateInputType
    _sum?: RespuestaSumAggregateInputType
    _min?: RespuestaMinAggregateInputType
    _max?: RespuestaMaxAggregateInputType
  }


  export type RespuestaGroupByOutputType = {
    id: number
    descripcion: string
    usuarioId: number
    createdAt: Date
    updatedAt: Date
    _count: RespuestaCountAggregateOutputType | null
    _avg: RespuestaAvgAggregateOutputType | null
    _sum: RespuestaSumAggregateOutputType | null
    _min: RespuestaMinAggregateOutputType | null
    _max: RespuestaMaxAggregateOutputType | null
  }

  type GetRespuestaGroupByPayload<T extends RespuestaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RespuestaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RespuestaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RespuestaGroupByOutputType[P]>
            : GetScalarType<T[P], RespuestaGroupByOutputType[P]>
        }
      >
    >


  export type RespuestaSelect = {
    id?: boolean
    descripcion?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioArgs
    preguntas?: boolean | Respuesta$preguntasArgs
    _count?: boolean | RespuestaCountOutputTypeArgs
  }


  export type RespuestaInclude = {
    usuario?: boolean | UsuarioArgs
    preguntas?: boolean | Respuesta$preguntasArgs
    _count?: boolean | RespuestaCountOutputTypeArgs
  }

  export type RespuestaGetPayload<S extends boolean | null | undefined | RespuestaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Respuesta :
    S extends undefined ? never :
    S extends { include: any } & (RespuestaArgs | RespuestaFindManyArgs)
    ? Respuesta  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['include'][P]> :
        P extends 'preguntas' ? Array < PreguntaGetPayload<S['include'][P]>>  :
        P extends '_count' ? RespuestaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RespuestaArgs | RespuestaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['select'][P]> :
        P extends 'preguntas' ? Array < PreguntaGetPayload<S['select'][P]>>  :
        P extends '_count' ? RespuestaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Respuesta ? Respuesta[P] : never
  } 
      : Respuesta


  type RespuestaCountArgs = 
    Omit<RespuestaFindManyArgs, 'select' | 'include'> & {
      select?: RespuestaCountAggregateInputType | true
    }

  export interface RespuestaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Respuesta that matches the filter.
     * @param {RespuestaFindUniqueArgs} args - Arguments to find a Respuesta
     * @example
     * // Get one Respuesta
     * const respuesta = await prisma.respuesta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RespuestaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RespuestaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Respuesta'> extends True ? Prisma__RespuestaClient<RespuestaGetPayload<T>> : Prisma__RespuestaClient<RespuestaGetPayload<T> | null, null>

    /**
     * Find one Respuesta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RespuestaFindUniqueOrThrowArgs} args - Arguments to find a Respuesta
     * @example
     * // Get one Respuesta
     * const respuesta = await prisma.respuesta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RespuestaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RespuestaFindUniqueOrThrowArgs>
    ): Prisma__RespuestaClient<RespuestaGetPayload<T>>

    /**
     * Find the first Respuesta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaFindFirstArgs} args - Arguments to find a Respuesta
     * @example
     * // Get one Respuesta
     * const respuesta = await prisma.respuesta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RespuestaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RespuestaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Respuesta'> extends True ? Prisma__RespuestaClient<RespuestaGetPayload<T>> : Prisma__RespuestaClient<RespuestaGetPayload<T> | null, null>

    /**
     * Find the first Respuesta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaFindFirstOrThrowArgs} args - Arguments to find a Respuesta
     * @example
     * // Get one Respuesta
     * const respuesta = await prisma.respuesta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RespuestaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RespuestaFindFirstOrThrowArgs>
    ): Prisma__RespuestaClient<RespuestaGetPayload<T>>

    /**
     * Find zero or more Respuestas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Respuestas
     * const respuestas = await prisma.respuesta.findMany()
     * 
     * // Get first 10 Respuestas
     * const respuestas = await prisma.respuesta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const respuestaWithIdOnly = await prisma.respuesta.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RespuestaFindManyArgs>(
      args?: SelectSubset<T, RespuestaFindManyArgs>
    ): Prisma.PrismaPromise<Array<RespuestaGetPayload<T>>>

    /**
     * Create a Respuesta.
     * @param {RespuestaCreateArgs} args - Arguments to create a Respuesta.
     * @example
     * // Create one Respuesta
     * const Respuesta = await prisma.respuesta.create({
     *   data: {
     *     // ... data to create a Respuesta
     *   }
     * })
     * 
    **/
    create<T extends RespuestaCreateArgs>(
      args: SelectSubset<T, RespuestaCreateArgs>
    ): Prisma__RespuestaClient<RespuestaGetPayload<T>>

    /**
     * Create many Respuestas.
     *     @param {RespuestaCreateManyArgs} args - Arguments to create many Respuestas.
     *     @example
     *     // Create many Respuestas
     *     const respuesta = await prisma.respuesta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RespuestaCreateManyArgs>(
      args?: SelectSubset<T, RespuestaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Respuesta.
     * @param {RespuestaDeleteArgs} args - Arguments to delete one Respuesta.
     * @example
     * // Delete one Respuesta
     * const Respuesta = await prisma.respuesta.delete({
     *   where: {
     *     // ... filter to delete one Respuesta
     *   }
     * })
     * 
    **/
    delete<T extends RespuestaDeleteArgs>(
      args: SelectSubset<T, RespuestaDeleteArgs>
    ): Prisma__RespuestaClient<RespuestaGetPayload<T>>

    /**
     * Update one Respuesta.
     * @param {RespuestaUpdateArgs} args - Arguments to update one Respuesta.
     * @example
     * // Update one Respuesta
     * const respuesta = await prisma.respuesta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RespuestaUpdateArgs>(
      args: SelectSubset<T, RespuestaUpdateArgs>
    ): Prisma__RespuestaClient<RespuestaGetPayload<T>>

    /**
     * Delete zero or more Respuestas.
     * @param {RespuestaDeleteManyArgs} args - Arguments to filter Respuestas to delete.
     * @example
     * // Delete a few Respuestas
     * const { count } = await prisma.respuesta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RespuestaDeleteManyArgs>(
      args?: SelectSubset<T, RespuestaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Respuestas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Respuestas
     * const respuesta = await prisma.respuesta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RespuestaUpdateManyArgs>(
      args: SelectSubset<T, RespuestaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Respuesta.
     * @param {RespuestaUpsertArgs} args - Arguments to update or create a Respuesta.
     * @example
     * // Update or create a Respuesta
     * const respuesta = await prisma.respuesta.upsert({
     *   create: {
     *     // ... data to create a Respuesta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Respuesta we want to update
     *   }
     * })
    **/
    upsert<T extends RespuestaUpsertArgs>(
      args: SelectSubset<T, RespuestaUpsertArgs>
    ): Prisma__RespuestaClient<RespuestaGetPayload<T>>

    /**
     * Count the number of Respuestas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaCountArgs} args - Arguments to filter Respuestas to count.
     * @example
     * // Count the number of Respuestas
     * const count = await prisma.respuesta.count({
     *   where: {
     *     // ... the filter for the Respuestas we want to count
     *   }
     * })
    **/
    count<T extends RespuestaCountArgs>(
      args?: Subset<T, RespuestaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RespuestaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Respuesta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RespuestaAggregateArgs>(args: Subset<T, RespuestaAggregateArgs>): Prisma.PrismaPromise<GetRespuestaAggregateType<T>>

    /**
     * Group by Respuesta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RespuestaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RespuestaGroupByArgs['orderBy'] }
        : { orderBy?: RespuestaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RespuestaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRespuestaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Respuesta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RespuestaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends UsuarioArgs= {}>(args?: Subset<T, UsuarioArgs>): Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>;

    preguntas<T extends Respuesta$preguntasArgs= {}>(args?: Subset<T, Respuesta$preguntasArgs>): Prisma.PrismaPromise<Array<PreguntaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Respuesta base type for findUnique actions
   */
  export type RespuestaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    /**
     * Filter, which Respuesta to fetch.
     */
    where: RespuestaWhereUniqueInput
  }

  /**
   * Respuesta findUnique
   */
  export interface RespuestaFindUniqueArgs extends RespuestaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Respuesta findUniqueOrThrow
   */
  export type RespuestaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    /**
     * Filter, which Respuesta to fetch.
     */
    where: RespuestaWhereUniqueInput
  }


  /**
   * Respuesta base type for findFirst actions
   */
  export type RespuestaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    /**
     * Filter, which Respuesta to fetch.
     */
    where?: RespuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Respuestas to fetch.
     */
    orderBy?: Enumerable<RespuestaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Respuestas.
     */
    cursor?: RespuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Respuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Respuestas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Respuestas.
     */
    distinct?: Enumerable<RespuestaScalarFieldEnum>
  }

  /**
   * Respuesta findFirst
   */
  export interface RespuestaFindFirstArgs extends RespuestaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Respuesta findFirstOrThrow
   */
  export type RespuestaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    /**
     * Filter, which Respuesta to fetch.
     */
    where?: RespuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Respuestas to fetch.
     */
    orderBy?: Enumerable<RespuestaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Respuestas.
     */
    cursor?: RespuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Respuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Respuestas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Respuestas.
     */
    distinct?: Enumerable<RespuestaScalarFieldEnum>
  }


  /**
   * Respuesta findMany
   */
  export type RespuestaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    /**
     * Filter, which Respuestas to fetch.
     */
    where?: RespuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Respuestas to fetch.
     */
    orderBy?: Enumerable<RespuestaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Respuestas.
     */
    cursor?: RespuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Respuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Respuestas.
     */
    skip?: number
    distinct?: Enumerable<RespuestaScalarFieldEnum>
  }


  /**
   * Respuesta create
   */
  export type RespuestaCreateArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    /**
     * The data needed to create a Respuesta.
     */
    data: XOR<RespuestaCreateInput, RespuestaUncheckedCreateInput>
  }


  /**
   * Respuesta createMany
   */
  export type RespuestaCreateManyArgs = {
    /**
     * The data used to create many Respuestas.
     */
    data: Enumerable<RespuestaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Respuesta update
   */
  export type RespuestaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    /**
     * The data needed to update a Respuesta.
     */
    data: XOR<RespuestaUpdateInput, RespuestaUncheckedUpdateInput>
    /**
     * Choose, which Respuesta to update.
     */
    where: RespuestaWhereUniqueInput
  }


  /**
   * Respuesta updateMany
   */
  export type RespuestaUpdateManyArgs = {
    /**
     * The data used to update Respuestas.
     */
    data: XOR<RespuestaUpdateManyMutationInput, RespuestaUncheckedUpdateManyInput>
    /**
     * Filter which Respuestas to update
     */
    where?: RespuestaWhereInput
  }


  /**
   * Respuesta upsert
   */
  export type RespuestaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    /**
     * The filter to search for the Respuesta to update in case it exists.
     */
    where: RespuestaWhereUniqueInput
    /**
     * In case the Respuesta found by the `where` argument doesn't exist, create a new Respuesta with this data.
     */
    create: XOR<RespuestaCreateInput, RespuestaUncheckedCreateInput>
    /**
     * In case the Respuesta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RespuestaUpdateInput, RespuestaUncheckedUpdateInput>
  }


  /**
   * Respuesta delete
   */
  export type RespuestaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
    /**
     * Filter which Respuesta to delete.
     */
    where: RespuestaWhereUniqueInput
  }


  /**
   * Respuesta deleteMany
   */
  export type RespuestaDeleteManyArgs = {
    /**
     * Filter which Respuestas to delete
     */
    where?: RespuestaWhereInput
  }


  /**
   * Respuesta.preguntas
   */
  export type Respuesta$preguntasArgs = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreguntaInclude | null
    where?: PreguntaWhereInput
    orderBy?: Enumerable<PreguntaOrderByWithRelationInput>
    cursor?: PreguntaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PreguntaScalarFieldEnum>
  }


  /**
   * Respuesta without action
   */
  export type RespuestaArgs = {
    /**
     * Select specific fields to fetch from the Respuesta
     */
    select?: RespuestaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespuestaInclude | null
  }



  /**
   * Model Informe
   */


  export type AggregateInforme = {
    _count: InformeCountAggregateOutputType | null
    _avg: InformeAvgAggregateOutputType | null
    _sum: InformeSumAggregateOutputType | null
    _min: InformeMinAggregateOutputType | null
    _max: InformeMaxAggregateOutputType | null
  }

  export type InformeAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type InformeSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type InformeMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InformeMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InformeCountAggregateOutputType = {
    id: number
    descripcion: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InformeAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type InformeSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type InformeMinAggregateInputType = {
    id?: true
    descripcion?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InformeMaxAggregateInputType = {
    id?: true
    descripcion?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InformeCountAggregateInputType = {
    id?: true
    descripcion?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InformeAggregateArgs = {
    /**
     * Filter which Informe to aggregate.
     */
    where?: InformeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Informes to fetch.
     */
    orderBy?: Enumerable<InformeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InformeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Informes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Informes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Informes
    **/
    _count?: true | InformeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InformeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InformeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InformeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InformeMaxAggregateInputType
  }

  export type GetInformeAggregateType<T extends InformeAggregateArgs> = {
        [P in keyof T & keyof AggregateInforme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInforme[P]>
      : GetScalarType<T[P], AggregateInforme[P]>
  }




  export type InformeGroupByArgs = {
    where?: InformeWhereInput
    orderBy?: Enumerable<InformeOrderByWithAggregationInput>
    by: InformeScalarFieldEnum[]
    having?: InformeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InformeCountAggregateInputType | true
    _avg?: InformeAvgAggregateInputType
    _sum?: InformeSumAggregateInputType
    _min?: InformeMinAggregateInputType
    _max?: InformeMaxAggregateInputType
  }


  export type InformeGroupByOutputType = {
    id: number
    descripcion: string
    usuarioId: number
    createdAt: Date
    updatedAt: Date
    _count: InformeCountAggregateOutputType | null
    _avg: InformeAvgAggregateOutputType | null
    _sum: InformeSumAggregateOutputType | null
    _min: InformeMinAggregateOutputType | null
    _max: InformeMaxAggregateOutputType | null
  }

  type GetInformeGroupByPayload<T extends InformeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InformeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InformeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InformeGroupByOutputType[P]>
            : GetScalarType<T[P], InformeGroupByOutputType[P]>
        }
      >
    >


  export type InformeSelect = {
    id?: boolean
    descripcion?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioArgs
  }


  export type InformeInclude = {
    usuario?: boolean | UsuarioArgs
  }

  export type InformeGetPayload<S extends boolean | null | undefined | InformeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Informe :
    S extends undefined ? never :
    S extends { include: any } & (InformeArgs | InformeFindManyArgs)
    ? Informe  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (InformeArgs | InformeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['select'][P]> :  P extends keyof Informe ? Informe[P] : never
  } 
      : Informe


  type InformeCountArgs = 
    Omit<InformeFindManyArgs, 'select' | 'include'> & {
      select?: InformeCountAggregateInputType | true
    }

  export interface InformeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Informe that matches the filter.
     * @param {InformeFindUniqueArgs} args - Arguments to find a Informe
     * @example
     * // Get one Informe
     * const informe = await prisma.informe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InformeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InformeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Informe'> extends True ? Prisma__InformeClient<InformeGetPayload<T>> : Prisma__InformeClient<InformeGetPayload<T> | null, null>

    /**
     * Find one Informe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InformeFindUniqueOrThrowArgs} args - Arguments to find a Informe
     * @example
     * // Get one Informe
     * const informe = await prisma.informe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InformeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InformeFindUniqueOrThrowArgs>
    ): Prisma__InformeClient<InformeGetPayload<T>>

    /**
     * Find the first Informe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InformeFindFirstArgs} args - Arguments to find a Informe
     * @example
     * // Get one Informe
     * const informe = await prisma.informe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InformeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InformeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Informe'> extends True ? Prisma__InformeClient<InformeGetPayload<T>> : Prisma__InformeClient<InformeGetPayload<T> | null, null>

    /**
     * Find the first Informe that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InformeFindFirstOrThrowArgs} args - Arguments to find a Informe
     * @example
     * // Get one Informe
     * const informe = await prisma.informe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InformeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InformeFindFirstOrThrowArgs>
    ): Prisma__InformeClient<InformeGetPayload<T>>

    /**
     * Find zero or more Informes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InformeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Informes
     * const informes = await prisma.informe.findMany()
     * 
     * // Get first 10 Informes
     * const informes = await prisma.informe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const informeWithIdOnly = await prisma.informe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InformeFindManyArgs>(
      args?: SelectSubset<T, InformeFindManyArgs>
    ): Prisma.PrismaPromise<Array<InformeGetPayload<T>>>

    /**
     * Create a Informe.
     * @param {InformeCreateArgs} args - Arguments to create a Informe.
     * @example
     * // Create one Informe
     * const Informe = await prisma.informe.create({
     *   data: {
     *     // ... data to create a Informe
     *   }
     * })
     * 
    **/
    create<T extends InformeCreateArgs>(
      args: SelectSubset<T, InformeCreateArgs>
    ): Prisma__InformeClient<InformeGetPayload<T>>

    /**
     * Create many Informes.
     *     @param {InformeCreateManyArgs} args - Arguments to create many Informes.
     *     @example
     *     // Create many Informes
     *     const informe = await prisma.informe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InformeCreateManyArgs>(
      args?: SelectSubset<T, InformeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Informe.
     * @param {InformeDeleteArgs} args - Arguments to delete one Informe.
     * @example
     * // Delete one Informe
     * const Informe = await prisma.informe.delete({
     *   where: {
     *     // ... filter to delete one Informe
     *   }
     * })
     * 
    **/
    delete<T extends InformeDeleteArgs>(
      args: SelectSubset<T, InformeDeleteArgs>
    ): Prisma__InformeClient<InformeGetPayload<T>>

    /**
     * Update one Informe.
     * @param {InformeUpdateArgs} args - Arguments to update one Informe.
     * @example
     * // Update one Informe
     * const informe = await prisma.informe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InformeUpdateArgs>(
      args: SelectSubset<T, InformeUpdateArgs>
    ): Prisma__InformeClient<InformeGetPayload<T>>

    /**
     * Delete zero or more Informes.
     * @param {InformeDeleteManyArgs} args - Arguments to filter Informes to delete.
     * @example
     * // Delete a few Informes
     * const { count } = await prisma.informe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InformeDeleteManyArgs>(
      args?: SelectSubset<T, InformeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Informes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InformeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Informes
     * const informe = await prisma.informe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InformeUpdateManyArgs>(
      args: SelectSubset<T, InformeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Informe.
     * @param {InformeUpsertArgs} args - Arguments to update or create a Informe.
     * @example
     * // Update or create a Informe
     * const informe = await prisma.informe.upsert({
     *   create: {
     *     // ... data to create a Informe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Informe we want to update
     *   }
     * })
    **/
    upsert<T extends InformeUpsertArgs>(
      args: SelectSubset<T, InformeUpsertArgs>
    ): Prisma__InformeClient<InformeGetPayload<T>>

    /**
     * Count the number of Informes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InformeCountArgs} args - Arguments to filter Informes to count.
     * @example
     * // Count the number of Informes
     * const count = await prisma.informe.count({
     *   where: {
     *     // ... the filter for the Informes we want to count
     *   }
     * })
    **/
    count<T extends InformeCountArgs>(
      args?: Subset<T, InformeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InformeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Informe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InformeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InformeAggregateArgs>(args: Subset<T, InformeAggregateArgs>): Prisma.PrismaPromise<GetInformeAggregateType<T>>

    /**
     * Group by Informe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InformeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InformeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InformeGroupByArgs['orderBy'] }
        : { orderBy?: InformeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InformeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInformeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Informe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InformeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends UsuarioArgs= {}>(args?: Subset<T, UsuarioArgs>): Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Informe base type for findUnique actions
   */
  export type InformeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    /**
     * Filter, which Informe to fetch.
     */
    where: InformeWhereUniqueInput
  }

  /**
   * Informe findUnique
   */
  export interface InformeFindUniqueArgs extends InformeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Informe findUniqueOrThrow
   */
  export type InformeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    /**
     * Filter, which Informe to fetch.
     */
    where: InformeWhereUniqueInput
  }


  /**
   * Informe base type for findFirst actions
   */
  export type InformeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    /**
     * Filter, which Informe to fetch.
     */
    where?: InformeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Informes to fetch.
     */
    orderBy?: Enumerable<InformeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Informes.
     */
    cursor?: InformeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Informes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Informes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Informes.
     */
    distinct?: Enumerable<InformeScalarFieldEnum>
  }

  /**
   * Informe findFirst
   */
  export interface InformeFindFirstArgs extends InformeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Informe findFirstOrThrow
   */
  export type InformeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    /**
     * Filter, which Informe to fetch.
     */
    where?: InformeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Informes to fetch.
     */
    orderBy?: Enumerable<InformeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Informes.
     */
    cursor?: InformeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Informes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Informes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Informes.
     */
    distinct?: Enumerable<InformeScalarFieldEnum>
  }


  /**
   * Informe findMany
   */
  export type InformeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    /**
     * Filter, which Informes to fetch.
     */
    where?: InformeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Informes to fetch.
     */
    orderBy?: Enumerable<InformeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Informes.
     */
    cursor?: InformeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Informes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Informes.
     */
    skip?: number
    distinct?: Enumerable<InformeScalarFieldEnum>
  }


  /**
   * Informe create
   */
  export type InformeCreateArgs = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    /**
     * The data needed to create a Informe.
     */
    data: XOR<InformeCreateInput, InformeUncheckedCreateInput>
  }


  /**
   * Informe createMany
   */
  export type InformeCreateManyArgs = {
    /**
     * The data used to create many Informes.
     */
    data: Enumerable<InformeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Informe update
   */
  export type InformeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    /**
     * The data needed to update a Informe.
     */
    data: XOR<InformeUpdateInput, InformeUncheckedUpdateInput>
    /**
     * Choose, which Informe to update.
     */
    where: InformeWhereUniqueInput
  }


  /**
   * Informe updateMany
   */
  export type InformeUpdateManyArgs = {
    /**
     * The data used to update Informes.
     */
    data: XOR<InformeUpdateManyMutationInput, InformeUncheckedUpdateManyInput>
    /**
     * Filter which Informes to update
     */
    where?: InformeWhereInput
  }


  /**
   * Informe upsert
   */
  export type InformeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    /**
     * The filter to search for the Informe to update in case it exists.
     */
    where: InformeWhereUniqueInput
    /**
     * In case the Informe found by the `where` argument doesn't exist, create a new Informe with this data.
     */
    create: XOR<InformeCreateInput, InformeUncheckedCreateInput>
    /**
     * In case the Informe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InformeUpdateInput, InformeUncheckedUpdateInput>
  }


  /**
   * Informe delete
   */
  export type InformeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
    /**
     * Filter which Informe to delete.
     */
    where: InformeWhereUniqueInput
  }


  /**
   * Informe deleteMany
   */
  export type InformeDeleteManyArgs = {
    /**
     * Filter which Informes to delete
     */
    where?: InformeWhereInput
  }


  /**
   * Informe without action
   */
  export type InformeArgs = {
    /**
     * Select specific fields to fetch from the Informe
     */
    select?: InformeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InformeInclude | null
  }



  /**
   * Model Evaluacion
   */


  export type AggregateEvaluacion = {
    _count: EvaluacionCountAggregateOutputType | null
    _avg: EvaluacionAvgAggregateOutputType | null
    _sum: EvaluacionSumAggregateOutputType | null
    _min: EvaluacionMinAggregateOutputType | null
    _max: EvaluacionMaxAggregateOutputType | null
  }

  export type EvaluacionAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    pedidoId: number | null
    nota: number | null
  }

  export type EvaluacionSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    pedidoId: number | null
    nota: number | null
  }

  export type EvaluacionMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    usuarioId: number | null
    pedidoId: number | null
    nota: number | null
    descripcion: string | null
    usuarioRol: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluacionMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    usuarioId: number | null
    pedidoId: number | null
    nota: number | null
    descripcion: string | null
    usuarioRol: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluacionCountAggregateOutputType = {
    id: number
    nombre: number
    usuarioId: number
    pedidoId: number
    nota: number
    descripcion: number
    usuarioRol: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvaluacionAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    pedidoId?: true
    nota?: true
  }

  export type EvaluacionSumAggregateInputType = {
    id?: true
    usuarioId?: true
    pedidoId?: true
    nota?: true
  }

  export type EvaluacionMinAggregateInputType = {
    id?: true
    nombre?: true
    usuarioId?: true
    pedidoId?: true
    nota?: true
    descripcion?: true
    usuarioRol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluacionMaxAggregateInputType = {
    id?: true
    nombre?: true
    usuarioId?: true
    pedidoId?: true
    nota?: true
    descripcion?: true
    usuarioRol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluacionCountAggregateInputType = {
    id?: true
    nombre?: true
    usuarioId?: true
    pedidoId?: true
    nota?: true
    descripcion?: true
    usuarioRol?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvaluacionAggregateArgs = {
    /**
     * Filter which Evaluacion to aggregate.
     */
    where?: EvaluacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluacions to fetch.
     */
    orderBy?: Enumerable<EvaluacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluacions
    **/
    _count?: true | EvaluacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluacionMaxAggregateInputType
  }

  export type GetEvaluacionAggregateType<T extends EvaluacionAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluacion[P]>
      : GetScalarType<T[P], AggregateEvaluacion[P]>
  }




  export type EvaluacionGroupByArgs = {
    where?: EvaluacionWhereInput
    orderBy?: Enumerable<EvaluacionOrderByWithAggregationInput>
    by: EvaluacionScalarFieldEnum[]
    having?: EvaluacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluacionCountAggregateInputType | true
    _avg?: EvaluacionAvgAggregateInputType
    _sum?: EvaluacionSumAggregateInputType
    _min?: EvaluacionMinAggregateInputType
    _max?: EvaluacionMaxAggregateInputType
  }


  export type EvaluacionGroupByOutputType = {
    id: number
    nombre: string
    usuarioId: number
    pedidoId: number
    nota: number
    descripcion: string | null
    usuarioRol: string
    createdAt: Date
    updatedAt: Date
    _count: EvaluacionCountAggregateOutputType | null
    _avg: EvaluacionAvgAggregateOutputType | null
    _sum: EvaluacionSumAggregateOutputType | null
    _min: EvaluacionMinAggregateOutputType | null
    _max: EvaluacionMaxAggregateOutputType | null
  }

  type GetEvaluacionGroupByPayload<T extends EvaluacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EvaluacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluacionGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluacionGroupByOutputType[P]>
        }
      >
    >


  export type EvaluacionSelect = {
    id?: boolean
    nombre?: boolean
    usuarioId?: boolean
    pedidoId?: boolean
    nota?: boolean
    descripcion?: boolean
    usuarioRol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioArgs
    pedido?: boolean | PedidoArgs
  }


  export type EvaluacionInclude = {
    usuario?: boolean | UsuarioArgs
    pedido?: boolean | PedidoArgs
  }

  export type EvaluacionGetPayload<S extends boolean | null | undefined | EvaluacionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Evaluacion :
    S extends undefined ? never :
    S extends { include: any } & (EvaluacionArgs | EvaluacionFindManyArgs)
    ? Evaluacion  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['include'][P]> :
        P extends 'pedido' ? PedidoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EvaluacionArgs | EvaluacionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['select'][P]> :
        P extends 'pedido' ? PedidoGetPayload<S['select'][P]> :  P extends keyof Evaluacion ? Evaluacion[P] : never
  } 
      : Evaluacion


  type EvaluacionCountArgs = 
    Omit<EvaluacionFindManyArgs, 'select' | 'include'> & {
      select?: EvaluacionCountAggregateInputType | true
    }

  export interface EvaluacionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Evaluacion that matches the filter.
     * @param {EvaluacionFindUniqueArgs} args - Arguments to find a Evaluacion
     * @example
     * // Get one Evaluacion
     * const evaluacion = await prisma.evaluacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EvaluacionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EvaluacionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Evaluacion'> extends True ? Prisma__EvaluacionClient<EvaluacionGetPayload<T>> : Prisma__EvaluacionClient<EvaluacionGetPayload<T> | null, null>

    /**
     * Find one Evaluacion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EvaluacionFindUniqueOrThrowArgs} args - Arguments to find a Evaluacion
     * @example
     * // Get one Evaluacion
     * const evaluacion = await prisma.evaluacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EvaluacionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EvaluacionFindUniqueOrThrowArgs>
    ): Prisma__EvaluacionClient<EvaluacionGetPayload<T>>

    /**
     * Find the first Evaluacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionFindFirstArgs} args - Arguments to find a Evaluacion
     * @example
     * // Get one Evaluacion
     * const evaluacion = await prisma.evaluacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EvaluacionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EvaluacionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Evaluacion'> extends True ? Prisma__EvaluacionClient<EvaluacionGetPayload<T>> : Prisma__EvaluacionClient<EvaluacionGetPayload<T> | null, null>

    /**
     * Find the first Evaluacion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionFindFirstOrThrowArgs} args - Arguments to find a Evaluacion
     * @example
     * // Get one Evaluacion
     * const evaluacion = await prisma.evaluacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EvaluacionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EvaluacionFindFirstOrThrowArgs>
    ): Prisma__EvaluacionClient<EvaluacionGetPayload<T>>

    /**
     * Find zero or more Evaluacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluacions
     * const evaluacions = await prisma.evaluacion.findMany()
     * 
     * // Get first 10 Evaluacions
     * const evaluacions = await prisma.evaluacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluacionWithIdOnly = await prisma.evaluacion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EvaluacionFindManyArgs>(
      args?: SelectSubset<T, EvaluacionFindManyArgs>
    ): Prisma.PrismaPromise<Array<EvaluacionGetPayload<T>>>

    /**
     * Create a Evaluacion.
     * @param {EvaluacionCreateArgs} args - Arguments to create a Evaluacion.
     * @example
     * // Create one Evaluacion
     * const Evaluacion = await prisma.evaluacion.create({
     *   data: {
     *     // ... data to create a Evaluacion
     *   }
     * })
     * 
    **/
    create<T extends EvaluacionCreateArgs>(
      args: SelectSubset<T, EvaluacionCreateArgs>
    ): Prisma__EvaluacionClient<EvaluacionGetPayload<T>>

    /**
     * Create many Evaluacions.
     *     @param {EvaluacionCreateManyArgs} args - Arguments to create many Evaluacions.
     *     @example
     *     // Create many Evaluacions
     *     const evaluacion = await prisma.evaluacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EvaluacionCreateManyArgs>(
      args?: SelectSubset<T, EvaluacionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evaluacion.
     * @param {EvaluacionDeleteArgs} args - Arguments to delete one Evaluacion.
     * @example
     * // Delete one Evaluacion
     * const Evaluacion = await prisma.evaluacion.delete({
     *   where: {
     *     // ... filter to delete one Evaluacion
     *   }
     * })
     * 
    **/
    delete<T extends EvaluacionDeleteArgs>(
      args: SelectSubset<T, EvaluacionDeleteArgs>
    ): Prisma__EvaluacionClient<EvaluacionGetPayload<T>>

    /**
     * Update one Evaluacion.
     * @param {EvaluacionUpdateArgs} args - Arguments to update one Evaluacion.
     * @example
     * // Update one Evaluacion
     * const evaluacion = await prisma.evaluacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EvaluacionUpdateArgs>(
      args: SelectSubset<T, EvaluacionUpdateArgs>
    ): Prisma__EvaluacionClient<EvaluacionGetPayload<T>>

    /**
     * Delete zero or more Evaluacions.
     * @param {EvaluacionDeleteManyArgs} args - Arguments to filter Evaluacions to delete.
     * @example
     * // Delete a few Evaluacions
     * const { count } = await prisma.evaluacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EvaluacionDeleteManyArgs>(
      args?: SelectSubset<T, EvaluacionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluacions
     * const evaluacion = await prisma.evaluacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EvaluacionUpdateManyArgs>(
      args: SelectSubset<T, EvaluacionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluacion.
     * @param {EvaluacionUpsertArgs} args - Arguments to update or create a Evaluacion.
     * @example
     * // Update or create a Evaluacion
     * const evaluacion = await prisma.evaluacion.upsert({
     *   create: {
     *     // ... data to create a Evaluacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluacion we want to update
     *   }
     * })
    **/
    upsert<T extends EvaluacionUpsertArgs>(
      args: SelectSubset<T, EvaluacionUpsertArgs>
    ): Prisma__EvaluacionClient<EvaluacionGetPayload<T>>

    /**
     * Count the number of Evaluacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionCountArgs} args - Arguments to filter Evaluacions to count.
     * @example
     * // Count the number of Evaluacions
     * const count = await prisma.evaluacion.count({
     *   where: {
     *     // ... the filter for the Evaluacions we want to count
     *   }
     * })
    **/
    count<T extends EvaluacionCountArgs>(
      args?: Subset<T, EvaluacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluacionAggregateArgs>(args: Subset<T, EvaluacionAggregateArgs>): Prisma.PrismaPromise<GetEvaluacionAggregateType<T>>

    /**
     * Group by Evaluacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluacionGroupByArgs['orderBy'] }
        : { orderBy?: EvaluacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EvaluacionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends UsuarioArgs= {}>(args?: Subset<T, UsuarioArgs>): Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>;

    pedido<T extends PedidoArgs= {}>(args?: Subset<T, PedidoArgs>): Prisma__PedidoClient<PedidoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Evaluacion base type for findUnique actions
   */
  export type EvaluacionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    /**
     * Filter, which Evaluacion to fetch.
     */
    where: EvaluacionWhereUniqueInput
  }

  /**
   * Evaluacion findUnique
   */
  export interface EvaluacionFindUniqueArgs extends EvaluacionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Evaluacion findUniqueOrThrow
   */
  export type EvaluacionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    /**
     * Filter, which Evaluacion to fetch.
     */
    where: EvaluacionWhereUniqueInput
  }


  /**
   * Evaluacion base type for findFirst actions
   */
  export type EvaluacionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    /**
     * Filter, which Evaluacion to fetch.
     */
    where?: EvaluacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluacions to fetch.
     */
    orderBy?: Enumerable<EvaluacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluacions.
     */
    cursor?: EvaluacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluacions.
     */
    distinct?: Enumerable<EvaluacionScalarFieldEnum>
  }

  /**
   * Evaluacion findFirst
   */
  export interface EvaluacionFindFirstArgs extends EvaluacionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Evaluacion findFirstOrThrow
   */
  export type EvaluacionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    /**
     * Filter, which Evaluacion to fetch.
     */
    where?: EvaluacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluacions to fetch.
     */
    orderBy?: Enumerable<EvaluacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluacions.
     */
    cursor?: EvaluacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluacions.
     */
    distinct?: Enumerable<EvaluacionScalarFieldEnum>
  }


  /**
   * Evaluacion findMany
   */
  export type EvaluacionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    /**
     * Filter, which Evaluacions to fetch.
     */
    where?: EvaluacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluacions to fetch.
     */
    orderBy?: Enumerable<EvaluacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluacions.
     */
    cursor?: EvaluacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluacions.
     */
    skip?: number
    distinct?: Enumerable<EvaluacionScalarFieldEnum>
  }


  /**
   * Evaluacion create
   */
  export type EvaluacionCreateArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    /**
     * The data needed to create a Evaluacion.
     */
    data: XOR<EvaluacionCreateInput, EvaluacionUncheckedCreateInput>
  }


  /**
   * Evaluacion createMany
   */
  export type EvaluacionCreateManyArgs = {
    /**
     * The data used to create many Evaluacions.
     */
    data: Enumerable<EvaluacionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Evaluacion update
   */
  export type EvaluacionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    /**
     * The data needed to update a Evaluacion.
     */
    data: XOR<EvaluacionUpdateInput, EvaluacionUncheckedUpdateInput>
    /**
     * Choose, which Evaluacion to update.
     */
    where: EvaluacionWhereUniqueInput
  }


  /**
   * Evaluacion updateMany
   */
  export type EvaluacionUpdateManyArgs = {
    /**
     * The data used to update Evaluacions.
     */
    data: XOR<EvaluacionUpdateManyMutationInput, EvaluacionUncheckedUpdateManyInput>
    /**
     * Filter which Evaluacions to update
     */
    where?: EvaluacionWhereInput
  }


  /**
   * Evaluacion upsert
   */
  export type EvaluacionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    /**
     * The filter to search for the Evaluacion to update in case it exists.
     */
    where: EvaluacionWhereUniqueInput
    /**
     * In case the Evaluacion found by the `where` argument doesn't exist, create a new Evaluacion with this data.
     */
    create: XOR<EvaluacionCreateInput, EvaluacionUncheckedCreateInput>
    /**
     * In case the Evaluacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluacionUpdateInput, EvaluacionUncheckedUpdateInput>
  }


  /**
   * Evaluacion delete
   */
  export type EvaluacionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
    /**
     * Filter which Evaluacion to delete.
     */
    where: EvaluacionWhereUniqueInput
  }


  /**
   * Evaluacion deleteMany
   */
  export type EvaluacionDeleteManyArgs = {
    /**
     * Filter which Evaluacions to delete
     */
    where?: EvaluacionWhereInput
  }


  /**
   * Evaluacion without action
   */
  export type EvaluacionArgs = {
    /**
     * Select specific fields to fetch from the Evaluacion
     */
    select?: EvaluacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluacionInclude | null
  }



  /**
   * Model Categoria
   */


  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    descripcion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaSumAggregateInputType = {
    id?: true
  }

  export type CategoriaMinAggregateInputType = {
    id?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoriaAggregateArgs = {
    /**
     * Filter which Categoria to aggregate.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs = {
    where?: CategoriaWhereInput
    orderBy?: Enumerable<CategoriaOrderByWithAggregationInput>
    by: CategoriaScalarFieldEnum[]
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }


  export type CategoriaGroupByOutputType = {
    id: number
    descripcion: string
    createdAt: Date
    updatedAt: Date
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect = {
    id?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ropas?: boolean | Categoria$ropasArgs
    _count?: boolean | CategoriaCountOutputTypeArgs
  }


  export type CategoriaInclude = {
    ropas?: boolean | Categoria$ropasArgs
    _count?: boolean | CategoriaCountOutputTypeArgs
  }

  export type CategoriaGetPayload<S extends boolean | null | undefined | CategoriaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Categoria :
    S extends undefined ? never :
    S extends { include: any } & (CategoriaArgs | CategoriaFindManyArgs)
    ? Categoria  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ropas' ? Array < RopaGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoriaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CategoriaArgs | CategoriaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ropas' ? Array < RopaGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoriaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Categoria ? Categoria[P] : never
  } 
      : Categoria


  type CategoriaCountArgs = 
    Omit<CategoriaFindManyArgs, 'select' | 'include'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface CategoriaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoriaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Categoria'> extends True ? Prisma__CategoriaClient<CategoriaGetPayload<T>> : Prisma__CategoriaClient<CategoriaGetPayload<T> | null, null>

    /**
     * Find one Categoria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoriaFindUniqueOrThrowArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoriaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Categoria'> extends True ? Prisma__CategoriaClient<CategoriaGetPayload<T>> : Prisma__CategoriaClient<CategoriaGetPayload<T> | null, null>

    /**
     * Find the first Categoria that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoriaFindManyArgs>(
      args?: SelectSubset<T, CategoriaFindManyArgs>
    ): Prisma.PrismaPromise<Array<CategoriaGetPayload<T>>>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
    **/
    create<T extends CategoriaCreateArgs>(
      args: SelectSubset<T, CategoriaCreateArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Create many Categorias.
     *     @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     *     @example
     *     // Create many Categorias
     *     const categoria = await prisma.categoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriaCreateManyArgs>(
      args?: SelectSubset<T, CategoriaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
    **/
    delete<T extends CategoriaDeleteArgs>(
      args: SelectSubset<T, CategoriaDeleteArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriaUpdateArgs>(
      args: SelectSubset<T, CategoriaUpdateArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriaDeleteManyArgs>(
      args?: SelectSubset<T, CategoriaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriaUpdateManyArgs>(
      args: SelectSubset<T, CategoriaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriaUpsertArgs>(
      args: SelectSubset<T, CategoriaUpsertArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoriaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ropas<T extends Categoria$ropasArgs= {}>(args?: Subset<T, Categoria$ropasArgs>): Prisma.PrismaPromise<Array<RopaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Categoria base type for findUnique actions
   */
  export type CategoriaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findUnique
   */
  export interface CategoriaFindUniqueArgs extends CategoriaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria base type for findFirst actions
   */
  export type CategoriaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: Enumerable<CategoriaScalarFieldEnum>
  }

  /**
   * Categoria findFirst
   */
  export interface CategoriaFindFirstArgs extends CategoriaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: Enumerable<CategoriaScalarFieldEnum>
  }


  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    /**
     * Filter, which Categorias to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    distinct?: Enumerable<CategoriaScalarFieldEnum>
  }


  /**
   * Categoria create
   */
  export type CategoriaCreateArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    /**
     * The data needed to create a Categoria.
     */
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }


  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs = {
    /**
     * The data used to create many Categorias.
     */
    data: Enumerable<CategoriaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    /**
     * The data needed to update a Categoria.
     */
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs = {
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
  }


  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     */
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     */
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }


  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
    /**
     * Filter which Categoria to delete.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs = {
    /**
     * Filter which Categorias to delete
     */
    where?: CategoriaWhereInput
  }


  /**
   * Categoria.ropas
   */
  export type Categoria$ropasArgs = {
    /**
     * Select specific fields to fetch from the Ropa
     */
    select?: RopaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RopaInclude | null
    where?: RopaWhereInput
    orderBy?: Enumerable<RopaOrderByWithRelationInput>
    cursor?: RopaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RopaScalarFieldEnum>
  }


  /**
   * Categoria without action
   */
  export type CategoriaArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude | null
  }



  /**
   * Model Direccion
   */


  export type AggregateDireccion = {
    _count: DireccionCountAggregateOutputType | null
    _avg: DireccionAvgAggregateOutputType | null
    _sum: DireccionSumAggregateOutputType | null
    _min: DireccionMinAggregateOutputType | null
    _max: DireccionMaxAggregateOutputType | null
  }

  export type DireccionAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type DireccionSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type DireccionMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    provincia: string | null
    canton: string | null
    distrito: string | null
    direccionExacta: string | null
    codPostal: string | null
    telef: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DireccionMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    provincia: string | null
    canton: string | null
    distrito: string | null
    direccionExacta: string | null
    codPostal: string | null
    telef: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DireccionCountAggregateOutputType = {
    id: number
    usuarioId: number
    provincia: number
    canton: number
    distrito: number
    direccionExacta: number
    codPostal: number
    telef: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DireccionAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type DireccionSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type DireccionMinAggregateInputType = {
    id?: true
    usuarioId?: true
    provincia?: true
    canton?: true
    distrito?: true
    direccionExacta?: true
    codPostal?: true
    telef?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DireccionMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    provincia?: true
    canton?: true
    distrito?: true
    direccionExacta?: true
    codPostal?: true
    telef?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DireccionCountAggregateInputType = {
    id?: true
    usuarioId?: true
    provincia?: true
    canton?: true
    distrito?: true
    direccionExacta?: true
    codPostal?: true
    telef?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DireccionAggregateArgs = {
    /**
     * Filter which Direccion to aggregate.
     */
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     */
    orderBy?: Enumerable<DireccionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Direccions
    **/
    _count?: true | DireccionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DireccionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DireccionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DireccionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DireccionMaxAggregateInputType
  }

  export type GetDireccionAggregateType<T extends DireccionAggregateArgs> = {
        [P in keyof T & keyof AggregateDireccion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDireccion[P]>
      : GetScalarType<T[P], AggregateDireccion[P]>
  }




  export type DireccionGroupByArgs = {
    where?: DireccionWhereInput
    orderBy?: Enumerable<DireccionOrderByWithAggregationInput>
    by: DireccionScalarFieldEnum[]
    having?: DireccionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DireccionCountAggregateInputType | true
    _avg?: DireccionAvgAggregateInputType
    _sum?: DireccionSumAggregateInputType
    _min?: DireccionMinAggregateInputType
    _max?: DireccionMaxAggregateInputType
  }


  export type DireccionGroupByOutputType = {
    id: number
    usuarioId: number
    provincia: string
    canton: string
    distrito: string
    direccionExacta: string
    codPostal: string
    telef: string
    createdAt: Date
    updatedAt: Date
    _count: DireccionCountAggregateOutputType | null
    _avg: DireccionAvgAggregateOutputType | null
    _sum: DireccionSumAggregateOutputType | null
    _min: DireccionMinAggregateOutputType | null
    _max: DireccionMaxAggregateOutputType | null
  }

  type GetDireccionGroupByPayload<T extends DireccionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DireccionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DireccionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DireccionGroupByOutputType[P]>
            : GetScalarType<T[P], DireccionGroupByOutputType[P]>
        }
      >
    >


  export type DireccionSelect = {
    id?: boolean
    usuarioId?: boolean
    provincia?: boolean
    canton?: boolean
    distrito?: boolean
    direccionExacta?: boolean
    codPostal?: boolean
    telef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioArgs
    pedidos?: boolean | Direccion$pedidosArgs
    _count?: boolean | DireccionCountOutputTypeArgs
  }


  export type DireccionInclude = {
    usuario?: boolean | UsuarioArgs
    pedidos?: boolean | Direccion$pedidosArgs
    _count?: boolean | DireccionCountOutputTypeArgs
  }

  export type DireccionGetPayload<S extends boolean | null | undefined | DireccionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Direccion :
    S extends undefined ? never :
    S extends { include: any } & (DireccionArgs | DireccionFindManyArgs)
    ? Direccion  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['include'][P]> :
        P extends 'pedidos' ? Array < PedidoGetPayload<S['include'][P]>>  :
        P extends '_count' ? DireccionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DireccionArgs | DireccionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'usuario' ? UsuarioGetPayload<S['select'][P]> :
        P extends 'pedidos' ? Array < PedidoGetPayload<S['select'][P]>>  :
        P extends '_count' ? DireccionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Direccion ? Direccion[P] : never
  } 
      : Direccion


  type DireccionCountArgs = 
    Omit<DireccionFindManyArgs, 'select' | 'include'> & {
      select?: DireccionCountAggregateInputType | true
    }

  export interface DireccionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Direccion that matches the filter.
     * @param {DireccionFindUniqueArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DireccionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DireccionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Direccion'> extends True ? Prisma__DireccionClient<DireccionGetPayload<T>> : Prisma__DireccionClient<DireccionGetPayload<T> | null, null>

    /**
     * Find one Direccion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DireccionFindUniqueOrThrowArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DireccionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DireccionFindUniqueOrThrowArgs>
    ): Prisma__DireccionClient<DireccionGetPayload<T>>

    /**
     * Find the first Direccion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindFirstArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DireccionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DireccionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Direccion'> extends True ? Prisma__DireccionClient<DireccionGetPayload<T>> : Prisma__DireccionClient<DireccionGetPayload<T> | null, null>

    /**
     * Find the first Direccion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindFirstOrThrowArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DireccionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DireccionFindFirstOrThrowArgs>
    ): Prisma__DireccionClient<DireccionGetPayload<T>>

    /**
     * Find zero or more Direccions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Direccions
     * const direccions = await prisma.direccion.findMany()
     * 
     * // Get first 10 Direccions
     * const direccions = await prisma.direccion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const direccionWithIdOnly = await prisma.direccion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DireccionFindManyArgs>(
      args?: SelectSubset<T, DireccionFindManyArgs>
    ): Prisma.PrismaPromise<Array<DireccionGetPayload<T>>>

    /**
     * Create a Direccion.
     * @param {DireccionCreateArgs} args - Arguments to create a Direccion.
     * @example
     * // Create one Direccion
     * const Direccion = await prisma.direccion.create({
     *   data: {
     *     // ... data to create a Direccion
     *   }
     * })
     * 
    **/
    create<T extends DireccionCreateArgs>(
      args: SelectSubset<T, DireccionCreateArgs>
    ): Prisma__DireccionClient<DireccionGetPayload<T>>

    /**
     * Create many Direccions.
     *     @param {DireccionCreateManyArgs} args - Arguments to create many Direccions.
     *     @example
     *     // Create many Direccions
     *     const direccion = await prisma.direccion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DireccionCreateManyArgs>(
      args?: SelectSubset<T, DireccionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Direccion.
     * @param {DireccionDeleteArgs} args - Arguments to delete one Direccion.
     * @example
     * // Delete one Direccion
     * const Direccion = await prisma.direccion.delete({
     *   where: {
     *     // ... filter to delete one Direccion
     *   }
     * })
     * 
    **/
    delete<T extends DireccionDeleteArgs>(
      args: SelectSubset<T, DireccionDeleteArgs>
    ): Prisma__DireccionClient<DireccionGetPayload<T>>

    /**
     * Update one Direccion.
     * @param {DireccionUpdateArgs} args - Arguments to update one Direccion.
     * @example
     * // Update one Direccion
     * const direccion = await prisma.direccion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DireccionUpdateArgs>(
      args: SelectSubset<T, DireccionUpdateArgs>
    ): Prisma__DireccionClient<DireccionGetPayload<T>>

    /**
     * Delete zero or more Direccions.
     * @param {DireccionDeleteManyArgs} args - Arguments to filter Direccions to delete.
     * @example
     * // Delete a few Direccions
     * const { count } = await prisma.direccion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DireccionDeleteManyArgs>(
      args?: SelectSubset<T, DireccionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Direccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Direccions
     * const direccion = await prisma.direccion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DireccionUpdateManyArgs>(
      args: SelectSubset<T, DireccionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Direccion.
     * @param {DireccionUpsertArgs} args - Arguments to update or create a Direccion.
     * @example
     * // Update or create a Direccion
     * const direccion = await prisma.direccion.upsert({
     *   create: {
     *     // ... data to create a Direccion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Direccion we want to update
     *   }
     * })
    **/
    upsert<T extends DireccionUpsertArgs>(
      args: SelectSubset<T, DireccionUpsertArgs>
    ): Prisma__DireccionClient<DireccionGetPayload<T>>

    /**
     * Count the number of Direccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionCountArgs} args - Arguments to filter Direccions to count.
     * @example
     * // Count the number of Direccions
     * const count = await prisma.direccion.count({
     *   where: {
     *     // ... the filter for the Direccions we want to count
     *   }
     * })
    **/
    count<T extends DireccionCountArgs>(
      args?: Subset<T, DireccionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DireccionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Direccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DireccionAggregateArgs>(args: Subset<T, DireccionAggregateArgs>): Prisma.PrismaPromise<GetDireccionAggregateType<T>>

    /**
     * Group by Direccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DireccionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DireccionGroupByArgs['orderBy'] }
        : { orderBy?: DireccionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DireccionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDireccionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Direccion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DireccionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends UsuarioArgs= {}>(args?: Subset<T, UsuarioArgs>): Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>;

    pedidos<T extends Direccion$pedidosArgs= {}>(args?: Subset<T, Direccion$pedidosArgs>): Prisma.PrismaPromise<Array<PedidoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Direccion base type for findUnique actions
   */
  export type DireccionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    /**
     * Filter, which Direccion to fetch.
     */
    where: DireccionWhereUniqueInput
  }

  /**
   * Direccion findUnique
   */
  export interface DireccionFindUniqueArgs extends DireccionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Direccion findUniqueOrThrow
   */
  export type DireccionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    /**
     * Filter, which Direccion to fetch.
     */
    where: DireccionWhereUniqueInput
  }


  /**
   * Direccion base type for findFirst actions
   */
  export type DireccionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    /**
     * Filter, which Direccion to fetch.
     */
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     */
    orderBy?: Enumerable<DireccionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Direccions.
     */
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Direccions.
     */
    distinct?: Enumerable<DireccionScalarFieldEnum>
  }

  /**
   * Direccion findFirst
   */
  export interface DireccionFindFirstArgs extends DireccionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Direccion findFirstOrThrow
   */
  export type DireccionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    /**
     * Filter, which Direccion to fetch.
     */
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     */
    orderBy?: Enumerable<DireccionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Direccions.
     */
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Direccions.
     */
    distinct?: Enumerable<DireccionScalarFieldEnum>
  }


  /**
   * Direccion findMany
   */
  export type DireccionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    /**
     * Filter, which Direccions to fetch.
     */
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     */
    orderBy?: Enumerable<DireccionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Direccions.
     */
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     */
    skip?: number
    distinct?: Enumerable<DireccionScalarFieldEnum>
  }


  /**
   * Direccion create
   */
  export type DireccionCreateArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    /**
     * The data needed to create a Direccion.
     */
    data: XOR<DireccionCreateInput, DireccionUncheckedCreateInput>
  }


  /**
   * Direccion createMany
   */
  export type DireccionCreateManyArgs = {
    /**
     * The data used to create many Direccions.
     */
    data: Enumerable<DireccionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Direccion update
   */
  export type DireccionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    /**
     * The data needed to update a Direccion.
     */
    data: XOR<DireccionUpdateInput, DireccionUncheckedUpdateInput>
    /**
     * Choose, which Direccion to update.
     */
    where: DireccionWhereUniqueInput
  }


  /**
   * Direccion updateMany
   */
  export type DireccionUpdateManyArgs = {
    /**
     * The data used to update Direccions.
     */
    data: XOR<DireccionUpdateManyMutationInput, DireccionUncheckedUpdateManyInput>
    /**
     * Filter which Direccions to update
     */
    where?: DireccionWhereInput
  }


  /**
   * Direccion upsert
   */
  export type DireccionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    /**
     * The filter to search for the Direccion to update in case it exists.
     */
    where: DireccionWhereUniqueInput
    /**
     * In case the Direccion found by the `where` argument doesn't exist, create a new Direccion with this data.
     */
    create: XOR<DireccionCreateInput, DireccionUncheckedCreateInput>
    /**
     * In case the Direccion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DireccionUpdateInput, DireccionUncheckedUpdateInput>
  }


  /**
   * Direccion delete
   */
  export type DireccionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
    /**
     * Filter which Direccion to delete.
     */
    where: DireccionWhereUniqueInput
  }


  /**
   * Direccion deleteMany
   */
  export type DireccionDeleteManyArgs = {
    /**
     * Filter which Direccions to delete
     */
    where?: DireccionWhereInput
  }


  /**
   * Direccion.pedidos
   */
  export type Direccion$pedidosArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude | null
    where?: PedidoWhereInput
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }


  /**
   * Direccion without action
   */
  export type DireccionArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude | null
  }



  /**
   * Model Foto
   */


  export type AggregateFoto = {
    _count: FotoCountAggregateOutputType | null
    _avg: FotoAvgAggregateOutputType | null
    _sum: FotoSumAggregateOutputType | null
    _min: FotoMinAggregateOutputType | null
    _max: FotoMaxAggregateOutputType | null
  }

  export type FotoAvgAggregateOutputType = {
    id: number | null
    ropaId: number | null
  }

  export type FotoSumAggregateOutputType = {
    id: number | null
    ropaId: number | null
  }

  export type FotoMinAggregateOutputType = {
    id: number | null
    ropaId: number | null
    foto: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FotoMaxAggregateOutputType = {
    id: number | null
    ropaId: number | null
    foto: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FotoCountAggregateOutputType = {
    id: number
    ropaId: number
    foto: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FotoAvgAggregateInputType = {
    id?: true
    ropaId?: true
  }

  export type FotoSumAggregateInputType = {
    id?: true
    ropaId?: true
  }

  export type FotoMinAggregateInputType = {
    id?: true
    ropaId?: true
    foto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FotoMaxAggregateInputType = {
    id?: true
    ropaId?: true
    foto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FotoCountAggregateInputType = {
    id?: true
    ropaId?: true
    foto?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FotoAggregateArgs = {
    /**
     * Filter which Foto to aggregate.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: Enumerable<FotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fotos
    **/
    _count?: true | FotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FotoMaxAggregateInputType
  }

  export type GetFotoAggregateType<T extends FotoAggregateArgs> = {
        [P in keyof T & keyof AggregateFoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoto[P]>
      : GetScalarType<T[P], AggregateFoto[P]>
  }




  export type FotoGroupByArgs = {
    where?: FotoWhereInput
    orderBy?: Enumerable<FotoOrderByWithAggregationInput>
    by: FotoScalarFieldEnum[]
    having?: FotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FotoCountAggregateInputType | true
    _avg?: FotoAvgAggregateInputType
    _sum?: FotoSumAggregateInputType
    _min?: FotoMinAggregateInputType
    _max?: FotoMaxAggregateInputType
  }


  export type FotoGroupByOutputType = {
    id: number
    ropaId: number
    foto: string
    createdAt: Date
    updatedAt: Date
    _count: FotoCountAggregateOutputType | null
    _avg: FotoAvgAggregateOutputType | null
    _sum: FotoSumAggregateOutputType | null
    _min: FotoMinAggregateOutputType | null
    _max: FotoMaxAggregateOutputType | null
  }

  type GetFotoGroupByPayload<T extends FotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FotoGroupByOutputType[P]>
            : GetScalarType<T[P], FotoGroupByOutputType[P]>
        }
      >
    >


  export type FotoSelect = {
    id?: boolean
    ropaId?: boolean
    foto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ropa?: boolean | RopaArgs
  }


  export type FotoInclude = {
    ropa?: boolean | RopaArgs
  }

  export type FotoGetPayload<S extends boolean | null | undefined | FotoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Foto :
    S extends undefined ? never :
    S extends { include: any } & (FotoArgs | FotoFindManyArgs)
    ? Foto  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ropa' ? RopaGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FotoArgs | FotoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ropa' ? RopaGetPayload<S['select'][P]> :  P extends keyof Foto ? Foto[P] : never
  } 
      : Foto


  type FotoCountArgs = 
    Omit<FotoFindManyArgs, 'select' | 'include'> & {
      select?: FotoCountAggregateInputType | true
    }

  export interface FotoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Foto that matches the filter.
     * @param {FotoFindUniqueArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FotoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FotoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Foto'> extends True ? Prisma__FotoClient<FotoGetPayload<T>> : Prisma__FotoClient<FotoGetPayload<T> | null, null>

    /**
     * Find one Foto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FotoFindUniqueOrThrowArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FotoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FotoFindUniqueOrThrowArgs>
    ): Prisma__FotoClient<FotoGetPayload<T>>

    /**
     * Find the first Foto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoFindFirstArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FotoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FotoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Foto'> extends True ? Prisma__FotoClient<FotoGetPayload<T>> : Prisma__FotoClient<FotoGetPayload<T> | null, null>

    /**
     * Find the first Foto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoFindFirstOrThrowArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FotoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FotoFindFirstOrThrowArgs>
    ): Prisma__FotoClient<FotoGetPayload<T>>

    /**
     * Find zero or more Fotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fotos
     * const fotos = await prisma.foto.findMany()
     * 
     * // Get first 10 Fotos
     * const fotos = await prisma.foto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fotoWithIdOnly = await prisma.foto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FotoFindManyArgs>(
      args?: SelectSubset<T, FotoFindManyArgs>
    ): Prisma.PrismaPromise<Array<FotoGetPayload<T>>>

    /**
     * Create a Foto.
     * @param {FotoCreateArgs} args - Arguments to create a Foto.
     * @example
     * // Create one Foto
     * const Foto = await prisma.foto.create({
     *   data: {
     *     // ... data to create a Foto
     *   }
     * })
     * 
    **/
    create<T extends FotoCreateArgs>(
      args: SelectSubset<T, FotoCreateArgs>
    ): Prisma__FotoClient<FotoGetPayload<T>>

    /**
     * Create many Fotos.
     *     @param {FotoCreateManyArgs} args - Arguments to create many Fotos.
     *     @example
     *     // Create many Fotos
     *     const foto = await prisma.foto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FotoCreateManyArgs>(
      args?: SelectSubset<T, FotoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Foto.
     * @param {FotoDeleteArgs} args - Arguments to delete one Foto.
     * @example
     * // Delete one Foto
     * const Foto = await prisma.foto.delete({
     *   where: {
     *     // ... filter to delete one Foto
     *   }
     * })
     * 
    **/
    delete<T extends FotoDeleteArgs>(
      args: SelectSubset<T, FotoDeleteArgs>
    ): Prisma__FotoClient<FotoGetPayload<T>>

    /**
     * Update one Foto.
     * @param {FotoUpdateArgs} args - Arguments to update one Foto.
     * @example
     * // Update one Foto
     * const foto = await prisma.foto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FotoUpdateArgs>(
      args: SelectSubset<T, FotoUpdateArgs>
    ): Prisma__FotoClient<FotoGetPayload<T>>

    /**
     * Delete zero or more Fotos.
     * @param {FotoDeleteManyArgs} args - Arguments to filter Fotos to delete.
     * @example
     * // Delete a few Fotos
     * const { count } = await prisma.foto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FotoDeleteManyArgs>(
      args?: SelectSubset<T, FotoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fotos
     * const foto = await prisma.foto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FotoUpdateManyArgs>(
      args: SelectSubset<T, FotoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foto.
     * @param {FotoUpsertArgs} args - Arguments to update or create a Foto.
     * @example
     * // Update or create a Foto
     * const foto = await prisma.foto.upsert({
     *   create: {
     *     // ... data to create a Foto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foto we want to update
     *   }
     * })
    **/
    upsert<T extends FotoUpsertArgs>(
      args: SelectSubset<T, FotoUpsertArgs>
    ): Prisma__FotoClient<FotoGetPayload<T>>

    /**
     * Count the number of Fotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoCountArgs} args - Arguments to filter Fotos to count.
     * @example
     * // Count the number of Fotos
     * const count = await prisma.foto.count({
     *   where: {
     *     // ... the filter for the Fotos we want to count
     *   }
     * })
    **/
    count<T extends FotoCountArgs>(
      args?: Subset<T, FotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FotoAggregateArgs>(args: Subset<T, FotoAggregateArgs>): Prisma.PrismaPromise<GetFotoAggregateType<T>>

    /**
     * Group by Foto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FotoGroupByArgs['orderBy'] }
        : { orderBy?: FotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Foto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FotoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ropa<T extends RopaArgs= {}>(args?: Subset<T, RopaArgs>): Prisma__RopaClient<RopaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Foto base type for findUnique actions
   */
  export type FotoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    /**
     * Filter, which Foto to fetch.
     */
    where: FotoWhereUniqueInput
  }

  /**
   * Foto findUnique
   */
  export interface FotoFindUniqueArgs extends FotoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Foto findUniqueOrThrow
   */
  export type FotoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    /**
     * Filter, which Foto to fetch.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto base type for findFirst actions
   */
  export type FotoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    /**
     * Filter, which Foto to fetch.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: Enumerable<FotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fotos.
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fotos.
     */
    distinct?: Enumerable<FotoScalarFieldEnum>
  }

  /**
   * Foto findFirst
   */
  export interface FotoFindFirstArgs extends FotoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Foto findFirstOrThrow
   */
  export type FotoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    /**
     * Filter, which Foto to fetch.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: Enumerable<FotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fotos.
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fotos.
     */
    distinct?: Enumerable<FotoScalarFieldEnum>
  }


  /**
   * Foto findMany
   */
  export type FotoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    /**
     * Filter, which Fotos to fetch.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: Enumerable<FotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fotos.
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    distinct?: Enumerable<FotoScalarFieldEnum>
  }


  /**
   * Foto create
   */
  export type FotoCreateArgs = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    /**
     * The data needed to create a Foto.
     */
    data: XOR<FotoCreateInput, FotoUncheckedCreateInput>
  }


  /**
   * Foto createMany
   */
  export type FotoCreateManyArgs = {
    /**
     * The data used to create many Fotos.
     */
    data: Enumerable<FotoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Foto update
   */
  export type FotoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    /**
     * The data needed to update a Foto.
     */
    data: XOR<FotoUpdateInput, FotoUncheckedUpdateInput>
    /**
     * Choose, which Foto to update.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto updateMany
   */
  export type FotoUpdateManyArgs = {
    /**
     * The data used to update Fotos.
     */
    data: XOR<FotoUpdateManyMutationInput, FotoUncheckedUpdateManyInput>
    /**
     * Filter which Fotos to update
     */
    where?: FotoWhereInput
  }


  /**
   * Foto upsert
   */
  export type FotoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    /**
     * The filter to search for the Foto to update in case it exists.
     */
    where: FotoWhereUniqueInput
    /**
     * In case the Foto found by the `where` argument doesn't exist, create a new Foto with this data.
     */
    create: XOR<FotoCreateInput, FotoUncheckedCreateInput>
    /**
     * In case the Foto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FotoUpdateInput, FotoUncheckedUpdateInput>
  }


  /**
   * Foto delete
   */
  export type FotoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
    /**
     * Filter which Foto to delete.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto deleteMany
   */
  export type FotoDeleteManyArgs = {
    /**
     * Filter which Fotos to delete
     */
    where?: FotoWhereInput
  }


  /**
   * Foto without action
   */
  export type FotoArgs = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CategoriaScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const DireccionScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    provincia: 'provincia',
    canton: 'canton',
    distrito: 'distrito',
    direccionExacta: 'direccionExacta',
    codPostal: 'codPostal',
    telef: 'telef',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DireccionScalarFieldEnum = (typeof DireccionScalarFieldEnum)[keyof typeof DireccionScalarFieldEnum]


  export const EvaluacionScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    usuarioId: 'usuarioId',
    pedidoId: 'pedidoId',
    nota: 'nota',
    descripcion: 'descripcion',
    usuarioRol: 'usuarioRol',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvaluacionScalarFieldEnum = (typeof EvaluacionScalarFieldEnum)[keyof typeof EvaluacionScalarFieldEnum]


  export const FotoScalarFieldEnum: {
    id: 'id',
    ropaId: 'ropaId',
    foto: 'foto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FotoScalarFieldEnum = (typeof FotoScalarFieldEnum)[keyof typeof FotoScalarFieldEnum]


  export const InformeScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InformeScalarFieldEnum = (typeof InformeScalarFieldEnum)[keyof typeof InformeScalarFieldEnum]


  export const MetodoPagoScalarFieldEnum: {
    id: 'id',
    idCliente: 'idCliente',
    descripcion: 'descripcion',
    proveedor: 'proveedor',
    numeroCuenta: 'numeroCuenta',
    fechaExpiracion: 'fechaExpiracion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MetodoPagoScalarFieldEnum = (typeof MetodoPagoScalarFieldEnum)[keyof typeof MetodoPagoScalarFieldEnum]


  export const PedidoRopaScalarFieldEnum: {
    id: 'id',
    idRopa: 'idRopa',
    idPedido: 'idPedido',
    cantidad: 'cantidad',
    subtotal: 'subtotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PedidoRopaScalarFieldEnum = (typeof PedidoRopaScalarFieldEnum)[keyof typeof PedidoRopaScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id: 'id',
    fechaOrden: 'fechaOrden',
    idPago: 'idPago',
    clienteId: 'clienteId',
    direccionId: 'direccionId',
    descuento: 'descuento',
    IV: 'IV',
    estado: 'estado',
    subtotal: 'subtotal',
    Total: 'Total',
    fecha: 'fecha',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const PreguntaScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion',
    usuarioId: 'usuarioId',
    ropaId: 'ropaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PreguntaScalarFieldEnum = (typeof PreguntaScalarFieldEnum)[keyof typeof PreguntaScalarFieldEnum]


  export const ProveedorScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProveedorScalarFieldEnum = (typeof ProveedorScalarFieldEnum)[keyof typeof ProveedorScalarFieldEnum]


  export const RespuestaScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RespuestaScalarFieldEnum = (typeof RespuestaScalarFieldEnum)[keyof typeof RespuestaScalarFieldEnum]


  export const RopaScalarFieldEnum: {
    id: 'id',
    vendedorId: 'vendedorId',
    nombre: 'nombre',
    precio: 'precio',
    estado: 'estado',
    cantidad: 'cantidad',
    proveedorId: 'proveedorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RopaScalarFieldEnum = (typeof RopaScalarFieldEnum)[keyof typeof RopaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    cedula: 'cedula',
    telefono: 'telefono',
    correo: 'correo',
    contrasenna: 'contrasenna',
    estado: 'estado',
    rol: 'rol',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type ProveedorWhereInput = {
    AND?: Enumerable<ProveedorWhereInput>
    OR?: Enumerable<ProveedorWhereInput>
    NOT?: Enumerable<ProveedorWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    ropas?: RopaListRelationFilter
  }

  export type ProveedorOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ropas?: RopaOrderByRelationAggregateInput
  }

  export type ProveedorWhereUniqueInput = {
    id?: number
  }

  export type ProveedorOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProveedorCountOrderByAggregateInput
    _avg?: ProveedorAvgOrderByAggregateInput
    _max?: ProveedorMaxOrderByAggregateInput
    _min?: ProveedorMinOrderByAggregateInput
    _sum?: ProveedorSumOrderByAggregateInput
  }

  export type ProveedorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProveedorScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProveedorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProveedorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RopaWhereInput = {
    AND?: Enumerable<RopaWhereInput>
    OR?: Enumerable<RopaWhereInput>
    NOT?: Enumerable<RopaWhereInput>
    id?: IntFilter | number
    vendedorId?: IntFilter | number
    nombre?: StringFilter | string
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    estado?: StringFilter | string
    cantidad?: IntFilter | number
    proveedorId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    proveedor?: XOR<ProveedorRelationFilter, ProveedorWhereInput>
    vendedor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    categorias?: CategoriaListRelationFilter
    fotos?: FotoListRelationFilter
    ordenes?: PedidoRopaListRelationFilter
    preguntas?: PreguntaListRelationFilter
  }

  export type RopaOrderByWithRelationInput = {
    id?: SortOrder
    vendedorId?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    cantidad?: SortOrder
    proveedorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proveedor?: ProveedorOrderByWithRelationInput
    vendedor?: UsuarioOrderByWithRelationInput
    categorias?: CategoriaOrderByRelationAggregateInput
    fotos?: FotoOrderByRelationAggregateInput
    ordenes?: PedidoRopaOrderByRelationAggregateInput
    preguntas?: PreguntaOrderByRelationAggregateInput
  }

  export type RopaWhereUniqueInput = {
    id?: number
  }

  export type RopaOrderByWithAggregationInput = {
    id?: SortOrder
    vendedorId?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    cantidad?: SortOrder
    proveedorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RopaCountOrderByAggregateInput
    _avg?: RopaAvgOrderByAggregateInput
    _max?: RopaMaxOrderByAggregateInput
    _min?: RopaMinOrderByAggregateInput
    _sum?: RopaSumOrderByAggregateInput
  }

  export type RopaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RopaScalarWhereWithAggregatesInput>
    OR?: Enumerable<RopaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RopaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    vendedorId?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    precio?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    estado?: StringWithAggregatesFilter | string
    cantidad?: IntWithAggregatesFilter | number
    proveedorId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PedidoRopaWhereInput = {
    AND?: Enumerable<PedidoRopaWhereInput>
    OR?: Enumerable<PedidoRopaWhereInput>
    NOT?: Enumerable<PedidoRopaWhereInput>
    id?: IntFilter | number
    idRopa?: IntFilter | number
    idPedido?: IntFilter | number
    cantidad?: IntFilter | number
    subtotal?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    ropa?: XOR<RopaRelationFilter, RopaWhereInput>
  }

  export type PedidoRopaOrderByWithRelationInput = {
    id?: SortOrder
    idRopa?: SortOrder
    idPedido?: SortOrder
    cantidad?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
    ropa?: RopaOrderByWithRelationInput
  }

  export type PedidoRopaWhereUniqueInput = {
    id?: number
  }

  export type PedidoRopaOrderByWithAggregationInput = {
    id?: SortOrder
    idRopa?: SortOrder
    idPedido?: SortOrder
    cantidad?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PedidoRopaCountOrderByAggregateInput
    _avg?: PedidoRopaAvgOrderByAggregateInput
    _max?: PedidoRopaMaxOrderByAggregateInput
    _min?: PedidoRopaMinOrderByAggregateInput
    _sum?: PedidoRopaSumOrderByAggregateInput
  }

  export type PedidoRopaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PedidoRopaScalarWhereWithAggregatesInput>
    OR?: Enumerable<PedidoRopaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PedidoRopaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idRopa?: IntWithAggregatesFilter | number
    idPedido?: IntWithAggregatesFilter | number
    cantidad?: IntWithAggregatesFilter | number
    subtotal?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PedidoWhereInput = {
    AND?: Enumerable<PedidoWhereInput>
    OR?: Enumerable<PedidoWhereInput>
    NOT?: Enumerable<PedidoWhereInput>
    id?: IntFilter | number
    fechaOrden?: DateTimeFilter | Date | string
    idPago?: IntFilter | number
    clienteId?: IntFilter | number
    direccionId?: IntFilter | number
    descuento?: DecimalFilter | Decimal | DecimalJsLike | number | string
    IV?: DecimalFilter | Decimal | DecimalJsLike | number | string
    estado?: StringFilter | string
    subtotal?: DecimalFilter | Decimal | DecimalJsLike | number | string
    Total?: DecimalFilter | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    ropas?: PedidoRopaListRelationFilter
    evaluaciones?: EvaluacionListRelationFilter
    direccion?: XOR<DireccionRelationFilter, DireccionWhereInput>
    metodo?: XOR<MetodoPagoRelationFilter, MetodoPagoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type PedidoOrderByWithRelationInput = {
    id?: SortOrder
    fechaOrden?: SortOrder
    idPago?: SortOrder
    clienteId?: SortOrder
    direccionId?: SortOrder
    descuento?: SortOrder
    IV?: SortOrder
    estado?: SortOrder
    subtotal?: SortOrder
    Total?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ropas?: PedidoRopaOrderByRelationAggregateInput
    evaluaciones?: EvaluacionOrderByRelationAggregateInput
    direccion?: DireccionOrderByWithRelationInput
    metodo?: MetodoPagoOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type PedidoWhereUniqueInput = {
    id?: number
  }

  export type PedidoOrderByWithAggregationInput = {
    id?: SortOrder
    fechaOrden?: SortOrder
    idPago?: SortOrder
    clienteId?: SortOrder
    direccionId?: SortOrder
    descuento?: SortOrder
    IV?: SortOrder
    estado?: SortOrder
    subtotal?: SortOrder
    Total?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fechaOrden?: DateTimeWithAggregatesFilter | Date | string
    idPago?: IntWithAggregatesFilter | number
    clienteId?: IntWithAggregatesFilter | number
    direccionId?: IntWithAggregatesFilter | number
    descuento?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    IV?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    estado?: StringWithAggregatesFilter | string
    subtotal?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    Total?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UsuarioWhereInput = {
    AND?: Enumerable<UsuarioWhereInput>
    OR?: Enumerable<UsuarioWhereInput>
    NOT?: Enumerable<UsuarioWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    cedula?: StringFilter | string
    telefono?: StringFilter | string
    correo?: StringFilter | string
    contrasenna?: StringFilter | string
    estado?: BoolFilter | boolean
    rol?: EnumRolFilter | Rol
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    metodos?: MetodoPagoListRelationFilter
    pedidos?: PedidoListRelationFilter
    direcciones?: DireccionListRelationFilter
    preguntas?: PreguntaListRelationFilter
    respuestas?: RespuestaListRelationFilter
    informes?: InformeListRelationFilter
    evaluaciones?: EvaluacionListRelationFilter
    ropas?: RopaListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    cedula?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metodos?: MetodoPagoOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
    direcciones?: DireccionOrderByRelationAggregateInput
    preguntas?: PreguntaOrderByRelationAggregateInput
    respuestas?: RespuestaOrderByRelationAggregateInput
    informes?: InformeOrderByRelationAggregateInput
    evaluaciones?: EvaluacionOrderByRelationAggregateInput
    ropas?: RopaOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = {
    id?: number
    correo?: string
  }

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    cedula?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    cedula?: StringWithAggregatesFilter | string
    telefono?: StringWithAggregatesFilter | string
    correo?: StringWithAggregatesFilter | string
    contrasenna?: StringWithAggregatesFilter | string
    estado?: BoolWithAggregatesFilter | boolean
    rol?: EnumRolWithAggregatesFilter | Rol
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MetodoPagoWhereInput = {
    AND?: Enumerable<MetodoPagoWhereInput>
    OR?: Enumerable<MetodoPagoWhereInput>
    NOT?: Enumerable<MetodoPagoWhereInput>
    id?: IntFilter | number
    idCliente?: IntFilter | number
    descripcion?: StringFilter | string
    proveedor?: StringFilter | string
    numeroCuenta?: StringFilter | string
    fechaExpiracion?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    pedidos?: PedidoListRelationFilter
  }

  export type MetodoPagoOrderByWithRelationInput = {
    id?: SortOrder
    idCliente?: SortOrder
    descripcion?: SortOrder
    proveedor?: SortOrder
    numeroCuenta?: SortOrder
    fechaExpiracion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    pedidos?: PedidoOrderByRelationAggregateInput
  }

  export type MetodoPagoWhereUniqueInput = {
    id?: number
  }

  export type MetodoPagoOrderByWithAggregationInput = {
    id?: SortOrder
    idCliente?: SortOrder
    descripcion?: SortOrder
    proveedor?: SortOrder
    numeroCuenta?: SortOrder
    fechaExpiracion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MetodoPagoCountOrderByAggregateInput
    _avg?: MetodoPagoAvgOrderByAggregateInput
    _max?: MetodoPagoMaxOrderByAggregateInput
    _min?: MetodoPagoMinOrderByAggregateInput
    _sum?: MetodoPagoSumOrderByAggregateInput
  }

  export type MetodoPagoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MetodoPagoScalarWhereWithAggregatesInput>
    OR?: Enumerable<MetodoPagoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MetodoPagoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idCliente?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    proveedor?: StringWithAggregatesFilter | string
    numeroCuenta?: StringWithAggregatesFilter | string
    fechaExpiracion?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PreguntaWhereInput = {
    AND?: Enumerable<PreguntaWhereInput>
    OR?: Enumerable<PreguntaWhereInput>
    NOT?: Enumerable<PreguntaWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    usuarioId?: IntFilter | number
    ropaId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    ropa?: XOR<RopaRelationFilter, RopaWhereInput>
    respuestas?: RespuestaListRelationFilter
  }

  export type PreguntaOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    ropaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    ropa?: RopaOrderByWithRelationInput
    respuestas?: RespuestaOrderByRelationAggregateInput
  }

  export type PreguntaWhereUniqueInput = {
    id?: number
  }

  export type PreguntaOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    ropaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PreguntaCountOrderByAggregateInput
    _avg?: PreguntaAvgOrderByAggregateInput
    _max?: PreguntaMaxOrderByAggregateInput
    _min?: PreguntaMinOrderByAggregateInput
    _sum?: PreguntaSumOrderByAggregateInput
  }

  export type PreguntaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PreguntaScalarWhereWithAggregatesInput>
    OR?: Enumerable<PreguntaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PreguntaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    usuarioId?: IntWithAggregatesFilter | number
    ropaId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RespuestaWhereInput = {
    AND?: Enumerable<RespuestaWhereInput>
    OR?: Enumerable<RespuestaWhereInput>
    NOT?: Enumerable<RespuestaWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    usuarioId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    preguntas?: PreguntaListRelationFilter
  }

  export type RespuestaOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    preguntas?: PreguntaOrderByRelationAggregateInput
  }

  export type RespuestaWhereUniqueInput = {
    id?: number
  }

  export type RespuestaOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RespuestaCountOrderByAggregateInput
    _avg?: RespuestaAvgOrderByAggregateInput
    _max?: RespuestaMaxOrderByAggregateInput
    _min?: RespuestaMinOrderByAggregateInput
    _sum?: RespuestaSumOrderByAggregateInput
  }

  export type RespuestaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RespuestaScalarWhereWithAggregatesInput>
    OR?: Enumerable<RespuestaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RespuestaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    usuarioId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InformeWhereInput = {
    AND?: Enumerable<InformeWhereInput>
    OR?: Enumerable<InformeWhereInput>
    NOT?: Enumerable<InformeWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    usuarioId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type InformeOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type InformeWhereUniqueInput = {
    id?: number
  }

  export type InformeOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InformeCountOrderByAggregateInput
    _avg?: InformeAvgOrderByAggregateInput
    _max?: InformeMaxOrderByAggregateInput
    _min?: InformeMinOrderByAggregateInput
    _sum?: InformeSumOrderByAggregateInput
  }

  export type InformeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InformeScalarWhereWithAggregatesInput>
    OR?: Enumerable<InformeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InformeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    usuarioId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EvaluacionWhereInput = {
    AND?: Enumerable<EvaluacionWhereInput>
    OR?: Enumerable<EvaluacionWhereInput>
    NOT?: Enumerable<EvaluacionWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    usuarioId?: IntFilter | number
    pedidoId?: IntFilter | number
    nota?: IntFilter | number
    descripcion?: StringNullableFilter | string | null
    usuarioRol?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
  }

  export type EvaluacionOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    usuarioId?: SortOrder
    pedidoId?: SortOrder
    nota?: SortOrder
    descripcion?: SortOrder
    usuarioRol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    pedido?: PedidoOrderByWithRelationInput
  }

  export type EvaluacionWhereUniqueInput = {
    id?: number
  }

  export type EvaluacionOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    usuarioId?: SortOrder
    pedidoId?: SortOrder
    nota?: SortOrder
    descripcion?: SortOrder
    usuarioRol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvaluacionCountOrderByAggregateInput
    _avg?: EvaluacionAvgOrderByAggregateInput
    _max?: EvaluacionMaxOrderByAggregateInput
    _min?: EvaluacionMinOrderByAggregateInput
    _sum?: EvaluacionSumOrderByAggregateInput
  }

  export type EvaluacionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EvaluacionScalarWhereWithAggregatesInput>
    OR?: Enumerable<EvaluacionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EvaluacionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    usuarioId?: IntWithAggregatesFilter | number
    pedidoId?: IntWithAggregatesFilter | number
    nota?: IntWithAggregatesFilter | number
    descripcion?: StringNullableWithAggregatesFilter | string | null
    usuarioRol?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CategoriaWhereInput = {
    AND?: Enumerable<CategoriaWhereInput>
    OR?: Enumerable<CategoriaWhereInput>
    NOT?: Enumerable<CategoriaWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    ropas?: RopaListRelationFilter
  }

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ropas?: RopaOrderByRelationAggregateInput
  }

  export type CategoriaWhereUniqueInput = {
    id?: number
  }

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _avg?: CategoriaAvgOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
    _sum?: CategoriaSumOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoriaScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoriaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoriaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DireccionWhereInput = {
    AND?: Enumerable<DireccionWhereInput>
    OR?: Enumerable<DireccionWhereInput>
    NOT?: Enumerable<DireccionWhereInput>
    id?: IntFilter | number
    usuarioId?: IntFilter | number
    provincia?: StringFilter | string
    canton?: StringFilter | string
    distrito?: StringFilter | string
    direccionExacta?: StringFilter | string
    codPostal?: StringFilter | string
    telef?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    pedidos?: PedidoListRelationFilter
  }

  export type DireccionOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    provincia?: SortOrder
    canton?: SortOrder
    distrito?: SortOrder
    direccionExacta?: SortOrder
    codPostal?: SortOrder
    telef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    pedidos?: PedidoOrderByRelationAggregateInput
  }

  export type DireccionWhereUniqueInput = {
    id?: number
  }

  export type DireccionOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    provincia?: SortOrder
    canton?: SortOrder
    distrito?: SortOrder
    direccionExacta?: SortOrder
    codPostal?: SortOrder
    telef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DireccionCountOrderByAggregateInput
    _avg?: DireccionAvgOrderByAggregateInput
    _max?: DireccionMaxOrderByAggregateInput
    _min?: DireccionMinOrderByAggregateInput
    _sum?: DireccionSumOrderByAggregateInput
  }

  export type DireccionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DireccionScalarWhereWithAggregatesInput>
    OR?: Enumerable<DireccionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DireccionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    usuarioId?: IntWithAggregatesFilter | number
    provincia?: StringWithAggregatesFilter | string
    canton?: StringWithAggregatesFilter | string
    distrito?: StringWithAggregatesFilter | string
    direccionExacta?: StringWithAggregatesFilter | string
    codPostal?: StringWithAggregatesFilter | string
    telef?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FotoWhereInput = {
    AND?: Enumerable<FotoWhereInput>
    OR?: Enumerable<FotoWhereInput>
    NOT?: Enumerable<FotoWhereInput>
    id?: IntFilter | number
    ropaId?: IntFilter | number
    foto?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    ropa?: XOR<RopaRelationFilter, RopaWhereInput>
  }

  export type FotoOrderByWithRelationInput = {
    id?: SortOrder
    ropaId?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ropa?: RopaOrderByWithRelationInput
  }

  export type FotoWhereUniqueInput = {
    id?: number
  }

  export type FotoOrderByWithAggregationInput = {
    id?: SortOrder
    ropaId?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FotoCountOrderByAggregateInput
    _avg?: FotoAvgOrderByAggregateInput
    _max?: FotoMaxOrderByAggregateInput
    _min?: FotoMinOrderByAggregateInput
    _sum?: FotoSumOrderByAggregateInput
  }

  export type FotoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FotoScalarWhereWithAggregatesInput>
    OR?: Enumerable<FotoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FotoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ropaId?: IntWithAggregatesFilter | number
    foto?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProveedorCreateInput = {
    nombre: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: RopaCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUncheckedCreateInput = {
    id?: number
    nombre: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: RopaUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: RopaUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: RopaUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorCreateManyInput = {
    id?: number
    nombre: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProveedorUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProveedorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RopaCreateInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proveedor: ProveedorCreateNestedOneWithoutRopasInput
    vendedor: UsuarioCreateNestedOneWithoutRopasInput
    categorias?: CategoriaCreateNestedManyWithoutRopasInput
    fotos?: FotoCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaCreateNestedManyWithoutRopaInput
  }

  export type RopaUncheckedCreateInput = {
    id?: number
    vendedorId: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    proveedorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categorias?: CategoriaUncheckedCreateNestedManyWithoutRopasInput
    fotos?: FotoUncheckedCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaUncheckedCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutRopaInput
  }

  export type RopaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proveedor?: ProveedorUpdateOneRequiredWithoutRopasNestedInput
    vendedor?: UsuarioUpdateOneRequiredWithoutRopasNestedInput
    categorias?: CategoriaUpdateManyWithoutRopasNestedInput
    fotos?: FotoUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUpdateManyWithoutRopaNestedInput
  }

  export type RopaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendedorId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    proveedorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CategoriaUncheckedUpdateManyWithoutRopasNestedInput
    fotos?: FotoUncheckedUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUncheckedUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutRopaNestedInput
  }

  export type RopaCreateManyInput = {
    id?: number
    vendedorId: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    proveedorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RopaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RopaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendedorId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    proveedorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoRopaCreateInput = {
    cantidad: number
    subtotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutRopasInput
    ropa: RopaCreateNestedOneWithoutOrdenesInput
  }

  export type PedidoRopaUncheckedCreateInput = {
    id?: number
    idRopa: number
    idPedido: number
    cantidad: number
    subtotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoRopaUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutRopasNestedInput
    ropa?: RopaUpdateOneRequiredWithoutOrdenesNestedInput
  }

  export type PedidoRopaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRopa?: IntFieldUpdateOperationsInput | number
    idPedido?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoRopaCreateManyInput = {
    id?: number
    idRopa: number
    idPedido: number
    cantidad: number
    subtotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoRopaUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoRopaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRopa?: IntFieldUpdateOperationsInput | number
    idPedido?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateInput = {
    fechaOrden?: Date | string
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaCreateNestedManyWithoutPedidoInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutPedidoInput
    direccion: DireccionCreateNestedOneWithoutPedidosInput
    metodo: MetodoPagoCreateNestedOneWithoutPedidosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateInput = {
    id?: number
    fechaOrden?: Date | string
    idPago: number
    clienteId: number
    direccionId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaUncheckedCreateNestedManyWithoutPedidoInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUpdateInput = {
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUpdateManyWithoutPedidoNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutPedidoNestedInput
    direccion?: DireccionUpdateOneRequiredWithoutPedidosNestedInput
    metodo?: MetodoPagoUpdateOneRequiredWithoutPedidosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    idPago?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    direccionId?: IntFieldUpdateOperationsInput | number
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUncheckedUpdateManyWithoutPedidoNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoCreateManyInput = {
    id?: number
    fechaOrden?: Date | string
    idPago: number
    clienteId: number
    direccionId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateManyMutationInput = {
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    idPago?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    direccionId?: IntFieldUpdateOperationsInput | number
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioCreateInput = {
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaCreateNestedManyWithoutUsuarioInput
    informes?: InformeCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutUsuarioInput
    ropas?: RopaCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutUsuarioInput
    informes?: InformeUncheckedCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutUsuarioInput
    ropas?: RopaUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUncheckedUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUncheckedUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetodoPagoCreateInput = {
    descripcion: string
    proveedor: string
    numeroCuenta: string
    fechaExpiracion: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutMetodosInput
    pedidos?: PedidoCreateNestedManyWithoutMetodoInput
  }

  export type MetodoPagoUncheckedCreateInput = {
    id?: number
    idCliente: number
    descripcion: string
    proveedor: string
    numeroCuenta: string
    fechaExpiracion: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutMetodoInput
  }

  export type MetodoPagoUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    numeroCuenta?: StringFieldUpdateOperationsInput | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutMetodosNestedInput
    pedidos?: PedidoUpdateManyWithoutMetodoNestedInput
  }

  export type MetodoPagoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCliente?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    numeroCuenta?: StringFieldUpdateOperationsInput | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUncheckedUpdateManyWithoutMetodoNestedInput
  }

  export type MetodoPagoCreateManyInput = {
    id?: number
    idCliente: number
    descripcion: string
    proveedor: string
    numeroCuenta: string
    fechaExpiracion: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetodoPagoUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    numeroCuenta?: StringFieldUpdateOperationsInput | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetodoPagoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCliente?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    numeroCuenta?: StringFieldUpdateOperationsInput | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreguntaCreateInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutPreguntasInput
    ropa: RopaCreateNestedOneWithoutPreguntasInput
    respuestas?: RespuestaCreateNestedManyWithoutPreguntasInput
  }

  export type PreguntaUncheckedCreateInput = {
    id?: number
    descripcion: string
    usuarioId: number
    ropaId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type PreguntaUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutPreguntasNestedInput
    ropa?: RopaUpdateOneRequiredWithoutPreguntasNestedInput
    respuestas?: RespuestaUpdateManyWithoutPreguntasNestedInput
  }

  export type PreguntaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    ropaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respuestas?: RespuestaUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type PreguntaCreateManyInput = {
    id?: number
    descripcion: string
    usuarioId: number
    ropaId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreguntaUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreguntaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    ropaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RespuestaCreateInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutRespuestasInput
    preguntas?: PreguntaCreateNestedManyWithoutRespuestasInput
  }

  export type RespuestaUncheckedCreateInput = {
    id?: number
    descripcion: string
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutRespuestasInput
  }

  export type RespuestaUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutRespuestasNestedInput
    preguntas?: PreguntaUpdateManyWithoutRespuestasNestedInput
  }

  export type RespuestaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: PreguntaUncheckedUpdateManyWithoutRespuestasNestedInput
  }

  export type RespuestaCreateManyInput = {
    id?: number
    descripcion: string
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RespuestaUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RespuestaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InformeCreateInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutInformesInput
  }

  export type InformeUncheckedCreateInput = {
    id?: number
    descripcion: string
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InformeUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutInformesNestedInput
  }

  export type InformeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InformeCreateManyInput = {
    id?: number
    descripcion: string
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InformeUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InformeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluacionCreateInput = {
    nombre: string
    nota: number
    descripcion?: string | null
    usuarioRol: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEvaluacionesInput
    pedido: PedidoCreateNestedOneWithoutEvaluacionesInput
  }

  export type EvaluacionUncheckedCreateInput = {
    id?: number
    nombre: string
    usuarioId: number
    pedidoId: number
    nota: number
    descripcion?: string | null
    usuarioRol: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluacionUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioRol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEvaluacionesNestedInput
    pedido?: PedidoUpdateOneRequiredWithoutEvaluacionesNestedInput
  }

  export type EvaluacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    nota?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioRol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluacionCreateManyInput = {
    id?: number
    nombre: string
    usuarioId: number
    pedidoId: number
    nota: number
    descripcion?: string | null
    usuarioRol: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluacionUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioRol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    nota?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioRol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaCreateInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: RopaCreateNestedManyWithoutCategoriasInput
  }

  export type CategoriaUncheckedCreateInput = {
    id?: number
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: RopaUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type CategoriaUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: RopaUpdateManyWithoutCategoriasNestedInput
  }

  export type CategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: RopaUncheckedUpdateManyWithoutCategoriasNestedInput
  }

  export type CategoriaCreateManyInput = {
    id?: number
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoriaUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DireccionCreateInput = {
    provincia: string
    canton: string
    distrito: string
    direccionExacta: string
    codPostal: string
    telef: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutDireccionesInput
    pedidos?: PedidoCreateNestedManyWithoutDireccionInput
  }

  export type DireccionUncheckedCreateInput = {
    id?: number
    usuarioId: number
    provincia: string
    canton: string
    distrito: string
    direccionExacta: string
    codPostal: string
    telef: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutDireccionInput
  }

  export type DireccionUpdateInput = {
    provincia?: StringFieldUpdateOperationsInput | string
    canton?: StringFieldUpdateOperationsInput | string
    distrito?: StringFieldUpdateOperationsInput | string
    direccionExacta?: StringFieldUpdateOperationsInput | string
    codPostal?: StringFieldUpdateOperationsInput | string
    telef?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutDireccionesNestedInput
    pedidos?: PedidoUpdateManyWithoutDireccionNestedInput
  }

  export type DireccionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    provincia?: StringFieldUpdateOperationsInput | string
    canton?: StringFieldUpdateOperationsInput | string
    distrito?: StringFieldUpdateOperationsInput | string
    direccionExacta?: StringFieldUpdateOperationsInput | string
    codPostal?: StringFieldUpdateOperationsInput | string
    telef?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUncheckedUpdateManyWithoutDireccionNestedInput
  }

  export type DireccionCreateManyInput = {
    id?: number
    usuarioId: number
    provincia: string
    canton: string
    distrito: string
    direccionExacta: string
    codPostal: string
    telef: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DireccionUpdateManyMutationInput = {
    provincia?: StringFieldUpdateOperationsInput | string
    canton?: StringFieldUpdateOperationsInput | string
    distrito?: StringFieldUpdateOperationsInput | string
    direccionExacta?: StringFieldUpdateOperationsInput | string
    codPostal?: StringFieldUpdateOperationsInput | string
    telef?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DireccionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    provincia?: StringFieldUpdateOperationsInput | string
    canton?: StringFieldUpdateOperationsInput | string
    distrito?: StringFieldUpdateOperationsInput | string
    direccionExacta?: StringFieldUpdateOperationsInput | string
    codPostal?: StringFieldUpdateOperationsInput | string
    telef?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FotoCreateInput = {
    foto: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropa: RopaCreateNestedOneWithoutFotosInput
  }

  export type FotoUncheckedCreateInput = {
    id?: number
    ropaId: number
    foto: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FotoUpdateInput = {
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropa?: RopaUpdateOneRequiredWithoutFotosNestedInput
  }

  export type FotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ropaId?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FotoCreateManyInput = {
    id?: number
    ropaId: number
    foto: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FotoUpdateManyMutationInput = {
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ropaId?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type RopaListRelationFilter = {
    every?: RopaWhereInput
    some?: RopaWhereInput
    none?: RopaWhereInput
  }

  export type RopaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProveedorCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProveedorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProveedorMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProveedorMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProveedorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type ProveedorRelationFilter = {
    is?: ProveedorWhereInput
    isNot?: ProveedorWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type CategoriaListRelationFilter = {
    every?: CategoriaWhereInput
    some?: CategoriaWhereInput
    none?: CategoriaWhereInput
  }

  export type FotoListRelationFilter = {
    every?: FotoWhereInput
    some?: FotoWhereInput
    none?: FotoWhereInput
  }

  export type PedidoRopaListRelationFilter = {
    every?: PedidoRopaWhereInput
    some?: PedidoRopaWhereInput
    none?: PedidoRopaWhereInput
  }

  export type PreguntaListRelationFilter = {
    every?: PreguntaWhereInput
    some?: PreguntaWhereInput
    none?: PreguntaWhereInput
  }

  export type CategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoRopaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PreguntaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RopaCountOrderByAggregateInput = {
    id?: SortOrder
    vendedorId?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    cantidad?: SortOrder
    proveedorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RopaAvgOrderByAggregateInput = {
    id?: SortOrder
    vendedorId?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    proveedorId?: SortOrder
  }

  export type RopaMaxOrderByAggregateInput = {
    id?: SortOrder
    vendedorId?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    cantidad?: SortOrder
    proveedorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RopaMinOrderByAggregateInput = {
    id?: SortOrder
    vendedorId?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    cantidad?: SortOrder
    proveedorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RopaSumOrderByAggregateInput = {
    id?: SortOrder
    vendedorId?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    proveedorId?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type PedidoRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type RopaRelationFilter = {
    is?: RopaWhereInput
    isNot?: RopaWhereInput
  }

  export type PedidoRopaCountOrderByAggregateInput = {
    id?: SortOrder
    idRopa?: SortOrder
    idPedido?: SortOrder
    cantidad?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoRopaAvgOrderByAggregateInput = {
    id?: SortOrder
    idRopa?: SortOrder
    idPedido?: SortOrder
    cantidad?: SortOrder
    subtotal?: SortOrder
  }

  export type PedidoRopaMaxOrderByAggregateInput = {
    id?: SortOrder
    idRopa?: SortOrder
    idPedido?: SortOrder
    cantidad?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoRopaMinOrderByAggregateInput = {
    id?: SortOrder
    idRopa?: SortOrder
    idPedido?: SortOrder
    cantidad?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoRopaSumOrderByAggregateInput = {
    id?: SortOrder
    idRopa?: SortOrder
    idPedido?: SortOrder
    cantidad?: SortOrder
    subtotal?: SortOrder
  }

  export type EvaluacionListRelationFilter = {
    every?: EvaluacionWhereInput
    some?: EvaluacionWhereInput
    none?: EvaluacionWhereInput
  }

  export type DireccionRelationFilter = {
    is?: DireccionWhereInput
    isNot?: DireccionWhereInput
  }

  export type MetodoPagoRelationFilter = {
    is?: MetodoPagoWhereInput
    isNot?: MetodoPagoWhereInput
  }

  export type EvaluacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoCountOrderByAggregateInput = {
    id?: SortOrder
    fechaOrden?: SortOrder
    idPago?: SortOrder
    clienteId?: SortOrder
    direccionId?: SortOrder
    descuento?: SortOrder
    IV?: SortOrder
    estado?: SortOrder
    subtotal?: SortOrder
    Total?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    idPago?: SortOrder
    clienteId?: SortOrder
    direccionId?: SortOrder
    descuento?: SortOrder
    IV?: SortOrder
    subtotal?: SortOrder
    Total?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    fechaOrden?: SortOrder
    idPago?: SortOrder
    clienteId?: SortOrder
    direccionId?: SortOrder
    descuento?: SortOrder
    IV?: SortOrder
    estado?: SortOrder
    subtotal?: SortOrder
    Total?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    id?: SortOrder
    fechaOrden?: SortOrder
    idPago?: SortOrder
    clienteId?: SortOrder
    direccionId?: SortOrder
    descuento?: SortOrder
    IV?: SortOrder
    estado?: SortOrder
    subtotal?: SortOrder
    Total?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    id?: SortOrder
    idPago?: SortOrder
    clienteId?: SortOrder
    direccionId?: SortOrder
    descuento?: SortOrder
    IV?: SortOrder
    subtotal?: SortOrder
    Total?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EnumRolFilter = {
    equals?: Rol
    in?: Enumerable<Rol>
    notIn?: Enumerable<Rol>
    not?: NestedEnumRolFilter | Rol
  }

  export type MetodoPagoListRelationFilter = {
    every?: MetodoPagoWhereInput
    some?: MetodoPagoWhereInput
    none?: MetodoPagoWhereInput
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type DireccionListRelationFilter = {
    every?: DireccionWhereInput
    some?: DireccionWhereInput
    none?: DireccionWhereInput
  }

  export type RespuestaListRelationFilter = {
    every?: RespuestaWhereInput
    some?: RespuestaWhereInput
    none?: RespuestaWhereInput
  }

  export type InformeListRelationFilter = {
    every?: InformeWhereInput
    some?: InformeWhereInput
    none?: InformeWhereInput
  }

  export type MetodoPagoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DireccionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RespuestaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InformeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    cedula?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    cedula?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    cedula?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumRolWithAggregatesFilter = {
    equals?: Rol
    in?: Enumerable<Rol>
    notIn?: Enumerable<Rol>
    not?: NestedEnumRolWithAggregatesFilter | Rol
    _count?: NestedIntFilter
    _min?: NestedEnumRolFilter
    _max?: NestedEnumRolFilter
  }

  export type MetodoPagoCountOrderByAggregateInput = {
    id?: SortOrder
    idCliente?: SortOrder
    descripcion?: SortOrder
    proveedor?: SortOrder
    numeroCuenta?: SortOrder
    fechaExpiracion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetodoPagoAvgOrderByAggregateInput = {
    id?: SortOrder
    idCliente?: SortOrder
  }

  export type MetodoPagoMaxOrderByAggregateInput = {
    id?: SortOrder
    idCliente?: SortOrder
    descripcion?: SortOrder
    proveedor?: SortOrder
    numeroCuenta?: SortOrder
    fechaExpiracion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetodoPagoMinOrderByAggregateInput = {
    id?: SortOrder
    idCliente?: SortOrder
    descripcion?: SortOrder
    proveedor?: SortOrder
    numeroCuenta?: SortOrder
    fechaExpiracion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetodoPagoSumOrderByAggregateInput = {
    id?: SortOrder
    idCliente?: SortOrder
  }

  export type PreguntaCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    ropaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreguntaAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    ropaId?: SortOrder
  }

  export type PreguntaMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    ropaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreguntaMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    ropaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreguntaSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    ropaId?: SortOrder
  }

  export type RespuestaCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RespuestaAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type RespuestaMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RespuestaMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RespuestaSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type InformeCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InformeAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type InformeMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InformeMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InformeSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type EvaluacionCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    usuarioId?: SortOrder
    pedidoId?: SortOrder
    nota?: SortOrder
    descripcion?: SortOrder
    usuarioRol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluacionAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    pedidoId?: SortOrder
    nota?: SortOrder
  }

  export type EvaluacionMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    usuarioId?: SortOrder
    pedidoId?: SortOrder
    nota?: SortOrder
    descripcion?: SortOrder
    usuarioRol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluacionMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    usuarioId?: SortOrder
    pedidoId?: SortOrder
    nota?: SortOrder
    descripcion?: SortOrder
    usuarioRol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluacionSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    pedidoId?: SortOrder
    nota?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DireccionCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    provincia?: SortOrder
    canton?: SortOrder
    distrito?: SortOrder
    direccionExacta?: SortOrder
    codPostal?: SortOrder
    telef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DireccionAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type DireccionMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    provincia?: SortOrder
    canton?: SortOrder
    distrito?: SortOrder
    direccionExacta?: SortOrder
    codPostal?: SortOrder
    telef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DireccionMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    provincia?: SortOrder
    canton?: SortOrder
    distrito?: SortOrder
    direccionExacta?: SortOrder
    codPostal?: SortOrder
    telef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DireccionSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type FotoCountOrderByAggregateInput = {
    id?: SortOrder
    ropaId?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FotoAvgOrderByAggregateInput = {
    id?: SortOrder
    ropaId?: SortOrder
  }

  export type FotoMaxOrderByAggregateInput = {
    id?: SortOrder
    ropaId?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FotoMinOrderByAggregateInput = {
    id?: SortOrder
    ropaId?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FotoSumOrderByAggregateInput = {
    id?: SortOrder
    ropaId?: SortOrder
  }

  export type RopaCreateNestedManyWithoutProveedorInput = {
    create?: XOR<Enumerable<RopaCreateWithoutProveedorInput>, Enumerable<RopaUncheckedCreateWithoutProveedorInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutProveedorInput>
    createMany?: RopaCreateManyProveedorInputEnvelope
    connect?: Enumerable<RopaWhereUniqueInput>
  }

  export type RopaUncheckedCreateNestedManyWithoutProveedorInput = {
    create?: XOR<Enumerable<RopaCreateWithoutProveedorInput>, Enumerable<RopaUncheckedCreateWithoutProveedorInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutProveedorInput>
    createMany?: RopaCreateManyProveedorInputEnvelope
    connect?: Enumerable<RopaWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RopaUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<Enumerable<RopaCreateWithoutProveedorInput>, Enumerable<RopaUncheckedCreateWithoutProveedorInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutProveedorInput>
    upsert?: Enumerable<RopaUpsertWithWhereUniqueWithoutProveedorInput>
    createMany?: RopaCreateManyProveedorInputEnvelope
    set?: Enumerable<RopaWhereUniqueInput>
    disconnect?: Enumerable<RopaWhereUniqueInput>
    delete?: Enumerable<RopaWhereUniqueInput>
    connect?: Enumerable<RopaWhereUniqueInput>
    update?: Enumerable<RopaUpdateWithWhereUniqueWithoutProveedorInput>
    updateMany?: Enumerable<RopaUpdateManyWithWhereWithoutProveedorInput>
    deleteMany?: Enumerable<RopaScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RopaUncheckedUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<Enumerable<RopaCreateWithoutProveedorInput>, Enumerable<RopaUncheckedCreateWithoutProveedorInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutProveedorInput>
    upsert?: Enumerable<RopaUpsertWithWhereUniqueWithoutProveedorInput>
    createMany?: RopaCreateManyProveedorInputEnvelope
    set?: Enumerable<RopaWhereUniqueInput>
    disconnect?: Enumerable<RopaWhereUniqueInput>
    delete?: Enumerable<RopaWhereUniqueInput>
    connect?: Enumerable<RopaWhereUniqueInput>
    update?: Enumerable<RopaUpdateWithWhereUniqueWithoutProveedorInput>
    updateMany?: Enumerable<RopaUpdateManyWithWhereWithoutProveedorInput>
    deleteMany?: Enumerable<RopaScalarWhereInput>
  }

  export type ProveedorCreateNestedOneWithoutRopasInput = {
    create?: XOR<ProveedorCreateWithoutRopasInput, ProveedorUncheckedCreateWithoutRopasInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutRopasInput
    connect?: ProveedorWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutRopasInput = {
    create?: XOR<UsuarioCreateWithoutRopasInput, UsuarioUncheckedCreateWithoutRopasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRopasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CategoriaCreateNestedManyWithoutRopasInput = {
    create?: XOR<Enumerable<CategoriaCreateWithoutRopasInput>, Enumerable<CategoriaUncheckedCreateWithoutRopasInput>>
    connectOrCreate?: Enumerable<CategoriaCreateOrConnectWithoutRopasInput>
    connect?: Enumerable<CategoriaWhereUniqueInput>
  }

  export type FotoCreateNestedManyWithoutRopaInput = {
    create?: XOR<Enumerable<FotoCreateWithoutRopaInput>, Enumerable<FotoUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<FotoCreateOrConnectWithoutRopaInput>
    createMany?: FotoCreateManyRopaInputEnvelope
    connect?: Enumerable<FotoWhereUniqueInput>
  }

  export type PedidoRopaCreateNestedManyWithoutRopaInput = {
    create?: XOR<Enumerable<PedidoRopaCreateWithoutRopaInput>, Enumerable<PedidoRopaUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<PedidoRopaCreateOrConnectWithoutRopaInput>
    createMany?: PedidoRopaCreateManyRopaInputEnvelope
    connect?: Enumerable<PedidoRopaWhereUniqueInput>
  }

  export type PreguntaCreateNestedManyWithoutRopaInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutRopaInput>, Enumerable<PreguntaUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutRopaInput>
    createMany?: PreguntaCreateManyRopaInputEnvelope
    connect?: Enumerable<PreguntaWhereUniqueInput>
  }

  export type CategoriaUncheckedCreateNestedManyWithoutRopasInput = {
    create?: XOR<Enumerable<CategoriaCreateWithoutRopasInput>, Enumerable<CategoriaUncheckedCreateWithoutRopasInput>>
    connectOrCreate?: Enumerable<CategoriaCreateOrConnectWithoutRopasInput>
    connect?: Enumerable<CategoriaWhereUniqueInput>
  }

  export type FotoUncheckedCreateNestedManyWithoutRopaInput = {
    create?: XOR<Enumerable<FotoCreateWithoutRopaInput>, Enumerable<FotoUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<FotoCreateOrConnectWithoutRopaInput>
    createMany?: FotoCreateManyRopaInputEnvelope
    connect?: Enumerable<FotoWhereUniqueInput>
  }

  export type PedidoRopaUncheckedCreateNestedManyWithoutRopaInput = {
    create?: XOR<Enumerable<PedidoRopaCreateWithoutRopaInput>, Enumerable<PedidoRopaUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<PedidoRopaCreateOrConnectWithoutRopaInput>
    createMany?: PedidoRopaCreateManyRopaInputEnvelope
    connect?: Enumerable<PedidoRopaWhereUniqueInput>
  }

  export type PreguntaUncheckedCreateNestedManyWithoutRopaInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutRopaInput>, Enumerable<PreguntaUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutRopaInput>
    createMany?: PreguntaCreateManyRopaInputEnvelope
    connect?: Enumerable<PreguntaWhereUniqueInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProveedorUpdateOneRequiredWithoutRopasNestedInput = {
    create?: XOR<ProveedorCreateWithoutRopasInput, ProveedorUncheckedCreateWithoutRopasInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutRopasInput
    upsert?: ProveedorUpsertWithoutRopasInput
    connect?: ProveedorWhereUniqueInput
    update?: XOR<ProveedorUpdateWithoutRopasInput, ProveedorUncheckedUpdateWithoutRopasInput>
  }

  export type UsuarioUpdateOneRequiredWithoutRopasNestedInput = {
    create?: XOR<UsuarioCreateWithoutRopasInput, UsuarioUncheckedCreateWithoutRopasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRopasInput
    upsert?: UsuarioUpsertWithoutRopasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutRopasInput, UsuarioUncheckedUpdateWithoutRopasInput>
  }

  export type CategoriaUpdateManyWithoutRopasNestedInput = {
    create?: XOR<Enumerable<CategoriaCreateWithoutRopasInput>, Enumerable<CategoriaUncheckedCreateWithoutRopasInput>>
    connectOrCreate?: Enumerable<CategoriaCreateOrConnectWithoutRopasInput>
    upsert?: Enumerable<CategoriaUpsertWithWhereUniqueWithoutRopasInput>
    set?: Enumerable<CategoriaWhereUniqueInput>
    disconnect?: Enumerable<CategoriaWhereUniqueInput>
    delete?: Enumerable<CategoriaWhereUniqueInput>
    connect?: Enumerable<CategoriaWhereUniqueInput>
    update?: Enumerable<CategoriaUpdateWithWhereUniqueWithoutRopasInput>
    updateMany?: Enumerable<CategoriaUpdateManyWithWhereWithoutRopasInput>
    deleteMany?: Enumerable<CategoriaScalarWhereInput>
  }

  export type FotoUpdateManyWithoutRopaNestedInput = {
    create?: XOR<Enumerable<FotoCreateWithoutRopaInput>, Enumerable<FotoUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<FotoCreateOrConnectWithoutRopaInput>
    upsert?: Enumerable<FotoUpsertWithWhereUniqueWithoutRopaInput>
    createMany?: FotoCreateManyRopaInputEnvelope
    set?: Enumerable<FotoWhereUniqueInput>
    disconnect?: Enumerable<FotoWhereUniqueInput>
    delete?: Enumerable<FotoWhereUniqueInput>
    connect?: Enumerable<FotoWhereUniqueInput>
    update?: Enumerable<FotoUpdateWithWhereUniqueWithoutRopaInput>
    updateMany?: Enumerable<FotoUpdateManyWithWhereWithoutRopaInput>
    deleteMany?: Enumerable<FotoScalarWhereInput>
  }

  export type PedidoRopaUpdateManyWithoutRopaNestedInput = {
    create?: XOR<Enumerable<PedidoRopaCreateWithoutRopaInput>, Enumerable<PedidoRopaUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<PedidoRopaCreateOrConnectWithoutRopaInput>
    upsert?: Enumerable<PedidoRopaUpsertWithWhereUniqueWithoutRopaInput>
    createMany?: PedidoRopaCreateManyRopaInputEnvelope
    set?: Enumerable<PedidoRopaWhereUniqueInput>
    disconnect?: Enumerable<PedidoRopaWhereUniqueInput>
    delete?: Enumerable<PedidoRopaWhereUniqueInput>
    connect?: Enumerable<PedidoRopaWhereUniqueInput>
    update?: Enumerable<PedidoRopaUpdateWithWhereUniqueWithoutRopaInput>
    updateMany?: Enumerable<PedidoRopaUpdateManyWithWhereWithoutRopaInput>
    deleteMany?: Enumerable<PedidoRopaScalarWhereInput>
  }

  export type PreguntaUpdateManyWithoutRopaNestedInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutRopaInput>, Enumerable<PreguntaUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutRopaInput>
    upsert?: Enumerable<PreguntaUpsertWithWhereUniqueWithoutRopaInput>
    createMany?: PreguntaCreateManyRopaInputEnvelope
    set?: Enumerable<PreguntaWhereUniqueInput>
    disconnect?: Enumerable<PreguntaWhereUniqueInput>
    delete?: Enumerable<PreguntaWhereUniqueInput>
    connect?: Enumerable<PreguntaWhereUniqueInput>
    update?: Enumerable<PreguntaUpdateWithWhereUniqueWithoutRopaInput>
    updateMany?: Enumerable<PreguntaUpdateManyWithWhereWithoutRopaInput>
    deleteMany?: Enumerable<PreguntaScalarWhereInput>
  }

  export type CategoriaUncheckedUpdateManyWithoutRopasNestedInput = {
    create?: XOR<Enumerable<CategoriaCreateWithoutRopasInput>, Enumerable<CategoriaUncheckedCreateWithoutRopasInput>>
    connectOrCreate?: Enumerable<CategoriaCreateOrConnectWithoutRopasInput>
    upsert?: Enumerable<CategoriaUpsertWithWhereUniqueWithoutRopasInput>
    set?: Enumerable<CategoriaWhereUniqueInput>
    disconnect?: Enumerable<CategoriaWhereUniqueInput>
    delete?: Enumerable<CategoriaWhereUniqueInput>
    connect?: Enumerable<CategoriaWhereUniqueInput>
    update?: Enumerable<CategoriaUpdateWithWhereUniqueWithoutRopasInput>
    updateMany?: Enumerable<CategoriaUpdateManyWithWhereWithoutRopasInput>
    deleteMany?: Enumerable<CategoriaScalarWhereInput>
  }

  export type FotoUncheckedUpdateManyWithoutRopaNestedInput = {
    create?: XOR<Enumerable<FotoCreateWithoutRopaInput>, Enumerable<FotoUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<FotoCreateOrConnectWithoutRopaInput>
    upsert?: Enumerable<FotoUpsertWithWhereUniqueWithoutRopaInput>
    createMany?: FotoCreateManyRopaInputEnvelope
    set?: Enumerable<FotoWhereUniqueInput>
    disconnect?: Enumerable<FotoWhereUniqueInput>
    delete?: Enumerable<FotoWhereUniqueInput>
    connect?: Enumerable<FotoWhereUniqueInput>
    update?: Enumerable<FotoUpdateWithWhereUniqueWithoutRopaInput>
    updateMany?: Enumerable<FotoUpdateManyWithWhereWithoutRopaInput>
    deleteMany?: Enumerable<FotoScalarWhereInput>
  }

  export type PedidoRopaUncheckedUpdateManyWithoutRopaNestedInput = {
    create?: XOR<Enumerable<PedidoRopaCreateWithoutRopaInput>, Enumerable<PedidoRopaUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<PedidoRopaCreateOrConnectWithoutRopaInput>
    upsert?: Enumerable<PedidoRopaUpsertWithWhereUniqueWithoutRopaInput>
    createMany?: PedidoRopaCreateManyRopaInputEnvelope
    set?: Enumerable<PedidoRopaWhereUniqueInput>
    disconnect?: Enumerable<PedidoRopaWhereUniqueInput>
    delete?: Enumerable<PedidoRopaWhereUniqueInput>
    connect?: Enumerable<PedidoRopaWhereUniqueInput>
    update?: Enumerable<PedidoRopaUpdateWithWhereUniqueWithoutRopaInput>
    updateMany?: Enumerable<PedidoRopaUpdateManyWithWhereWithoutRopaInput>
    deleteMany?: Enumerable<PedidoRopaScalarWhereInput>
  }

  export type PreguntaUncheckedUpdateManyWithoutRopaNestedInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutRopaInput>, Enumerable<PreguntaUncheckedCreateWithoutRopaInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutRopaInput>
    upsert?: Enumerable<PreguntaUpsertWithWhereUniqueWithoutRopaInput>
    createMany?: PreguntaCreateManyRopaInputEnvelope
    set?: Enumerable<PreguntaWhereUniqueInput>
    disconnect?: Enumerable<PreguntaWhereUniqueInput>
    delete?: Enumerable<PreguntaWhereUniqueInput>
    connect?: Enumerable<PreguntaWhereUniqueInput>
    update?: Enumerable<PreguntaUpdateWithWhereUniqueWithoutRopaInput>
    updateMany?: Enumerable<PreguntaUpdateManyWithWhereWithoutRopaInput>
    deleteMany?: Enumerable<PreguntaScalarWhereInput>
  }

  export type PedidoCreateNestedOneWithoutRopasInput = {
    create?: XOR<PedidoCreateWithoutRopasInput, PedidoUncheckedCreateWithoutRopasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutRopasInput
    connect?: PedidoWhereUniqueInput
  }

  export type RopaCreateNestedOneWithoutOrdenesInput = {
    create?: XOR<RopaCreateWithoutOrdenesInput, RopaUncheckedCreateWithoutOrdenesInput>
    connectOrCreate?: RopaCreateOrConnectWithoutOrdenesInput
    connect?: RopaWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutRopasNestedInput = {
    create?: XOR<PedidoCreateWithoutRopasInput, PedidoUncheckedCreateWithoutRopasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutRopasInput
    upsert?: PedidoUpsertWithoutRopasInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<PedidoUpdateWithoutRopasInput, PedidoUncheckedUpdateWithoutRopasInput>
  }

  export type RopaUpdateOneRequiredWithoutOrdenesNestedInput = {
    create?: XOR<RopaCreateWithoutOrdenesInput, RopaUncheckedCreateWithoutOrdenesInput>
    connectOrCreate?: RopaCreateOrConnectWithoutOrdenesInput
    upsert?: RopaUpsertWithoutOrdenesInput
    connect?: RopaWhereUniqueInput
    update?: XOR<RopaUpdateWithoutOrdenesInput, RopaUncheckedUpdateWithoutOrdenesInput>
  }

  export type PedidoRopaCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<PedidoRopaCreateWithoutPedidoInput>, Enumerable<PedidoRopaUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<PedidoRopaCreateOrConnectWithoutPedidoInput>
    createMany?: PedidoRopaCreateManyPedidoInputEnvelope
    connect?: Enumerable<PedidoRopaWhereUniqueInput>
  }

  export type EvaluacionCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<EvaluacionCreateWithoutPedidoInput>, Enumerable<EvaluacionUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<EvaluacionCreateOrConnectWithoutPedidoInput>
    createMany?: EvaluacionCreateManyPedidoInputEnvelope
    connect?: Enumerable<EvaluacionWhereUniqueInput>
  }

  export type DireccionCreateNestedOneWithoutPedidosInput = {
    create?: XOR<DireccionCreateWithoutPedidosInput, DireccionUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: DireccionCreateOrConnectWithoutPedidosInput
    connect?: DireccionWhereUniqueInput
  }

  export type MetodoPagoCreateNestedOneWithoutPedidosInput = {
    create?: XOR<MetodoPagoCreateWithoutPedidosInput, MetodoPagoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: MetodoPagoCreateOrConnectWithoutPedidosInput
    connect?: MetodoPagoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutPedidosInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoRopaUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<PedidoRopaCreateWithoutPedidoInput>, Enumerable<PedidoRopaUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<PedidoRopaCreateOrConnectWithoutPedidoInput>
    createMany?: PedidoRopaCreateManyPedidoInputEnvelope
    connect?: Enumerable<PedidoRopaWhereUniqueInput>
  }

  export type EvaluacionUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<EvaluacionCreateWithoutPedidoInput>, Enumerable<EvaluacionUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<EvaluacionCreateOrConnectWithoutPedidoInput>
    createMany?: EvaluacionCreateManyPedidoInputEnvelope
    connect?: Enumerable<EvaluacionWhereUniqueInput>
  }

  export type PedidoRopaUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<PedidoRopaCreateWithoutPedidoInput>, Enumerable<PedidoRopaUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<PedidoRopaCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<PedidoRopaUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: PedidoRopaCreateManyPedidoInputEnvelope
    set?: Enumerable<PedidoRopaWhereUniqueInput>
    disconnect?: Enumerable<PedidoRopaWhereUniqueInput>
    delete?: Enumerable<PedidoRopaWhereUniqueInput>
    connect?: Enumerable<PedidoRopaWhereUniqueInput>
    update?: Enumerable<PedidoRopaUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<PedidoRopaUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<PedidoRopaScalarWhereInput>
  }

  export type EvaluacionUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<EvaluacionCreateWithoutPedidoInput>, Enumerable<EvaluacionUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<EvaluacionCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<EvaluacionUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: EvaluacionCreateManyPedidoInputEnvelope
    set?: Enumerable<EvaluacionWhereUniqueInput>
    disconnect?: Enumerable<EvaluacionWhereUniqueInput>
    delete?: Enumerable<EvaluacionWhereUniqueInput>
    connect?: Enumerable<EvaluacionWhereUniqueInput>
    update?: Enumerable<EvaluacionUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<EvaluacionUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<EvaluacionScalarWhereInput>
  }

  export type DireccionUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<DireccionCreateWithoutPedidosInput, DireccionUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: DireccionCreateOrConnectWithoutPedidosInput
    upsert?: DireccionUpsertWithoutPedidosInput
    connect?: DireccionWhereUniqueInput
    update?: XOR<DireccionUpdateWithoutPedidosInput, DireccionUncheckedUpdateWithoutPedidosInput>
  }

  export type MetodoPagoUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<MetodoPagoCreateWithoutPedidosInput, MetodoPagoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: MetodoPagoCreateOrConnectWithoutPedidosInput
    upsert?: MetodoPagoUpsertWithoutPedidosInput
    connect?: MetodoPagoWhereUniqueInput
    update?: XOR<MetodoPagoUpdateWithoutPedidosInput, MetodoPagoUncheckedUpdateWithoutPedidosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    upsert?: UsuarioUpsertWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
  }

  export type PedidoRopaUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<PedidoRopaCreateWithoutPedidoInput>, Enumerable<PedidoRopaUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<PedidoRopaCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<PedidoRopaUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: PedidoRopaCreateManyPedidoInputEnvelope
    set?: Enumerable<PedidoRopaWhereUniqueInput>
    disconnect?: Enumerable<PedidoRopaWhereUniqueInput>
    delete?: Enumerable<PedidoRopaWhereUniqueInput>
    connect?: Enumerable<PedidoRopaWhereUniqueInput>
    update?: Enumerable<PedidoRopaUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<PedidoRopaUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<PedidoRopaScalarWhereInput>
  }

  export type EvaluacionUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<EvaluacionCreateWithoutPedidoInput>, Enumerable<EvaluacionUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<EvaluacionCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<EvaluacionUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: EvaluacionCreateManyPedidoInputEnvelope
    set?: Enumerable<EvaluacionWhereUniqueInput>
    disconnect?: Enumerable<EvaluacionWhereUniqueInput>
    delete?: Enumerable<EvaluacionWhereUniqueInput>
    connect?: Enumerable<EvaluacionWhereUniqueInput>
    update?: Enumerable<EvaluacionUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<EvaluacionUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<EvaluacionScalarWhereInput>
  }

  export type MetodoPagoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<MetodoPagoCreateWithoutUsuarioInput>, Enumerable<MetodoPagoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<MetodoPagoCreateOrConnectWithoutUsuarioInput>
    createMany?: MetodoPagoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<MetodoPagoWhereUniqueInput>
  }

  export type PedidoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type DireccionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<DireccionCreateWithoutUsuarioInput>, Enumerable<DireccionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<DireccionCreateOrConnectWithoutUsuarioInput>
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<DireccionWhereUniqueInput>
  }

  export type PreguntaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutUsuarioInput>, Enumerable<PreguntaUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutUsuarioInput>
    createMany?: PreguntaCreateManyUsuarioInputEnvelope
    connect?: Enumerable<PreguntaWhereUniqueInput>
  }

  export type RespuestaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<RespuestaCreateWithoutUsuarioInput>, Enumerable<RespuestaUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<RespuestaCreateOrConnectWithoutUsuarioInput>
    createMany?: RespuestaCreateManyUsuarioInputEnvelope
    connect?: Enumerable<RespuestaWhereUniqueInput>
  }

  export type InformeCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<InformeCreateWithoutUsuarioInput>, Enumerable<InformeUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<InformeCreateOrConnectWithoutUsuarioInput>
    createMany?: InformeCreateManyUsuarioInputEnvelope
    connect?: Enumerable<InformeWhereUniqueInput>
  }

  export type EvaluacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<EvaluacionCreateWithoutUsuarioInput>, Enumerable<EvaluacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<EvaluacionCreateOrConnectWithoutUsuarioInput>
    createMany?: EvaluacionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<EvaluacionWhereUniqueInput>
  }

  export type RopaCreateNestedManyWithoutVendedorInput = {
    create?: XOR<Enumerable<RopaCreateWithoutVendedorInput>, Enumerable<RopaUncheckedCreateWithoutVendedorInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutVendedorInput>
    createMany?: RopaCreateManyVendedorInputEnvelope
    connect?: Enumerable<RopaWhereUniqueInput>
  }

  export type MetodoPagoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<MetodoPagoCreateWithoutUsuarioInput>, Enumerable<MetodoPagoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<MetodoPagoCreateOrConnectWithoutUsuarioInput>
    createMany?: MetodoPagoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<MetodoPagoWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type DireccionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<DireccionCreateWithoutUsuarioInput>, Enumerable<DireccionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<DireccionCreateOrConnectWithoutUsuarioInput>
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<DireccionWhereUniqueInput>
  }

  export type PreguntaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutUsuarioInput>, Enumerable<PreguntaUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutUsuarioInput>
    createMany?: PreguntaCreateManyUsuarioInputEnvelope
    connect?: Enumerable<PreguntaWhereUniqueInput>
  }

  export type RespuestaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<RespuestaCreateWithoutUsuarioInput>, Enumerable<RespuestaUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<RespuestaCreateOrConnectWithoutUsuarioInput>
    createMany?: RespuestaCreateManyUsuarioInputEnvelope
    connect?: Enumerable<RespuestaWhereUniqueInput>
  }

  export type InformeUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<InformeCreateWithoutUsuarioInput>, Enumerable<InformeUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<InformeCreateOrConnectWithoutUsuarioInput>
    createMany?: InformeCreateManyUsuarioInputEnvelope
    connect?: Enumerable<InformeWhereUniqueInput>
  }

  export type EvaluacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<EvaluacionCreateWithoutUsuarioInput>, Enumerable<EvaluacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<EvaluacionCreateOrConnectWithoutUsuarioInput>
    createMany?: EvaluacionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<EvaluacionWhereUniqueInput>
  }

  export type RopaUncheckedCreateNestedManyWithoutVendedorInput = {
    create?: XOR<Enumerable<RopaCreateWithoutVendedorInput>, Enumerable<RopaUncheckedCreateWithoutVendedorInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutVendedorInput>
    createMany?: RopaCreateManyVendedorInputEnvelope
    connect?: Enumerable<RopaWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: Rol
  }

  export type MetodoPagoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<MetodoPagoCreateWithoutUsuarioInput>, Enumerable<MetodoPagoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<MetodoPagoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<MetodoPagoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: MetodoPagoCreateManyUsuarioInputEnvelope
    set?: Enumerable<MetodoPagoWhereUniqueInput>
    disconnect?: Enumerable<MetodoPagoWhereUniqueInput>
    delete?: Enumerable<MetodoPagoWhereUniqueInput>
    connect?: Enumerable<MetodoPagoWhereUniqueInput>
    update?: Enumerable<MetodoPagoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<MetodoPagoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<MetodoPagoScalarWhereInput>
  }

  export type PedidoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type DireccionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<DireccionCreateWithoutUsuarioInput>, Enumerable<DireccionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<DireccionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<DireccionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    set?: Enumerable<DireccionWhereUniqueInput>
    disconnect?: Enumerable<DireccionWhereUniqueInput>
    delete?: Enumerable<DireccionWhereUniqueInput>
    connect?: Enumerable<DireccionWhereUniqueInput>
    update?: Enumerable<DireccionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<DireccionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<DireccionScalarWhereInput>
  }

  export type PreguntaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutUsuarioInput>, Enumerable<PreguntaUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<PreguntaUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: PreguntaCreateManyUsuarioInputEnvelope
    set?: Enumerable<PreguntaWhereUniqueInput>
    disconnect?: Enumerable<PreguntaWhereUniqueInput>
    delete?: Enumerable<PreguntaWhereUniqueInput>
    connect?: Enumerable<PreguntaWhereUniqueInput>
    update?: Enumerable<PreguntaUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<PreguntaUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<PreguntaScalarWhereInput>
  }

  export type RespuestaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<RespuestaCreateWithoutUsuarioInput>, Enumerable<RespuestaUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<RespuestaCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<RespuestaUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: RespuestaCreateManyUsuarioInputEnvelope
    set?: Enumerable<RespuestaWhereUniqueInput>
    disconnect?: Enumerable<RespuestaWhereUniqueInput>
    delete?: Enumerable<RespuestaWhereUniqueInput>
    connect?: Enumerable<RespuestaWhereUniqueInput>
    update?: Enumerable<RespuestaUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<RespuestaUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<RespuestaScalarWhereInput>
  }

  export type InformeUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<InformeCreateWithoutUsuarioInput>, Enumerable<InformeUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<InformeCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<InformeUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: InformeCreateManyUsuarioInputEnvelope
    set?: Enumerable<InformeWhereUniqueInput>
    disconnect?: Enumerable<InformeWhereUniqueInput>
    delete?: Enumerable<InformeWhereUniqueInput>
    connect?: Enumerable<InformeWhereUniqueInput>
    update?: Enumerable<InformeUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<InformeUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<InformeScalarWhereInput>
  }

  export type EvaluacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<EvaluacionCreateWithoutUsuarioInput>, Enumerable<EvaluacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<EvaluacionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<EvaluacionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: EvaluacionCreateManyUsuarioInputEnvelope
    set?: Enumerable<EvaluacionWhereUniqueInput>
    disconnect?: Enumerable<EvaluacionWhereUniqueInput>
    delete?: Enumerable<EvaluacionWhereUniqueInput>
    connect?: Enumerable<EvaluacionWhereUniqueInput>
    update?: Enumerable<EvaluacionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<EvaluacionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<EvaluacionScalarWhereInput>
  }

  export type RopaUpdateManyWithoutVendedorNestedInput = {
    create?: XOR<Enumerable<RopaCreateWithoutVendedorInput>, Enumerable<RopaUncheckedCreateWithoutVendedorInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutVendedorInput>
    upsert?: Enumerable<RopaUpsertWithWhereUniqueWithoutVendedorInput>
    createMany?: RopaCreateManyVendedorInputEnvelope
    set?: Enumerable<RopaWhereUniqueInput>
    disconnect?: Enumerable<RopaWhereUniqueInput>
    delete?: Enumerable<RopaWhereUniqueInput>
    connect?: Enumerable<RopaWhereUniqueInput>
    update?: Enumerable<RopaUpdateWithWhereUniqueWithoutVendedorInput>
    updateMany?: Enumerable<RopaUpdateManyWithWhereWithoutVendedorInput>
    deleteMany?: Enumerable<RopaScalarWhereInput>
  }

  export type MetodoPagoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<MetodoPagoCreateWithoutUsuarioInput>, Enumerable<MetodoPagoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<MetodoPagoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<MetodoPagoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: MetodoPagoCreateManyUsuarioInputEnvelope
    set?: Enumerable<MetodoPagoWhereUniqueInput>
    disconnect?: Enumerable<MetodoPagoWhereUniqueInput>
    delete?: Enumerable<MetodoPagoWhereUniqueInput>
    connect?: Enumerable<MetodoPagoWhereUniqueInput>
    update?: Enumerable<MetodoPagoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<MetodoPagoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<MetodoPagoScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type DireccionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<DireccionCreateWithoutUsuarioInput>, Enumerable<DireccionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<DireccionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<DireccionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    set?: Enumerable<DireccionWhereUniqueInput>
    disconnect?: Enumerable<DireccionWhereUniqueInput>
    delete?: Enumerable<DireccionWhereUniqueInput>
    connect?: Enumerable<DireccionWhereUniqueInput>
    update?: Enumerable<DireccionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<DireccionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<DireccionScalarWhereInput>
  }

  export type PreguntaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutUsuarioInput>, Enumerable<PreguntaUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<PreguntaUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: PreguntaCreateManyUsuarioInputEnvelope
    set?: Enumerable<PreguntaWhereUniqueInput>
    disconnect?: Enumerable<PreguntaWhereUniqueInput>
    delete?: Enumerable<PreguntaWhereUniqueInput>
    connect?: Enumerable<PreguntaWhereUniqueInput>
    update?: Enumerable<PreguntaUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<PreguntaUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<PreguntaScalarWhereInput>
  }

  export type RespuestaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<RespuestaCreateWithoutUsuarioInput>, Enumerable<RespuestaUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<RespuestaCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<RespuestaUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: RespuestaCreateManyUsuarioInputEnvelope
    set?: Enumerable<RespuestaWhereUniqueInput>
    disconnect?: Enumerable<RespuestaWhereUniqueInput>
    delete?: Enumerable<RespuestaWhereUniqueInput>
    connect?: Enumerable<RespuestaWhereUniqueInput>
    update?: Enumerable<RespuestaUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<RespuestaUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<RespuestaScalarWhereInput>
  }

  export type InformeUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<InformeCreateWithoutUsuarioInput>, Enumerable<InformeUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<InformeCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<InformeUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: InformeCreateManyUsuarioInputEnvelope
    set?: Enumerable<InformeWhereUniqueInput>
    disconnect?: Enumerable<InformeWhereUniqueInput>
    delete?: Enumerable<InformeWhereUniqueInput>
    connect?: Enumerable<InformeWhereUniqueInput>
    update?: Enumerable<InformeUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<InformeUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<InformeScalarWhereInput>
  }

  export type EvaluacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<EvaluacionCreateWithoutUsuarioInput>, Enumerable<EvaluacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<EvaluacionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<EvaluacionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: EvaluacionCreateManyUsuarioInputEnvelope
    set?: Enumerable<EvaluacionWhereUniqueInput>
    disconnect?: Enumerable<EvaluacionWhereUniqueInput>
    delete?: Enumerable<EvaluacionWhereUniqueInput>
    connect?: Enumerable<EvaluacionWhereUniqueInput>
    update?: Enumerable<EvaluacionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<EvaluacionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<EvaluacionScalarWhereInput>
  }

  export type RopaUncheckedUpdateManyWithoutVendedorNestedInput = {
    create?: XOR<Enumerable<RopaCreateWithoutVendedorInput>, Enumerable<RopaUncheckedCreateWithoutVendedorInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutVendedorInput>
    upsert?: Enumerable<RopaUpsertWithWhereUniqueWithoutVendedorInput>
    createMany?: RopaCreateManyVendedorInputEnvelope
    set?: Enumerable<RopaWhereUniqueInput>
    disconnect?: Enumerable<RopaWhereUniqueInput>
    delete?: Enumerable<RopaWhereUniqueInput>
    connect?: Enumerable<RopaWhereUniqueInput>
    update?: Enumerable<RopaUpdateWithWhereUniqueWithoutVendedorInput>
    updateMany?: Enumerable<RopaUpdateManyWithWhereWithoutVendedorInput>
    deleteMany?: Enumerable<RopaScalarWhereInput>
  }

  export type UsuarioCreateNestedOneWithoutMetodosInput = {
    create?: XOR<UsuarioCreateWithoutMetodosInput, UsuarioUncheckedCreateWithoutMetodosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMetodosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoCreateNestedManyWithoutMetodoInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMetodoInput>, Enumerable<PedidoUncheckedCreateWithoutMetodoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMetodoInput>
    createMany?: PedidoCreateManyMetodoInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutMetodoInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMetodoInput>, Enumerable<PedidoUncheckedCreateWithoutMetodoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMetodoInput>
    createMany?: PedidoCreateManyMetodoInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type UsuarioUpdateOneRequiredWithoutMetodosNestedInput = {
    create?: XOR<UsuarioCreateWithoutMetodosInput, UsuarioUncheckedCreateWithoutMetodosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMetodosInput
    upsert?: UsuarioUpsertWithoutMetodosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutMetodosInput, UsuarioUncheckedUpdateWithoutMetodosInput>
  }

  export type PedidoUpdateManyWithoutMetodoNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMetodoInput>, Enumerable<PedidoUncheckedCreateWithoutMetodoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMetodoInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutMetodoInput>
    createMany?: PedidoCreateManyMetodoInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutMetodoInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutMetodoInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutMetodoNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMetodoInput>, Enumerable<PedidoUncheckedCreateWithoutMetodoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMetodoInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutMetodoInput>
    createMany?: PedidoCreateManyMetodoInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutMetodoInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutMetodoInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type UsuarioCreateNestedOneWithoutPreguntasInput = {
    create?: XOR<UsuarioCreateWithoutPreguntasInput, UsuarioUncheckedCreateWithoutPreguntasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPreguntasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RopaCreateNestedOneWithoutPreguntasInput = {
    create?: XOR<RopaCreateWithoutPreguntasInput, RopaUncheckedCreateWithoutPreguntasInput>
    connectOrCreate?: RopaCreateOrConnectWithoutPreguntasInput
    connect?: RopaWhereUniqueInput
  }

  export type RespuestaCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<Enumerable<RespuestaCreateWithoutPreguntasInput>, Enumerable<RespuestaUncheckedCreateWithoutPreguntasInput>>
    connectOrCreate?: Enumerable<RespuestaCreateOrConnectWithoutPreguntasInput>
    connect?: Enumerable<RespuestaWhereUniqueInput>
  }

  export type RespuestaUncheckedCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<Enumerable<RespuestaCreateWithoutPreguntasInput>, Enumerable<RespuestaUncheckedCreateWithoutPreguntasInput>>
    connectOrCreate?: Enumerable<RespuestaCreateOrConnectWithoutPreguntasInput>
    connect?: Enumerable<RespuestaWhereUniqueInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPreguntasNestedInput = {
    create?: XOR<UsuarioCreateWithoutPreguntasInput, UsuarioUncheckedCreateWithoutPreguntasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPreguntasInput
    upsert?: UsuarioUpsertWithoutPreguntasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutPreguntasInput, UsuarioUncheckedUpdateWithoutPreguntasInput>
  }

  export type RopaUpdateOneRequiredWithoutPreguntasNestedInput = {
    create?: XOR<RopaCreateWithoutPreguntasInput, RopaUncheckedCreateWithoutPreguntasInput>
    connectOrCreate?: RopaCreateOrConnectWithoutPreguntasInput
    upsert?: RopaUpsertWithoutPreguntasInput
    connect?: RopaWhereUniqueInput
    update?: XOR<RopaUpdateWithoutPreguntasInput, RopaUncheckedUpdateWithoutPreguntasInput>
  }

  export type RespuestaUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<Enumerable<RespuestaCreateWithoutPreguntasInput>, Enumerable<RespuestaUncheckedCreateWithoutPreguntasInput>>
    connectOrCreate?: Enumerable<RespuestaCreateOrConnectWithoutPreguntasInput>
    upsert?: Enumerable<RespuestaUpsertWithWhereUniqueWithoutPreguntasInput>
    set?: Enumerable<RespuestaWhereUniqueInput>
    disconnect?: Enumerable<RespuestaWhereUniqueInput>
    delete?: Enumerable<RespuestaWhereUniqueInput>
    connect?: Enumerable<RespuestaWhereUniqueInput>
    update?: Enumerable<RespuestaUpdateWithWhereUniqueWithoutPreguntasInput>
    updateMany?: Enumerable<RespuestaUpdateManyWithWhereWithoutPreguntasInput>
    deleteMany?: Enumerable<RespuestaScalarWhereInput>
  }

  export type RespuestaUncheckedUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<Enumerable<RespuestaCreateWithoutPreguntasInput>, Enumerable<RespuestaUncheckedCreateWithoutPreguntasInput>>
    connectOrCreate?: Enumerable<RespuestaCreateOrConnectWithoutPreguntasInput>
    upsert?: Enumerable<RespuestaUpsertWithWhereUniqueWithoutPreguntasInput>
    set?: Enumerable<RespuestaWhereUniqueInput>
    disconnect?: Enumerable<RespuestaWhereUniqueInput>
    delete?: Enumerable<RespuestaWhereUniqueInput>
    connect?: Enumerable<RespuestaWhereUniqueInput>
    update?: Enumerable<RespuestaUpdateWithWhereUniqueWithoutPreguntasInput>
    updateMany?: Enumerable<RespuestaUpdateManyWithWhereWithoutPreguntasInput>
    deleteMany?: Enumerable<RespuestaScalarWhereInput>
  }

  export type UsuarioCreateNestedOneWithoutRespuestasInput = {
    create?: XOR<UsuarioCreateWithoutRespuestasInput, UsuarioUncheckedCreateWithoutRespuestasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRespuestasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PreguntaCreateNestedManyWithoutRespuestasInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutRespuestasInput>, Enumerable<PreguntaUncheckedCreateWithoutRespuestasInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutRespuestasInput>
    connect?: Enumerable<PreguntaWhereUniqueInput>
  }

  export type PreguntaUncheckedCreateNestedManyWithoutRespuestasInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutRespuestasInput>, Enumerable<PreguntaUncheckedCreateWithoutRespuestasInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutRespuestasInput>
    connect?: Enumerable<PreguntaWhereUniqueInput>
  }

  export type UsuarioUpdateOneRequiredWithoutRespuestasNestedInput = {
    create?: XOR<UsuarioCreateWithoutRespuestasInput, UsuarioUncheckedCreateWithoutRespuestasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRespuestasInput
    upsert?: UsuarioUpsertWithoutRespuestasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutRespuestasInput, UsuarioUncheckedUpdateWithoutRespuestasInput>
  }

  export type PreguntaUpdateManyWithoutRespuestasNestedInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutRespuestasInput>, Enumerable<PreguntaUncheckedCreateWithoutRespuestasInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutRespuestasInput>
    upsert?: Enumerable<PreguntaUpsertWithWhereUniqueWithoutRespuestasInput>
    set?: Enumerable<PreguntaWhereUniqueInput>
    disconnect?: Enumerable<PreguntaWhereUniqueInput>
    delete?: Enumerable<PreguntaWhereUniqueInput>
    connect?: Enumerable<PreguntaWhereUniqueInput>
    update?: Enumerable<PreguntaUpdateWithWhereUniqueWithoutRespuestasInput>
    updateMany?: Enumerable<PreguntaUpdateManyWithWhereWithoutRespuestasInput>
    deleteMany?: Enumerable<PreguntaScalarWhereInput>
  }

  export type PreguntaUncheckedUpdateManyWithoutRespuestasNestedInput = {
    create?: XOR<Enumerable<PreguntaCreateWithoutRespuestasInput>, Enumerable<PreguntaUncheckedCreateWithoutRespuestasInput>>
    connectOrCreate?: Enumerable<PreguntaCreateOrConnectWithoutRespuestasInput>
    upsert?: Enumerable<PreguntaUpsertWithWhereUniqueWithoutRespuestasInput>
    set?: Enumerable<PreguntaWhereUniqueInput>
    disconnect?: Enumerable<PreguntaWhereUniqueInput>
    delete?: Enumerable<PreguntaWhereUniqueInput>
    connect?: Enumerable<PreguntaWhereUniqueInput>
    update?: Enumerable<PreguntaUpdateWithWhereUniqueWithoutRespuestasInput>
    updateMany?: Enumerable<PreguntaUpdateManyWithWhereWithoutRespuestasInput>
    deleteMany?: Enumerable<PreguntaScalarWhereInput>
  }

  export type UsuarioCreateNestedOneWithoutInformesInput = {
    create?: XOR<UsuarioCreateWithoutInformesInput, UsuarioUncheckedCreateWithoutInformesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutInformesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutInformesNestedInput = {
    create?: XOR<UsuarioCreateWithoutInformesInput, UsuarioUncheckedCreateWithoutInformesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutInformesInput
    upsert?: UsuarioUpsertWithoutInformesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutInformesInput, UsuarioUncheckedUpdateWithoutInformesInput>
  }

  export type UsuarioCreateNestedOneWithoutEvaluacionesInput = {
    create?: XOR<UsuarioCreateWithoutEvaluacionesInput, UsuarioUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEvaluacionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoCreateNestedOneWithoutEvaluacionesInput = {
    create?: XOR<PedidoCreateWithoutEvaluacionesInput, PedidoUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutEvaluacionesInput
    connect?: PedidoWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UsuarioUpdateOneRequiredWithoutEvaluacionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutEvaluacionesInput, UsuarioUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEvaluacionesInput
    upsert?: UsuarioUpsertWithoutEvaluacionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutEvaluacionesInput, UsuarioUncheckedUpdateWithoutEvaluacionesInput>
  }

  export type PedidoUpdateOneRequiredWithoutEvaluacionesNestedInput = {
    create?: XOR<PedidoCreateWithoutEvaluacionesInput, PedidoUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutEvaluacionesInput
    upsert?: PedidoUpsertWithoutEvaluacionesInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<PedidoUpdateWithoutEvaluacionesInput, PedidoUncheckedUpdateWithoutEvaluacionesInput>
  }

  export type RopaCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<Enumerable<RopaCreateWithoutCategoriasInput>, Enumerable<RopaUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutCategoriasInput>
    connect?: Enumerable<RopaWhereUniqueInput>
  }

  export type RopaUncheckedCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<Enumerable<RopaCreateWithoutCategoriasInput>, Enumerable<RopaUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutCategoriasInput>
    connect?: Enumerable<RopaWhereUniqueInput>
  }

  export type RopaUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<Enumerable<RopaCreateWithoutCategoriasInput>, Enumerable<RopaUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutCategoriasInput>
    upsert?: Enumerable<RopaUpsertWithWhereUniqueWithoutCategoriasInput>
    set?: Enumerable<RopaWhereUniqueInput>
    disconnect?: Enumerable<RopaWhereUniqueInput>
    delete?: Enumerable<RopaWhereUniqueInput>
    connect?: Enumerable<RopaWhereUniqueInput>
    update?: Enumerable<RopaUpdateWithWhereUniqueWithoutCategoriasInput>
    updateMany?: Enumerable<RopaUpdateManyWithWhereWithoutCategoriasInput>
    deleteMany?: Enumerable<RopaScalarWhereInput>
  }

  export type RopaUncheckedUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<Enumerable<RopaCreateWithoutCategoriasInput>, Enumerable<RopaUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<RopaCreateOrConnectWithoutCategoriasInput>
    upsert?: Enumerable<RopaUpsertWithWhereUniqueWithoutCategoriasInput>
    set?: Enumerable<RopaWhereUniqueInput>
    disconnect?: Enumerable<RopaWhereUniqueInput>
    delete?: Enumerable<RopaWhereUniqueInput>
    connect?: Enumerable<RopaWhereUniqueInput>
    update?: Enumerable<RopaUpdateWithWhereUniqueWithoutCategoriasInput>
    updateMany?: Enumerable<RopaUpdateManyWithWhereWithoutCategoriasInput>
    deleteMany?: Enumerable<RopaScalarWhereInput>
  }

  export type UsuarioCreateNestedOneWithoutDireccionesInput = {
    create?: XOR<UsuarioCreateWithoutDireccionesInput, UsuarioUncheckedCreateWithoutDireccionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDireccionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoCreateNestedManyWithoutDireccionInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutDireccionInput>, Enumerable<PedidoUncheckedCreateWithoutDireccionInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutDireccionInput>
    createMany?: PedidoCreateManyDireccionInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutDireccionInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutDireccionInput>, Enumerable<PedidoUncheckedCreateWithoutDireccionInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutDireccionInput>
    createMany?: PedidoCreateManyDireccionInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type UsuarioUpdateOneRequiredWithoutDireccionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutDireccionesInput, UsuarioUncheckedCreateWithoutDireccionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDireccionesInput
    upsert?: UsuarioUpsertWithoutDireccionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutDireccionesInput, UsuarioUncheckedUpdateWithoutDireccionesInput>
  }

  export type PedidoUpdateManyWithoutDireccionNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutDireccionInput>, Enumerable<PedidoUncheckedCreateWithoutDireccionInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutDireccionInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutDireccionInput>
    createMany?: PedidoCreateManyDireccionInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutDireccionInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutDireccionInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutDireccionNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutDireccionInput>, Enumerable<PedidoUncheckedCreateWithoutDireccionInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutDireccionInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutDireccionInput>
    createMany?: PedidoCreateManyDireccionInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutDireccionInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutDireccionInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type RopaCreateNestedOneWithoutFotosInput = {
    create?: XOR<RopaCreateWithoutFotosInput, RopaUncheckedCreateWithoutFotosInput>
    connectOrCreate?: RopaCreateOrConnectWithoutFotosInput
    connect?: RopaWhereUniqueInput
  }

  export type RopaUpdateOneRequiredWithoutFotosNestedInput = {
    create?: XOR<RopaCreateWithoutFotosInput, RopaUncheckedCreateWithoutFotosInput>
    connectOrCreate?: RopaCreateOrConnectWithoutFotosInput
    upsert?: RopaUpsertWithoutFotosInput
    connect?: RopaWhereUniqueInput
    update?: XOR<RopaUpdateWithoutFotosInput, RopaUncheckedUpdateWithoutFotosInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumRolFilter = {
    equals?: Rol
    in?: Enumerable<Rol>
    notIn?: Enumerable<Rol>
    not?: NestedEnumRolFilter | Rol
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumRolWithAggregatesFilter = {
    equals?: Rol
    in?: Enumerable<Rol>
    notIn?: Enumerable<Rol>
    not?: NestedEnumRolWithAggregatesFilter | Rol
    _count?: NestedIntFilter
    _min?: NestedEnumRolFilter
    _max?: NestedEnumRolFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type RopaCreateWithoutProveedorInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendedor: UsuarioCreateNestedOneWithoutRopasInput
    categorias?: CategoriaCreateNestedManyWithoutRopasInput
    fotos?: FotoCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaCreateNestedManyWithoutRopaInput
  }

  export type RopaUncheckedCreateWithoutProveedorInput = {
    id?: number
    vendedorId: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categorias?: CategoriaUncheckedCreateNestedManyWithoutRopasInput
    fotos?: FotoUncheckedCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaUncheckedCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutRopaInput
  }

  export type RopaCreateOrConnectWithoutProveedorInput = {
    where: RopaWhereUniqueInput
    create: XOR<RopaCreateWithoutProveedorInput, RopaUncheckedCreateWithoutProveedorInput>
  }

  export type RopaCreateManyProveedorInputEnvelope = {
    data: Enumerable<RopaCreateManyProveedorInput>
    skipDuplicates?: boolean
  }

  export type RopaUpsertWithWhereUniqueWithoutProveedorInput = {
    where: RopaWhereUniqueInput
    update: XOR<RopaUpdateWithoutProveedorInput, RopaUncheckedUpdateWithoutProveedorInput>
    create: XOR<RopaCreateWithoutProveedorInput, RopaUncheckedCreateWithoutProveedorInput>
  }

  export type RopaUpdateWithWhereUniqueWithoutProveedorInput = {
    where: RopaWhereUniqueInput
    data: XOR<RopaUpdateWithoutProveedorInput, RopaUncheckedUpdateWithoutProveedorInput>
  }

  export type RopaUpdateManyWithWhereWithoutProveedorInput = {
    where: RopaScalarWhereInput
    data: XOR<RopaUpdateManyMutationInput, RopaUncheckedUpdateManyWithoutRopasInput>
  }

  export type RopaScalarWhereInput = {
    AND?: Enumerable<RopaScalarWhereInput>
    OR?: Enumerable<RopaScalarWhereInput>
    NOT?: Enumerable<RopaScalarWhereInput>
    id?: IntFilter | number
    vendedorId?: IntFilter | number
    nombre?: StringFilter | string
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    estado?: StringFilter | string
    cantidad?: IntFilter | number
    proveedorId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProveedorCreateWithoutRopasInput = {
    nombre: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProveedorUncheckedCreateWithoutRopasInput = {
    id?: number
    nombre: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProveedorCreateOrConnectWithoutRopasInput = {
    where: ProveedorWhereUniqueInput
    create: XOR<ProveedorCreateWithoutRopasInput, ProveedorUncheckedCreateWithoutRopasInput>
  }

  export type UsuarioCreateWithoutRopasInput = {
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaCreateNestedManyWithoutUsuarioInput
    informes?: InformeCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRopasInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutUsuarioInput
    informes?: InformeUncheckedCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRopasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRopasInput, UsuarioUncheckedCreateWithoutRopasInput>
  }

  export type CategoriaCreateWithoutRopasInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoriaUncheckedCreateWithoutRopasInput = {
    id?: number
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoriaCreateOrConnectWithoutRopasInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutRopasInput, CategoriaUncheckedCreateWithoutRopasInput>
  }

  export type FotoCreateWithoutRopaInput = {
    foto: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FotoUncheckedCreateWithoutRopaInput = {
    id?: number
    foto: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FotoCreateOrConnectWithoutRopaInput = {
    where: FotoWhereUniqueInput
    create: XOR<FotoCreateWithoutRopaInput, FotoUncheckedCreateWithoutRopaInput>
  }

  export type FotoCreateManyRopaInputEnvelope = {
    data: Enumerable<FotoCreateManyRopaInput>
    skipDuplicates?: boolean
  }

  export type PedidoRopaCreateWithoutRopaInput = {
    cantidad: number
    subtotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutRopasInput
  }

  export type PedidoRopaUncheckedCreateWithoutRopaInput = {
    id?: number
    idPedido: number
    cantidad: number
    subtotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoRopaCreateOrConnectWithoutRopaInput = {
    where: PedidoRopaWhereUniqueInput
    create: XOR<PedidoRopaCreateWithoutRopaInput, PedidoRopaUncheckedCreateWithoutRopaInput>
  }

  export type PedidoRopaCreateManyRopaInputEnvelope = {
    data: Enumerable<PedidoRopaCreateManyRopaInput>
    skipDuplicates?: boolean
  }

  export type PreguntaCreateWithoutRopaInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutPreguntasInput
    respuestas?: RespuestaCreateNestedManyWithoutPreguntasInput
  }

  export type PreguntaUncheckedCreateWithoutRopaInput = {
    id?: number
    descripcion: string
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type PreguntaCreateOrConnectWithoutRopaInput = {
    where: PreguntaWhereUniqueInput
    create: XOR<PreguntaCreateWithoutRopaInput, PreguntaUncheckedCreateWithoutRopaInput>
  }

  export type PreguntaCreateManyRopaInputEnvelope = {
    data: Enumerable<PreguntaCreateManyRopaInput>
    skipDuplicates?: boolean
  }

  export type ProveedorUpsertWithoutRopasInput = {
    update: XOR<ProveedorUpdateWithoutRopasInput, ProveedorUncheckedUpdateWithoutRopasInput>
    create: XOR<ProveedorCreateWithoutRopasInput, ProveedorUncheckedCreateWithoutRopasInput>
  }

  export type ProveedorUpdateWithoutRopasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProveedorUncheckedUpdateWithoutRopasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUpsertWithoutRopasInput = {
    update: XOR<UsuarioUpdateWithoutRopasInput, UsuarioUncheckedUpdateWithoutRopasInput>
    create: XOR<UsuarioCreateWithoutRopasInput, UsuarioUncheckedCreateWithoutRopasInput>
  }

  export type UsuarioUpdateWithoutRopasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRopasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUncheckedUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUncheckedUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CategoriaUpsertWithWhereUniqueWithoutRopasInput = {
    where: CategoriaWhereUniqueInput
    update: XOR<CategoriaUpdateWithoutRopasInput, CategoriaUncheckedUpdateWithoutRopasInput>
    create: XOR<CategoriaCreateWithoutRopasInput, CategoriaUncheckedCreateWithoutRopasInput>
  }

  export type CategoriaUpdateWithWhereUniqueWithoutRopasInput = {
    where: CategoriaWhereUniqueInput
    data: XOR<CategoriaUpdateWithoutRopasInput, CategoriaUncheckedUpdateWithoutRopasInput>
  }

  export type CategoriaUpdateManyWithWhereWithoutRopasInput = {
    where: CategoriaScalarWhereInput
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyWithoutCategoriasInput>
  }

  export type CategoriaScalarWhereInput = {
    AND?: Enumerable<CategoriaScalarWhereInput>
    OR?: Enumerable<CategoriaScalarWhereInput>
    NOT?: Enumerable<CategoriaScalarWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FotoUpsertWithWhereUniqueWithoutRopaInput = {
    where: FotoWhereUniqueInput
    update: XOR<FotoUpdateWithoutRopaInput, FotoUncheckedUpdateWithoutRopaInput>
    create: XOR<FotoCreateWithoutRopaInput, FotoUncheckedCreateWithoutRopaInput>
  }

  export type FotoUpdateWithWhereUniqueWithoutRopaInput = {
    where: FotoWhereUniqueInput
    data: XOR<FotoUpdateWithoutRopaInput, FotoUncheckedUpdateWithoutRopaInput>
  }

  export type FotoUpdateManyWithWhereWithoutRopaInput = {
    where: FotoScalarWhereInput
    data: XOR<FotoUpdateManyMutationInput, FotoUncheckedUpdateManyWithoutFotosInput>
  }

  export type FotoScalarWhereInput = {
    AND?: Enumerable<FotoScalarWhereInput>
    OR?: Enumerable<FotoScalarWhereInput>
    NOT?: Enumerable<FotoScalarWhereInput>
    id?: IntFilter | number
    ropaId?: IntFilter | number
    foto?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PedidoRopaUpsertWithWhereUniqueWithoutRopaInput = {
    where: PedidoRopaWhereUniqueInput
    update: XOR<PedidoRopaUpdateWithoutRopaInput, PedidoRopaUncheckedUpdateWithoutRopaInput>
    create: XOR<PedidoRopaCreateWithoutRopaInput, PedidoRopaUncheckedCreateWithoutRopaInput>
  }

  export type PedidoRopaUpdateWithWhereUniqueWithoutRopaInput = {
    where: PedidoRopaWhereUniqueInput
    data: XOR<PedidoRopaUpdateWithoutRopaInput, PedidoRopaUncheckedUpdateWithoutRopaInput>
  }

  export type PedidoRopaUpdateManyWithWhereWithoutRopaInput = {
    where: PedidoRopaScalarWhereInput
    data: XOR<PedidoRopaUpdateManyMutationInput, PedidoRopaUncheckedUpdateManyWithoutOrdenesInput>
  }

  export type PedidoRopaScalarWhereInput = {
    AND?: Enumerable<PedidoRopaScalarWhereInput>
    OR?: Enumerable<PedidoRopaScalarWhereInput>
    NOT?: Enumerable<PedidoRopaScalarWhereInput>
    id?: IntFilter | number
    idRopa?: IntFilter | number
    idPedido?: IntFilter | number
    cantidad?: IntFilter | number
    subtotal?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PreguntaUpsertWithWhereUniqueWithoutRopaInput = {
    where: PreguntaWhereUniqueInput
    update: XOR<PreguntaUpdateWithoutRopaInput, PreguntaUncheckedUpdateWithoutRopaInput>
    create: XOR<PreguntaCreateWithoutRopaInput, PreguntaUncheckedCreateWithoutRopaInput>
  }

  export type PreguntaUpdateWithWhereUniqueWithoutRopaInput = {
    where: PreguntaWhereUniqueInput
    data: XOR<PreguntaUpdateWithoutRopaInput, PreguntaUncheckedUpdateWithoutRopaInput>
  }

  export type PreguntaUpdateManyWithWhereWithoutRopaInput = {
    where: PreguntaScalarWhereInput
    data: XOR<PreguntaUpdateManyMutationInput, PreguntaUncheckedUpdateManyWithoutPreguntasInput>
  }

  export type PreguntaScalarWhereInput = {
    AND?: Enumerable<PreguntaScalarWhereInput>
    OR?: Enumerable<PreguntaScalarWhereInput>
    NOT?: Enumerable<PreguntaScalarWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    usuarioId?: IntFilter | number
    ropaId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PedidoCreateWithoutRopasInput = {
    fechaOrden?: Date | string
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluaciones?: EvaluacionCreateNestedManyWithoutPedidoInput
    direccion: DireccionCreateNestedOneWithoutPedidosInput
    metodo: MetodoPagoCreateNestedOneWithoutPedidosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutRopasInput = {
    id?: number
    fechaOrden?: Date | string
    idPago: number
    clienteId: number
    direccionId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutRopasInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutRopasInput, PedidoUncheckedCreateWithoutRopasInput>
  }

  export type RopaCreateWithoutOrdenesInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proveedor: ProveedorCreateNestedOneWithoutRopasInput
    vendedor: UsuarioCreateNestedOneWithoutRopasInput
    categorias?: CategoriaCreateNestedManyWithoutRopasInput
    fotos?: FotoCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaCreateNestedManyWithoutRopaInput
  }

  export type RopaUncheckedCreateWithoutOrdenesInput = {
    id?: number
    vendedorId: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    proveedorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categorias?: CategoriaUncheckedCreateNestedManyWithoutRopasInput
    fotos?: FotoUncheckedCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutRopaInput
  }

  export type RopaCreateOrConnectWithoutOrdenesInput = {
    where: RopaWhereUniqueInput
    create: XOR<RopaCreateWithoutOrdenesInput, RopaUncheckedCreateWithoutOrdenesInput>
  }

  export type PedidoUpsertWithoutRopasInput = {
    update: XOR<PedidoUpdateWithoutRopasInput, PedidoUncheckedUpdateWithoutRopasInput>
    create: XOR<PedidoCreateWithoutRopasInput, PedidoUncheckedCreateWithoutRopasInput>
  }

  export type PedidoUpdateWithoutRopasInput = {
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluaciones?: EvaluacionUpdateManyWithoutPedidoNestedInput
    direccion?: DireccionUpdateOneRequiredWithoutPedidosNestedInput
    metodo?: MetodoPagoUpdateOneRequiredWithoutPedidosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutRopasInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    idPago?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    direccionId?: IntFieldUpdateOperationsInput | number
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type RopaUpsertWithoutOrdenesInput = {
    update: XOR<RopaUpdateWithoutOrdenesInput, RopaUncheckedUpdateWithoutOrdenesInput>
    create: XOR<RopaCreateWithoutOrdenesInput, RopaUncheckedCreateWithoutOrdenesInput>
  }

  export type RopaUpdateWithoutOrdenesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proveedor?: ProveedorUpdateOneRequiredWithoutRopasNestedInput
    vendedor?: UsuarioUpdateOneRequiredWithoutRopasNestedInput
    categorias?: CategoriaUpdateManyWithoutRopasNestedInput
    fotos?: FotoUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUpdateManyWithoutRopaNestedInput
  }

  export type RopaUncheckedUpdateWithoutOrdenesInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendedorId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    proveedorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CategoriaUncheckedUpdateManyWithoutRopasNestedInput
    fotos?: FotoUncheckedUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutRopaNestedInput
  }

  export type PedidoRopaCreateWithoutPedidoInput = {
    cantidad: number
    subtotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropa: RopaCreateNestedOneWithoutOrdenesInput
  }

  export type PedidoRopaUncheckedCreateWithoutPedidoInput = {
    id?: number
    idRopa: number
    cantidad: number
    subtotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoRopaCreateOrConnectWithoutPedidoInput = {
    where: PedidoRopaWhereUniqueInput
    create: XOR<PedidoRopaCreateWithoutPedidoInput, PedidoRopaUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoRopaCreateManyPedidoInputEnvelope = {
    data: Enumerable<PedidoRopaCreateManyPedidoInput>
    skipDuplicates?: boolean
  }

  export type EvaluacionCreateWithoutPedidoInput = {
    nombre: string
    nota: number
    descripcion?: string | null
    usuarioRol: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEvaluacionesInput
  }

  export type EvaluacionUncheckedCreateWithoutPedidoInput = {
    id?: number
    nombre: string
    usuarioId: number
    nota: number
    descripcion?: string | null
    usuarioRol: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluacionCreateOrConnectWithoutPedidoInput = {
    where: EvaluacionWhereUniqueInput
    create: XOR<EvaluacionCreateWithoutPedidoInput, EvaluacionUncheckedCreateWithoutPedidoInput>
  }

  export type EvaluacionCreateManyPedidoInputEnvelope = {
    data: Enumerable<EvaluacionCreateManyPedidoInput>
    skipDuplicates?: boolean
  }

  export type DireccionCreateWithoutPedidosInput = {
    provincia: string
    canton: string
    distrito: string
    direccionExacta: string
    codPostal: string
    telef: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutDireccionesInput
  }

  export type DireccionUncheckedCreateWithoutPedidosInput = {
    id?: number
    usuarioId: number
    provincia: string
    canton: string
    distrito: string
    direccionExacta: string
    codPostal: string
    telef: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DireccionCreateOrConnectWithoutPedidosInput = {
    where: DireccionWhereUniqueInput
    create: XOR<DireccionCreateWithoutPedidosInput, DireccionUncheckedCreateWithoutPedidosInput>
  }

  export type MetodoPagoCreateWithoutPedidosInput = {
    descripcion: string
    proveedor: string
    numeroCuenta: string
    fechaExpiracion: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutMetodosInput
  }

  export type MetodoPagoUncheckedCreateWithoutPedidosInput = {
    id?: number
    idCliente: number
    descripcion: string
    proveedor: string
    numeroCuenta: string
    fechaExpiracion: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetodoPagoCreateOrConnectWithoutPedidosInput = {
    where: MetodoPagoWhereUniqueInput
    create: XOR<MetodoPagoCreateWithoutPedidosInput, MetodoPagoUncheckedCreateWithoutPedidosInput>
  }

  export type UsuarioCreateWithoutPedidosInput = {
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaCreateNestedManyWithoutUsuarioInput
    informes?: InformeCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutUsuarioInput
    ropas?: RopaCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioUncheckedCreateWithoutPedidosInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoUncheckedCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutUsuarioInput
    informes?: InformeUncheckedCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutUsuarioInput
    ropas?: RopaUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioCreateOrConnectWithoutPedidosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type PedidoRopaUpsertWithWhereUniqueWithoutPedidoInput = {
    where: PedidoRopaWhereUniqueInput
    update: XOR<PedidoRopaUpdateWithoutPedidoInput, PedidoRopaUncheckedUpdateWithoutPedidoInput>
    create: XOR<PedidoRopaCreateWithoutPedidoInput, PedidoRopaUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoRopaUpdateWithWhereUniqueWithoutPedidoInput = {
    where: PedidoRopaWhereUniqueInput
    data: XOR<PedidoRopaUpdateWithoutPedidoInput, PedidoRopaUncheckedUpdateWithoutPedidoInput>
  }

  export type PedidoRopaUpdateManyWithWhereWithoutPedidoInput = {
    where: PedidoRopaScalarWhereInput
    data: XOR<PedidoRopaUpdateManyMutationInput, PedidoRopaUncheckedUpdateManyWithoutRopasInput>
  }

  export type EvaluacionUpsertWithWhereUniqueWithoutPedidoInput = {
    where: EvaluacionWhereUniqueInput
    update: XOR<EvaluacionUpdateWithoutPedidoInput, EvaluacionUncheckedUpdateWithoutPedidoInput>
    create: XOR<EvaluacionCreateWithoutPedidoInput, EvaluacionUncheckedCreateWithoutPedidoInput>
  }

  export type EvaluacionUpdateWithWhereUniqueWithoutPedidoInput = {
    where: EvaluacionWhereUniqueInput
    data: XOR<EvaluacionUpdateWithoutPedidoInput, EvaluacionUncheckedUpdateWithoutPedidoInput>
  }

  export type EvaluacionUpdateManyWithWhereWithoutPedidoInput = {
    where: EvaluacionScalarWhereInput
    data: XOR<EvaluacionUpdateManyMutationInput, EvaluacionUncheckedUpdateManyWithoutEvaluacionesInput>
  }

  export type EvaluacionScalarWhereInput = {
    AND?: Enumerable<EvaluacionScalarWhereInput>
    OR?: Enumerable<EvaluacionScalarWhereInput>
    NOT?: Enumerable<EvaluacionScalarWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    usuarioId?: IntFilter | number
    pedidoId?: IntFilter | number
    nota?: IntFilter | number
    descripcion?: StringNullableFilter | string | null
    usuarioRol?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DireccionUpsertWithoutPedidosInput = {
    update: XOR<DireccionUpdateWithoutPedidosInput, DireccionUncheckedUpdateWithoutPedidosInput>
    create: XOR<DireccionCreateWithoutPedidosInput, DireccionUncheckedCreateWithoutPedidosInput>
  }

  export type DireccionUpdateWithoutPedidosInput = {
    provincia?: StringFieldUpdateOperationsInput | string
    canton?: StringFieldUpdateOperationsInput | string
    distrito?: StringFieldUpdateOperationsInput | string
    direccionExacta?: StringFieldUpdateOperationsInput | string
    codPostal?: StringFieldUpdateOperationsInput | string
    telef?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutDireccionesNestedInput
  }

  export type DireccionUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    provincia?: StringFieldUpdateOperationsInput | string
    canton?: StringFieldUpdateOperationsInput | string
    distrito?: StringFieldUpdateOperationsInput | string
    direccionExacta?: StringFieldUpdateOperationsInput | string
    codPostal?: StringFieldUpdateOperationsInput | string
    telef?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetodoPagoUpsertWithoutPedidosInput = {
    update: XOR<MetodoPagoUpdateWithoutPedidosInput, MetodoPagoUncheckedUpdateWithoutPedidosInput>
    create: XOR<MetodoPagoCreateWithoutPedidosInput, MetodoPagoUncheckedCreateWithoutPedidosInput>
  }

  export type MetodoPagoUpdateWithoutPedidosInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    numeroCuenta?: StringFieldUpdateOperationsInput | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutMetodosNestedInput
  }

  export type MetodoPagoUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCliente?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    numeroCuenta?: StringFieldUpdateOperationsInput | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUpsertWithoutPedidosInput = {
    update: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type UsuarioUpdateWithoutPedidosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUncheckedUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUncheckedUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUncheckedUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type MetodoPagoCreateWithoutUsuarioInput = {
    descripcion: string
    proveedor: string
    numeroCuenta: string
    fechaExpiracion: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoCreateNestedManyWithoutMetodoInput
  }

  export type MetodoPagoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    descripcion: string
    proveedor: string
    numeroCuenta: string
    fechaExpiracion: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutMetodoInput
  }

  export type MetodoPagoCreateOrConnectWithoutUsuarioInput = {
    where: MetodoPagoWhereUniqueInput
    create: XOR<MetodoPagoCreateWithoutUsuarioInput, MetodoPagoUncheckedCreateWithoutUsuarioInput>
  }

  export type MetodoPagoCreateManyUsuarioInputEnvelope = {
    data: Enumerable<MetodoPagoCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutUsuarioInput = {
    fechaOrden?: Date | string
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaCreateNestedManyWithoutPedidoInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutPedidoInput
    direccion: DireccionCreateNestedOneWithoutPedidosInput
    metodo: MetodoPagoCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    fechaOrden?: Date | string
    idPago: number
    direccionId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaUncheckedCreateNestedManyWithoutPedidoInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoCreateManyUsuarioInputEnvelope = {
    data: Enumerable<PedidoCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type DireccionCreateWithoutUsuarioInput = {
    provincia: string
    canton: string
    distrito: string
    direccionExacta: string
    codPostal: string
    telef: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoCreateNestedManyWithoutDireccionInput
  }

  export type DireccionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    provincia: string
    canton: string
    distrito: string
    direccionExacta: string
    codPostal: string
    telef: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutDireccionInput
  }

  export type DireccionCreateOrConnectWithoutUsuarioInput = {
    where: DireccionWhereUniqueInput
    create: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput>
  }

  export type DireccionCreateManyUsuarioInputEnvelope = {
    data: Enumerable<DireccionCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type PreguntaCreateWithoutUsuarioInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropa: RopaCreateNestedOneWithoutPreguntasInput
    respuestas?: RespuestaCreateNestedManyWithoutPreguntasInput
  }

  export type PreguntaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    descripcion: string
    ropaId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type PreguntaCreateOrConnectWithoutUsuarioInput = {
    where: PreguntaWhereUniqueInput
    create: XOR<PreguntaCreateWithoutUsuarioInput, PreguntaUncheckedCreateWithoutUsuarioInput>
  }

  export type PreguntaCreateManyUsuarioInputEnvelope = {
    data: Enumerable<PreguntaCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type RespuestaCreateWithoutUsuarioInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preguntas?: PreguntaCreateNestedManyWithoutRespuestasInput
  }

  export type RespuestaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutRespuestasInput
  }

  export type RespuestaCreateOrConnectWithoutUsuarioInput = {
    where: RespuestaWhereUniqueInput
    create: XOR<RespuestaCreateWithoutUsuarioInput, RespuestaUncheckedCreateWithoutUsuarioInput>
  }

  export type RespuestaCreateManyUsuarioInputEnvelope = {
    data: Enumerable<RespuestaCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type InformeCreateWithoutUsuarioInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InformeUncheckedCreateWithoutUsuarioInput = {
    id?: number
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InformeCreateOrConnectWithoutUsuarioInput = {
    where: InformeWhereUniqueInput
    create: XOR<InformeCreateWithoutUsuarioInput, InformeUncheckedCreateWithoutUsuarioInput>
  }

  export type InformeCreateManyUsuarioInputEnvelope = {
    data: Enumerable<InformeCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type EvaluacionCreateWithoutUsuarioInput = {
    nombre: string
    nota: number
    descripcion?: string | null
    usuarioRol: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutEvaluacionesInput
  }

  export type EvaluacionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nombre: string
    pedidoId: number
    nota: number
    descripcion?: string | null
    usuarioRol: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluacionCreateOrConnectWithoutUsuarioInput = {
    where: EvaluacionWhereUniqueInput
    create: XOR<EvaluacionCreateWithoutUsuarioInput, EvaluacionUncheckedCreateWithoutUsuarioInput>
  }

  export type EvaluacionCreateManyUsuarioInputEnvelope = {
    data: Enumerable<EvaluacionCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type RopaCreateWithoutVendedorInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proveedor: ProveedorCreateNestedOneWithoutRopasInput
    categorias?: CategoriaCreateNestedManyWithoutRopasInput
    fotos?: FotoCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaCreateNestedManyWithoutRopaInput
  }

  export type RopaUncheckedCreateWithoutVendedorInput = {
    id?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    proveedorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categorias?: CategoriaUncheckedCreateNestedManyWithoutRopasInput
    fotos?: FotoUncheckedCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaUncheckedCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutRopaInput
  }

  export type RopaCreateOrConnectWithoutVendedorInput = {
    where: RopaWhereUniqueInput
    create: XOR<RopaCreateWithoutVendedorInput, RopaUncheckedCreateWithoutVendedorInput>
  }

  export type RopaCreateManyVendedorInputEnvelope = {
    data: Enumerable<RopaCreateManyVendedorInput>
    skipDuplicates?: boolean
  }

  export type MetodoPagoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: MetodoPagoWhereUniqueInput
    update: XOR<MetodoPagoUpdateWithoutUsuarioInput, MetodoPagoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<MetodoPagoCreateWithoutUsuarioInput, MetodoPagoUncheckedCreateWithoutUsuarioInput>
  }

  export type MetodoPagoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: MetodoPagoWhereUniqueInput
    data: XOR<MetodoPagoUpdateWithoutUsuarioInput, MetodoPagoUncheckedUpdateWithoutUsuarioInput>
  }

  export type MetodoPagoUpdateManyWithWhereWithoutUsuarioInput = {
    where: MetodoPagoScalarWhereInput
    data: XOR<MetodoPagoUpdateManyMutationInput, MetodoPagoUncheckedUpdateManyWithoutMetodosInput>
  }

  export type MetodoPagoScalarWhereInput = {
    AND?: Enumerable<MetodoPagoScalarWhereInput>
    OR?: Enumerable<MetodoPagoScalarWhereInput>
    NOT?: Enumerable<MetodoPagoScalarWhereInput>
    id?: IntFilter | number
    idCliente?: IntFilter | number
    descripcion?: StringFilter | string
    proveedor?: StringFilter | string
    numeroCuenta?: StringFilter | string
    fechaExpiracion?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PedidoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PedidoUpdateManyWithWhereWithoutUsuarioInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: Enumerable<PedidoScalarWhereInput>
    OR?: Enumerable<PedidoScalarWhereInput>
    NOT?: Enumerable<PedidoScalarWhereInput>
    id?: IntFilter | number
    fechaOrden?: DateTimeFilter | Date | string
    idPago?: IntFilter | number
    clienteId?: IntFilter | number
    direccionId?: IntFilter | number
    descuento?: DecimalFilter | Decimal | DecimalJsLike | number | string
    IV?: DecimalFilter | Decimal | DecimalJsLike | number | string
    estado?: StringFilter | string
    subtotal?: DecimalFilter | Decimal | DecimalJsLike | number | string
    Total?: DecimalFilter | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DireccionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: DireccionWhereUniqueInput
    update: XOR<DireccionUpdateWithoutUsuarioInput, DireccionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput>
  }

  export type DireccionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: DireccionWhereUniqueInput
    data: XOR<DireccionUpdateWithoutUsuarioInput, DireccionUncheckedUpdateWithoutUsuarioInput>
  }

  export type DireccionUpdateManyWithWhereWithoutUsuarioInput = {
    where: DireccionScalarWhereInput
    data: XOR<DireccionUpdateManyMutationInput, DireccionUncheckedUpdateManyWithoutDireccionesInput>
  }

  export type DireccionScalarWhereInput = {
    AND?: Enumerable<DireccionScalarWhereInput>
    OR?: Enumerable<DireccionScalarWhereInput>
    NOT?: Enumerable<DireccionScalarWhereInput>
    id?: IntFilter | number
    usuarioId?: IntFilter | number
    provincia?: StringFilter | string
    canton?: StringFilter | string
    distrito?: StringFilter | string
    direccionExacta?: StringFilter | string
    codPostal?: StringFilter | string
    telef?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PreguntaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PreguntaWhereUniqueInput
    update: XOR<PreguntaUpdateWithoutUsuarioInput, PreguntaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PreguntaCreateWithoutUsuarioInput, PreguntaUncheckedCreateWithoutUsuarioInput>
  }

  export type PreguntaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PreguntaWhereUniqueInput
    data: XOR<PreguntaUpdateWithoutUsuarioInput, PreguntaUncheckedUpdateWithoutUsuarioInput>
  }

  export type PreguntaUpdateManyWithWhereWithoutUsuarioInput = {
    where: PreguntaScalarWhereInput
    data: XOR<PreguntaUpdateManyMutationInput, PreguntaUncheckedUpdateManyWithoutPreguntasInput>
  }

  export type RespuestaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: RespuestaWhereUniqueInput
    update: XOR<RespuestaUpdateWithoutUsuarioInput, RespuestaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<RespuestaCreateWithoutUsuarioInput, RespuestaUncheckedCreateWithoutUsuarioInput>
  }

  export type RespuestaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: RespuestaWhereUniqueInput
    data: XOR<RespuestaUpdateWithoutUsuarioInput, RespuestaUncheckedUpdateWithoutUsuarioInput>
  }

  export type RespuestaUpdateManyWithWhereWithoutUsuarioInput = {
    where: RespuestaScalarWhereInput
    data: XOR<RespuestaUpdateManyMutationInput, RespuestaUncheckedUpdateManyWithoutRespuestasInput>
  }

  export type RespuestaScalarWhereInput = {
    AND?: Enumerable<RespuestaScalarWhereInput>
    OR?: Enumerable<RespuestaScalarWhereInput>
    NOT?: Enumerable<RespuestaScalarWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    usuarioId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InformeUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: InformeWhereUniqueInput
    update: XOR<InformeUpdateWithoutUsuarioInput, InformeUncheckedUpdateWithoutUsuarioInput>
    create: XOR<InformeCreateWithoutUsuarioInput, InformeUncheckedCreateWithoutUsuarioInput>
  }

  export type InformeUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: InformeWhereUniqueInput
    data: XOR<InformeUpdateWithoutUsuarioInput, InformeUncheckedUpdateWithoutUsuarioInput>
  }

  export type InformeUpdateManyWithWhereWithoutUsuarioInput = {
    where: InformeScalarWhereInput
    data: XOR<InformeUpdateManyMutationInput, InformeUncheckedUpdateManyWithoutInformesInput>
  }

  export type InformeScalarWhereInput = {
    AND?: Enumerable<InformeScalarWhereInput>
    OR?: Enumerable<InformeScalarWhereInput>
    NOT?: Enumerable<InformeScalarWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    usuarioId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type EvaluacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: EvaluacionWhereUniqueInput
    update: XOR<EvaluacionUpdateWithoutUsuarioInput, EvaluacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EvaluacionCreateWithoutUsuarioInput, EvaluacionUncheckedCreateWithoutUsuarioInput>
  }

  export type EvaluacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: EvaluacionWhereUniqueInput
    data: XOR<EvaluacionUpdateWithoutUsuarioInput, EvaluacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type EvaluacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: EvaluacionScalarWhereInput
    data: XOR<EvaluacionUpdateManyMutationInput, EvaluacionUncheckedUpdateManyWithoutEvaluacionesInput>
  }

  export type RopaUpsertWithWhereUniqueWithoutVendedorInput = {
    where: RopaWhereUniqueInput
    update: XOR<RopaUpdateWithoutVendedorInput, RopaUncheckedUpdateWithoutVendedorInput>
    create: XOR<RopaCreateWithoutVendedorInput, RopaUncheckedCreateWithoutVendedorInput>
  }

  export type RopaUpdateWithWhereUniqueWithoutVendedorInput = {
    where: RopaWhereUniqueInput
    data: XOR<RopaUpdateWithoutVendedorInput, RopaUncheckedUpdateWithoutVendedorInput>
  }

  export type RopaUpdateManyWithWhereWithoutVendedorInput = {
    where: RopaScalarWhereInput
    data: XOR<RopaUpdateManyMutationInput, RopaUncheckedUpdateManyWithoutRopasInput>
  }

  export type UsuarioCreateWithoutMetodosInput = {
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaCreateNestedManyWithoutUsuarioInput
    informes?: InformeCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutUsuarioInput
    ropas?: RopaCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioUncheckedCreateWithoutMetodosInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutUsuarioInput
    informes?: InformeUncheckedCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutUsuarioInput
    ropas?: RopaUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioCreateOrConnectWithoutMetodosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutMetodosInput, UsuarioUncheckedCreateWithoutMetodosInput>
  }

  export type PedidoCreateWithoutMetodoInput = {
    fechaOrden?: Date | string
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaCreateNestedManyWithoutPedidoInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutPedidoInput
    direccion: DireccionCreateNestedOneWithoutPedidosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutMetodoInput = {
    id?: number
    fechaOrden?: Date | string
    clienteId: number
    direccionId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaUncheckedCreateNestedManyWithoutPedidoInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutMetodoInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutMetodoInput, PedidoUncheckedCreateWithoutMetodoInput>
  }

  export type PedidoCreateManyMetodoInputEnvelope = {
    data: Enumerable<PedidoCreateManyMetodoInput>
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutMetodosInput = {
    update: XOR<UsuarioUpdateWithoutMetodosInput, UsuarioUncheckedUpdateWithoutMetodosInput>
    create: XOR<UsuarioCreateWithoutMetodosInput, UsuarioUncheckedCreateWithoutMetodosInput>
  }

  export type UsuarioUpdateWithoutMetodosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutMetodosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUncheckedUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUncheckedUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type PedidoUpsertWithWhereUniqueWithoutMetodoInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutMetodoInput, PedidoUncheckedUpdateWithoutMetodoInput>
    create: XOR<PedidoCreateWithoutMetodoInput, PedidoUncheckedCreateWithoutMetodoInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutMetodoInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutMetodoInput, PedidoUncheckedUpdateWithoutMetodoInput>
  }

  export type PedidoUpdateManyWithWhereWithoutMetodoInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type UsuarioCreateWithoutPreguntasInput = {
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaCreateNestedManyWithoutUsuarioInput
    informes?: InformeCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutUsuarioInput
    ropas?: RopaCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioUncheckedCreateWithoutPreguntasInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutUsuarioInput
    informes?: InformeUncheckedCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutUsuarioInput
    ropas?: RopaUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioCreateOrConnectWithoutPreguntasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPreguntasInput, UsuarioUncheckedCreateWithoutPreguntasInput>
  }

  export type RopaCreateWithoutPreguntasInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proveedor: ProveedorCreateNestedOneWithoutRopasInput
    vendedor: UsuarioCreateNestedOneWithoutRopasInput
    categorias?: CategoriaCreateNestedManyWithoutRopasInput
    fotos?: FotoCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaCreateNestedManyWithoutRopaInput
  }

  export type RopaUncheckedCreateWithoutPreguntasInput = {
    id?: number
    vendedorId: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    proveedorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categorias?: CategoriaUncheckedCreateNestedManyWithoutRopasInput
    fotos?: FotoUncheckedCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaUncheckedCreateNestedManyWithoutRopaInput
  }

  export type RopaCreateOrConnectWithoutPreguntasInput = {
    where: RopaWhereUniqueInput
    create: XOR<RopaCreateWithoutPreguntasInput, RopaUncheckedCreateWithoutPreguntasInput>
  }

  export type RespuestaCreateWithoutPreguntasInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutRespuestasInput
  }

  export type RespuestaUncheckedCreateWithoutPreguntasInput = {
    id?: number
    descripcion: string
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RespuestaCreateOrConnectWithoutPreguntasInput = {
    where: RespuestaWhereUniqueInput
    create: XOR<RespuestaCreateWithoutPreguntasInput, RespuestaUncheckedCreateWithoutPreguntasInput>
  }

  export type UsuarioUpsertWithoutPreguntasInput = {
    update: XOR<UsuarioUpdateWithoutPreguntasInput, UsuarioUncheckedUpdateWithoutPreguntasInput>
    create: XOR<UsuarioCreateWithoutPreguntasInput, UsuarioUncheckedCreateWithoutPreguntasInput>
  }

  export type UsuarioUpdateWithoutPreguntasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPreguntasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUncheckedUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUncheckedUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type RopaUpsertWithoutPreguntasInput = {
    update: XOR<RopaUpdateWithoutPreguntasInput, RopaUncheckedUpdateWithoutPreguntasInput>
    create: XOR<RopaCreateWithoutPreguntasInput, RopaUncheckedCreateWithoutPreguntasInput>
  }

  export type RopaUpdateWithoutPreguntasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proveedor?: ProveedorUpdateOneRequiredWithoutRopasNestedInput
    vendedor?: UsuarioUpdateOneRequiredWithoutRopasNestedInput
    categorias?: CategoriaUpdateManyWithoutRopasNestedInput
    fotos?: FotoUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUpdateManyWithoutRopaNestedInput
  }

  export type RopaUncheckedUpdateWithoutPreguntasInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendedorId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    proveedorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CategoriaUncheckedUpdateManyWithoutRopasNestedInput
    fotos?: FotoUncheckedUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUncheckedUpdateManyWithoutRopaNestedInput
  }

  export type RespuestaUpsertWithWhereUniqueWithoutPreguntasInput = {
    where: RespuestaWhereUniqueInput
    update: XOR<RespuestaUpdateWithoutPreguntasInput, RespuestaUncheckedUpdateWithoutPreguntasInput>
    create: XOR<RespuestaCreateWithoutPreguntasInput, RespuestaUncheckedCreateWithoutPreguntasInput>
  }

  export type RespuestaUpdateWithWhereUniqueWithoutPreguntasInput = {
    where: RespuestaWhereUniqueInput
    data: XOR<RespuestaUpdateWithoutPreguntasInput, RespuestaUncheckedUpdateWithoutPreguntasInput>
  }

  export type RespuestaUpdateManyWithWhereWithoutPreguntasInput = {
    where: RespuestaScalarWhereInput
    data: XOR<RespuestaUpdateManyMutationInput, RespuestaUncheckedUpdateManyWithoutRespuestasInput>
  }

  export type UsuarioCreateWithoutRespuestasInput = {
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaCreateNestedManyWithoutUsuarioInput
    informes?: InformeCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutUsuarioInput
    ropas?: RopaCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioUncheckedCreateWithoutRespuestasInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutUsuarioInput
    informes?: InformeUncheckedCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutUsuarioInput
    ropas?: RopaUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioCreateOrConnectWithoutRespuestasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRespuestasInput, UsuarioUncheckedCreateWithoutRespuestasInput>
  }

  export type PreguntaCreateWithoutRespuestasInput = {
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutPreguntasInput
    ropa: RopaCreateNestedOneWithoutPreguntasInput
  }

  export type PreguntaUncheckedCreateWithoutRespuestasInput = {
    id?: number
    descripcion: string
    usuarioId: number
    ropaId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreguntaCreateOrConnectWithoutRespuestasInput = {
    where: PreguntaWhereUniqueInput
    create: XOR<PreguntaCreateWithoutRespuestasInput, PreguntaUncheckedCreateWithoutRespuestasInput>
  }

  export type UsuarioUpsertWithoutRespuestasInput = {
    update: XOR<UsuarioUpdateWithoutRespuestasInput, UsuarioUncheckedUpdateWithoutRespuestasInput>
    create: XOR<UsuarioCreateWithoutRespuestasInput, UsuarioUncheckedCreateWithoutRespuestasInput>
  }

  export type UsuarioUpdateWithoutRespuestasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRespuestasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUncheckedUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type PreguntaUpsertWithWhereUniqueWithoutRespuestasInput = {
    where: PreguntaWhereUniqueInput
    update: XOR<PreguntaUpdateWithoutRespuestasInput, PreguntaUncheckedUpdateWithoutRespuestasInput>
    create: XOR<PreguntaCreateWithoutRespuestasInput, PreguntaUncheckedCreateWithoutRespuestasInput>
  }

  export type PreguntaUpdateWithWhereUniqueWithoutRespuestasInput = {
    where: PreguntaWhereUniqueInput
    data: XOR<PreguntaUpdateWithoutRespuestasInput, PreguntaUncheckedUpdateWithoutRespuestasInput>
  }

  export type PreguntaUpdateManyWithWhereWithoutRespuestasInput = {
    where: PreguntaScalarWhereInput
    data: XOR<PreguntaUpdateManyMutationInput, PreguntaUncheckedUpdateManyWithoutPreguntasInput>
  }

  export type UsuarioCreateWithoutInformesInput = {
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutUsuarioInput
    ropas?: RopaCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioUncheckedCreateWithoutInformesInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutUsuarioInput
    ropas?: RopaUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioCreateOrConnectWithoutInformesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutInformesInput, UsuarioUncheckedCreateWithoutInformesInput>
  }

  export type UsuarioUpsertWithoutInformesInput = {
    update: XOR<UsuarioUpdateWithoutInformesInput, UsuarioUncheckedUpdateWithoutInformesInput>
    create: XOR<UsuarioCreateWithoutInformesInput, UsuarioUncheckedCreateWithoutInformesInput>
  }

  export type UsuarioUpdateWithoutInformesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutInformesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUncheckedUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioCreateWithoutEvaluacionesInput = {
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaCreateNestedManyWithoutUsuarioInput
    informes?: InformeCreateNestedManyWithoutUsuarioInput
    ropas?: RopaCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioUncheckedCreateWithoutEvaluacionesInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    direcciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutUsuarioInput
    informes?: InformeUncheckedCreateNestedManyWithoutUsuarioInput
    ropas?: RopaUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioCreateOrConnectWithoutEvaluacionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEvaluacionesInput, UsuarioUncheckedCreateWithoutEvaluacionesInput>
  }

  export type PedidoCreateWithoutEvaluacionesInput = {
    fechaOrden?: Date | string
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaCreateNestedManyWithoutPedidoInput
    direccion: DireccionCreateNestedOneWithoutPedidosInput
    metodo: MetodoPagoCreateNestedOneWithoutPedidosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutEvaluacionesInput = {
    id?: number
    fechaOrden?: Date | string
    idPago: number
    clienteId: number
    direccionId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutEvaluacionesInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutEvaluacionesInput, PedidoUncheckedCreateWithoutEvaluacionesInput>
  }

  export type UsuarioUpsertWithoutEvaluacionesInput = {
    update: XOR<UsuarioUpdateWithoutEvaluacionesInput, UsuarioUncheckedUpdateWithoutEvaluacionesInput>
    create: XOR<UsuarioCreateWithoutEvaluacionesInput, UsuarioUncheckedCreateWithoutEvaluacionesInput>
  }

  export type UsuarioUpdateWithoutEvaluacionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEvaluacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    direcciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUncheckedUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUncheckedUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type PedidoUpsertWithoutEvaluacionesInput = {
    update: XOR<PedidoUpdateWithoutEvaluacionesInput, PedidoUncheckedUpdateWithoutEvaluacionesInput>
    create: XOR<PedidoCreateWithoutEvaluacionesInput, PedidoUncheckedCreateWithoutEvaluacionesInput>
  }

  export type PedidoUpdateWithoutEvaluacionesInput = {
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUpdateManyWithoutPedidoNestedInput
    direccion?: DireccionUpdateOneRequiredWithoutPedidosNestedInput
    metodo?: MetodoPagoUpdateOneRequiredWithoutPedidosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutEvaluacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    idPago?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    direccionId?: IntFieldUpdateOperationsInput | number
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type RopaCreateWithoutCategoriasInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proveedor: ProveedorCreateNestedOneWithoutRopasInput
    vendedor: UsuarioCreateNestedOneWithoutRopasInput
    fotos?: FotoCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaCreateNestedManyWithoutRopaInput
  }

  export type RopaUncheckedCreateWithoutCategoriasInput = {
    id?: number
    vendedorId: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    proveedorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fotos?: FotoUncheckedCreateNestedManyWithoutRopaInput
    ordenes?: PedidoRopaUncheckedCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutRopaInput
  }

  export type RopaCreateOrConnectWithoutCategoriasInput = {
    where: RopaWhereUniqueInput
    create: XOR<RopaCreateWithoutCategoriasInput, RopaUncheckedCreateWithoutCategoriasInput>
  }

  export type RopaUpsertWithWhereUniqueWithoutCategoriasInput = {
    where: RopaWhereUniqueInput
    update: XOR<RopaUpdateWithoutCategoriasInput, RopaUncheckedUpdateWithoutCategoriasInput>
    create: XOR<RopaCreateWithoutCategoriasInput, RopaUncheckedCreateWithoutCategoriasInput>
  }

  export type RopaUpdateWithWhereUniqueWithoutCategoriasInput = {
    where: RopaWhereUniqueInput
    data: XOR<RopaUpdateWithoutCategoriasInput, RopaUncheckedUpdateWithoutCategoriasInput>
  }

  export type RopaUpdateManyWithWhereWithoutCategoriasInput = {
    where: RopaScalarWhereInput
    data: XOR<RopaUpdateManyMutationInput, RopaUncheckedUpdateManyWithoutRopasInput>
  }

  export type UsuarioCreateWithoutDireccionesInput = {
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaCreateNestedManyWithoutUsuarioInput
    informes?: InformeCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutUsuarioInput
    ropas?: RopaCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioUncheckedCreateWithoutDireccionesInput = {
    id?: number
    nombre: string
    cedula: string
    telefono: string
    correo: string
    contrasenna: string
    estado: boolean
    rol?: Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    metodos?: MetodoPagoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestas?: RespuestaUncheckedCreateNestedManyWithoutUsuarioInput
    informes?: InformeUncheckedCreateNestedManyWithoutUsuarioInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutUsuarioInput
    ropas?: RopaUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type UsuarioCreateOrConnectWithoutDireccionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutDireccionesInput, UsuarioUncheckedCreateWithoutDireccionesInput>
  }

  export type PedidoCreateWithoutDireccionInput = {
    fechaOrden?: Date | string
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaCreateNestedManyWithoutPedidoInput
    evaluaciones?: EvaluacionCreateNestedManyWithoutPedidoInput
    metodo: MetodoPagoCreateNestedOneWithoutPedidosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutDireccionInput = {
    id?: number
    fechaOrden?: Date | string
    idPago: number
    clienteId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ropas?: PedidoRopaUncheckedCreateNestedManyWithoutPedidoInput
    evaluaciones?: EvaluacionUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutDireccionInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutDireccionInput, PedidoUncheckedCreateWithoutDireccionInput>
  }

  export type PedidoCreateManyDireccionInputEnvelope = {
    data: Enumerable<PedidoCreateManyDireccionInput>
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutDireccionesInput = {
    update: XOR<UsuarioUpdateWithoutDireccionesInput, UsuarioUncheckedUpdateWithoutDireccionesInput>
    create: XOR<UsuarioCreateWithoutDireccionesInput, UsuarioUncheckedCreateWithoutDireccionesInput>
  }

  export type UsuarioUpdateWithoutDireccionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUpdateManyWithoutVendedorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutDireccionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metodos?: MetodoPagoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestas?: RespuestaUncheckedUpdateManyWithoutUsuarioNestedInput
    informes?: InformeUncheckedUpdateManyWithoutUsuarioNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutUsuarioNestedInput
    ropas?: RopaUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type PedidoUpsertWithWhereUniqueWithoutDireccionInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutDireccionInput, PedidoUncheckedUpdateWithoutDireccionInput>
    create: XOR<PedidoCreateWithoutDireccionInput, PedidoUncheckedCreateWithoutDireccionInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutDireccionInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutDireccionInput, PedidoUncheckedUpdateWithoutDireccionInput>
  }

  export type PedidoUpdateManyWithWhereWithoutDireccionInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type RopaCreateWithoutFotosInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proveedor: ProveedorCreateNestedOneWithoutRopasInput
    vendedor: UsuarioCreateNestedOneWithoutRopasInput
    categorias?: CategoriaCreateNestedManyWithoutRopasInput
    ordenes?: PedidoRopaCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaCreateNestedManyWithoutRopaInput
  }

  export type RopaUncheckedCreateWithoutFotosInput = {
    id?: number
    vendedorId: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    proveedorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categorias?: CategoriaUncheckedCreateNestedManyWithoutRopasInput
    ordenes?: PedidoRopaUncheckedCreateNestedManyWithoutRopaInput
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutRopaInput
  }

  export type RopaCreateOrConnectWithoutFotosInput = {
    where: RopaWhereUniqueInput
    create: XOR<RopaCreateWithoutFotosInput, RopaUncheckedCreateWithoutFotosInput>
  }

  export type RopaUpsertWithoutFotosInput = {
    update: XOR<RopaUpdateWithoutFotosInput, RopaUncheckedUpdateWithoutFotosInput>
    create: XOR<RopaCreateWithoutFotosInput, RopaUncheckedCreateWithoutFotosInput>
  }

  export type RopaUpdateWithoutFotosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proveedor?: ProveedorUpdateOneRequiredWithoutRopasNestedInput
    vendedor?: UsuarioUpdateOneRequiredWithoutRopasNestedInput
    categorias?: CategoriaUpdateManyWithoutRopasNestedInput
    ordenes?: PedidoRopaUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUpdateManyWithoutRopaNestedInput
  }

  export type RopaUncheckedUpdateWithoutFotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendedorId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    proveedorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CategoriaUncheckedUpdateManyWithoutRopasNestedInput
    ordenes?: PedidoRopaUncheckedUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutRopaNestedInput
  }

  export type RopaCreateManyProveedorInput = {
    id?: number
    vendedorId: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RopaUpdateWithoutProveedorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendedor?: UsuarioUpdateOneRequiredWithoutRopasNestedInput
    categorias?: CategoriaUpdateManyWithoutRopasNestedInput
    fotos?: FotoUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUpdateManyWithoutRopaNestedInput
  }

  export type RopaUncheckedUpdateWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendedorId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CategoriaUncheckedUpdateManyWithoutRopasNestedInput
    fotos?: FotoUncheckedUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUncheckedUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutRopaNestedInput
  }

  export type RopaUncheckedUpdateManyWithoutRopasInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendedorId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FotoCreateManyRopaInput = {
    id?: number
    foto: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoRopaCreateManyRopaInput = {
    id?: number
    idPedido: number
    cantidad: number
    subtotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreguntaCreateManyRopaInput = {
    id?: number
    descripcion: string
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoriaUpdateWithoutRopasInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaUncheckedUpdateWithoutRopasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaUncheckedUpdateManyWithoutCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FotoUpdateWithoutRopaInput = {
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FotoUncheckedUpdateWithoutRopaInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FotoUncheckedUpdateManyWithoutFotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoRopaUpdateWithoutRopaInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutRopasNestedInput
  }

  export type PedidoRopaUncheckedUpdateWithoutRopaInput = {
    id?: IntFieldUpdateOperationsInput | number
    idPedido?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoRopaUncheckedUpdateManyWithoutOrdenesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idPedido?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreguntaUpdateWithoutRopaInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutPreguntasNestedInput
    respuestas?: RespuestaUpdateManyWithoutPreguntasNestedInput
  }

  export type PreguntaUncheckedUpdateWithoutRopaInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respuestas?: RespuestaUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type PreguntaUncheckedUpdateManyWithoutPreguntasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoRopaCreateManyPedidoInput = {
    id?: number
    idRopa: number
    cantidad: number
    subtotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluacionCreateManyPedidoInput = {
    id?: number
    nombre: string
    usuarioId: number
    nota: number
    descripcion?: string | null
    usuarioRol: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoRopaUpdateWithoutPedidoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropa?: RopaUpdateOneRequiredWithoutOrdenesNestedInput
  }

  export type PedidoRopaUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRopa?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoRopaUncheckedUpdateManyWithoutRopasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRopa?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluacionUpdateWithoutPedidoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioRol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEvaluacionesNestedInput
  }

  export type EvaluacionUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    nota?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioRol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluacionUncheckedUpdateManyWithoutEvaluacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    nota?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioRol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetodoPagoCreateManyUsuarioInput = {
    id?: number
    descripcion: string
    proveedor: string
    numeroCuenta: string
    fechaExpiracion: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoCreateManyUsuarioInput = {
    id?: number
    fechaOrden?: Date | string
    idPago: number
    direccionId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DireccionCreateManyUsuarioInput = {
    id?: number
    provincia: string
    canton: string
    distrito: string
    direccionExacta: string
    codPostal: string
    telef: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreguntaCreateManyUsuarioInput = {
    id?: number
    descripcion: string
    ropaId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RespuestaCreateManyUsuarioInput = {
    id?: number
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InformeCreateManyUsuarioInput = {
    id?: number
    descripcion: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluacionCreateManyUsuarioInput = {
    id?: number
    nombre: string
    pedidoId: number
    nota: number
    descripcion?: string | null
    usuarioRol: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RopaCreateManyVendedorInput = {
    id?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: string
    cantidad: number
    proveedorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetodoPagoUpdateWithoutUsuarioInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    numeroCuenta?: StringFieldUpdateOperationsInput | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUpdateManyWithoutMetodoNestedInput
  }

  export type MetodoPagoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    numeroCuenta?: StringFieldUpdateOperationsInput | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUncheckedUpdateManyWithoutMetodoNestedInput
  }

  export type MetodoPagoUncheckedUpdateManyWithoutMetodosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    proveedor?: StringFieldUpdateOperationsInput | string
    numeroCuenta?: StringFieldUpdateOperationsInput | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUpdateWithoutUsuarioInput = {
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUpdateManyWithoutPedidoNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutPedidoNestedInput
    direccion?: DireccionUpdateOneRequiredWithoutPedidosNestedInput
    metodo?: MetodoPagoUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    idPago?: IntFieldUpdateOperationsInput | number
    direccionId?: IntFieldUpdateOperationsInput | number
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUncheckedUpdateManyWithoutPedidoNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    idPago?: IntFieldUpdateOperationsInput | number
    direccionId?: IntFieldUpdateOperationsInput | number
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DireccionUpdateWithoutUsuarioInput = {
    provincia?: StringFieldUpdateOperationsInput | string
    canton?: StringFieldUpdateOperationsInput | string
    distrito?: StringFieldUpdateOperationsInput | string
    direccionExacta?: StringFieldUpdateOperationsInput | string
    codPostal?: StringFieldUpdateOperationsInput | string
    telef?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUpdateManyWithoutDireccionNestedInput
  }

  export type DireccionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    provincia?: StringFieldUpdateOperationsInput | string
    canton?: StringFieldUpdateOperationsInput | string
    distrito?: StringFieldUpdateOperationsInput | string
    direccionExacta?: StringFieldUpdateOperationsInput | string
    codPostal?: StringFieldUpdateOperationsInput | string
    telef?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUncheckedUpdateManyWithoutDireccionNestedInput
  }

  export type DireccionUncheckedUpdateManyWithoutDireccionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    provincia?: StringFieldUpdateOperationsInput | string
    canton?: StringFieldUpdateOperationsInput | string
    distrito?: StringFieldUpdateOperationsInput | string
    direccionExacta?: StringFieldUpdateOperationsInput | string
    codPostal?: StringFieldUpdateOperationsInput | string
    telef?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreguntaUpdateWithoutUsuarioInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropa?: RopaUpdateOneRequiredWithoutPreguntasNestedInput
    respuestas?: RespuestaUpdateManyWithoutPreguntasNestedInput
  }

  export type PreguntaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    ropaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respuestas?: RespuestaUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type RespuestaUpdateWithoutUsuarioInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: PreguntaUpdateManyWithoutRespuestasNestedInput
  }

  export type RespuestaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: PreguntaUncheckedUpdateManyWithoutRespuestasNestedInput
  }

  export type RespuestaUncheckedUpdateManyWithoutRespuestasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InformeUpdateWithoutUsuarioInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InformeUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InformeUncheckedUpdateManyWithoutInformesInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluacionUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioRol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutEvaluacionesNestedInput
  }

  export type EvaluacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    pedidoId?: IntFieldUpdateOperationsInput | number
    nota?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioRol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RopaUpdateWithoutVendedorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proveedor?: ProveedorUpdateOneRequiredWithoutRopasNestedInput
    categorias?: CategoriaUpdateManyWithoutRopasNestedInput
    fotos?: FotoUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUpdateManyWithoutRopaNestedInput
  }

  export type RopaUncheckedUpdateWithoutVendedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    proveedorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CategoriaUncheckedUpdateManyWithoutRopasNestedInput
    fotos?: FotoUncheckedUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUncheckedUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutRopaNestedInput
  }

  export type PedidoCreateManyMetodoInput = {
    id?: number
    fechaOrden?: Date | string
    clienteId: number
    direccionId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateWithoutMetodoInput = {
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUpdateManyWithoutPedidoNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutPedidoNestedInput
    direccion?: DireccionUpdateOneRequiredWithoutPedidosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutMetodoInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    clienteId?: IntFieldUpdateOperationsInput | number
    direccionId?: IntFieldUpdateOperationsInput | number
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUncheckedUpdateManyWithoutPedidoNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type RespuestaUpdateWithoutPreguntasInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutRespuestasNestedInput
  }

  export type RespuestaUncheckedUpdateWithoutPreguntasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreguntaUpdateWithoutRespuestasInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutPreguntasNestedInput
    ropa?: RopaUpdateOneRequiredWithoutPreguntasNestedInput
  }

  export type PreguntaUncheckedUpdateWithoutRespuestasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    ropaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RopaUpdateWithoutCategoriasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proveedor?: ProveedorUpdateOneRequiredWithoutRopasNestedInput
    vendedor?: UsuarioUpdateOneRequiredWithoutRopasNestedInput
    fotos?: FotoUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUpdateManyWithoutRopaNestedInput
  }

  export type RopaUncheckedUpdateWithoutCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendedorId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    proveedorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fotos?: FotoUncheckedUpdateManyWithoutRopaNestedInput
    ordenes?: PedidoRopaUncheckedUpdateManyWithoutRopaNestedInput
    preguntas?: PreguntaUncheckedUpdateManyWithoutRopaNestedInput
  }

  export type PedidoCreateManyDireccionInput = {
    id?: number
    fechaOrden?: Date | string
    idPago: number
    clienteId: number
    descuento: Decimal | DecimalJsLike | number | string
    IV: Decimal | DecimalJsLike | number | string
    estado: string
    subtotal: Decimal | DecimalJsLike | number | string
    Total: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateWithoutDireccionInput = {
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUpdateManyWithoutPedidoNestedInput
    evaluaciones?: EvaluacionUpdateManyWithoutPedidoNestedInput
    metodo?: MetodoPagoUpdateOneRequiredWithoutPedidosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutDireccionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaOrden?: DateTimeFieldUpdateOperationsInput | Date | string
    idPago?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    descuento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IV?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ropas?: PedidoRopaUncheckedUpdateManyWithoutPedidoNestedInput
    evaluaciones?: EvaluacionUncheckedUpdateManyWithoutPedidoNestedInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}